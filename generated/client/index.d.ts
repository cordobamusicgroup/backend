
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model InitializationStatus
 * 
 */
export type InitializationStatus = $Result.DefaultSelection<Prisma.$InitializationStatusPayload>
/**
 * Model S3File
 * 
 */
export type S3File = $Result.DefaultSelection<Prisma.$S3FilePayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = $Result.DefaultSelection<Prisma.$UserPreferencesPayload>
/**
 * Model UserComms
 * 
 */
export type UserComms = $Result.DefaultSelection<Prisma.$UserCommsPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ClientDMB
 * 
 */
export type ClientDMB = $Result.DefaultSelection<Prisma.$ClientDMBPayload>
/**
 * Model ClientPaymentInformation
 * 
 */
export type ClientPaymentInformation = $Result.DefaultSelection<Prisma.$ClientPaymentInformationPayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model Balance
 * 
 */
export type Balance = $Result.DefaultSelection<Prisma.$BalancePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model Label
 * 
 */
export type Label = $Result.DefaultSelection<Prisma.$LabelPayload>
/**
 * Model ImportedRoyaltyReport
 * 
 */
export type ImportedRoyaltyReport = $Result.DefaultSelection<Prisma.$ImportedRoyaltyReportPayload>
/**
 * Model BaseRoyaltyReport
 * 
 */
export type BaseRoyaltyReport = $Result.DefaultSelection<Prisma.$BaseRoyaltyReportPayload>
/**
 * Model UserRoyaltyReport
 * 
 */
export type UserRoyaltyReport = $Result.DefaultSelection<Prisma.$UserRoyaltyReportPayload>
/**
 * Model KontorRoyaltyReport
 * 
 */
export type KontorRoyaltyReport = $Result.DefaultSelection<Prisma.$KontorRoyaltyReportPayload>
/**
 * Model BelieveRoyaltyReport
 * 
 */
export type BelieveRoyaltyReport = $Result.DefaultSelection<Prisma.$BelieveRoyaltyReportPayload>
/**
 * Model UnlinkedReport
 * 
 */
export type UnlinkedReport = $Result.DefaultSelection<Prisma.$UnlinkedReportPayload>
/**
 * Model UnlinkedReportDetail
 * 
 */
export type UnlinkedReportDetail = $Result.DefaultSelection<Prisma.$UnlinkedReportDetailPayload>
/**
 * Model FailedReportDetail
 * 
 */
export type FailedReportDetail = $Result.DefaultSelection<Prisma.$FailedReportDetailPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Currency: {
  USD: 'USD',
  EUR: 'EUR',
  GBP: 'GBP'
};

export type Currency = (typeof Currency)[keyof typeof Currency]


export const Distributor: {
  BELIEVE: 'BELIEVE',
  KONTOR: 'KONTOR'
};

export type Distributor = (typeof Distributor)[keyof typeof Distributor]


export const PaymentMethod: {
  BANK_TRANSFER: 'BANK_TRANSFER',
  PAYPAL: 'PAYPAL',
  CRYPTO: 'CRYPTO'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const AccessTypeDMB: {
  STANDARD: 'STANDARD',
  ADVANCED: 'ADVANCED'
};

export type AccessTypeDMB = (typeof AccessTypeDMB)[keyof typeof AccessTypeDMB]


export const Role: {
  ADMIN: 'ADMIN',
  ADMIN_CONTENT: 'ADMIN_CONTENT',
  ADMIN_LEGAL: 'ADMIN_LEGAL',
  ADMIN_MANAGER: 'ADMIN_MANAGER',
  USER: 'USER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const CommsChannels: {
  MOBILE: 'MOBILE',
  PHONE: 'PHONE',
  SKYPE: 'SKYPE',
  X_TWITTER: 'X_TWITTER',
  FACEBOOK: 'FACEBOOK',
  INSTAGRAM: 'INSTAGRAM',
  TIKTOK: 'TIKTOK',
  TWITCH: 'TWITCH',
  VK: 'VK'
};

export type CommsChannels = (typeof CommsChannels)[keyof typeof CommsChannels]


export const ClientStatus: {
  ACTIVE: 'ACTIVE',
  BLOCKED: 'BLOCKED',
  TERMINATED: 'TERMINATED',
  INACTIVE: 'INACTIVE'
};

export type ClientStatus = (typeof ClientStatus)[keyof typeof ClientStatus]


export const TransactionType: {
  PAYMENT: 'PAYMENT',
  ROYALTIES: 'ROYALTIES',
  RECALLED_PAYMENT: 'RECALLED_PAYMENT',
  BOUNCEDBACK_PAYMENT: 'BOUNCEDBACK_PAYMENT',
  OTHER: 'OTHER'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const DebitState: {
  PAID: 'PAID',
  UNPAID: 'UNPAID',
  OPEN: 'OPEN'
};

export type DebitState = (typeof DebitState)[keyof typeof DebitState]


export const ContractType: {
  DISTRIBUTION_NONEXCLUSIVE: 'DISTRIBUTION_NONEXCLUSIVE',
  DISTRIBUTION_EXCLUSIVE: 'DISTRIBUTION_EXCLUSIVE',
  LICENSING: 'LICENSING',
  PUBLISHING: 'PUBLISHING',
  MANAGEMENT: 'MANAGEMENT',
  PRODUCTION: 'PRODUCTION',
  PROMOTION: 'PROMOTION',
  OTHER: 'OTHER'
};

export type ContractType = (typeof ContractType)[keyof typeof ContractType]


export const ClientType: {
  PERSON: 'PERSON',
  BUSINESS: 'BUSINESS'
};

export type ClientType = (typeof ClientType)[keyof typeof ClientType]


export const TaxIdType: {
  COMPANY_NUMBER: 'COMPANY_NUMBER',
  NATIONAL_ID: 'NATIONAL_ID',
  PASSPORT: 'PASSPORT',
  RESIDENT_PERMIT: 'RESIDENT_PERMIT',
  ID_CARD: 'ID_CARD',
  DRIVERS_LICENSE: 'DRIVERS_LICENSE'
};

export type TaxIdType = (typeof TaxIdType)[keyof typeof TaxIdType]


export const LabelRegistrationStatus: {
  NO_REGISTRATION: 'NO_REGISTRATION',
  PENDING: 'PENDING',
  REJECTED: 'REJECTED',
  ACTIVE: 'ACTIVE'
};

export type LabelRegistrationStatus = (typeof LabelRegistrationStatus)[keyof typeof LabelRegistrationStatus]


export const LabelStatus: {
  ACTIVE: 'ACTIVE',
  DISABLED: 'DISABLED'
};

export type LabelStatus = (typeof LabelStatus)[keyof typeof LabelStatus]


export const ContractStatus: {
  ACTIVE: 'ACTIVE',
  TERMINATED: 'TERMINATED',
  EXPIRED: 'EXPIRED',
  DRAFT: 'DRAFT'
};

export type ContractStatus = (typeof ContractStatus)[keyof typeof ContractStatus]


export const DMBStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  PENDING: 'PENDING'
};

export type DMBStatus = (typeof DMBStatus)[keyof typeof DMBStatus]

}

export type Currency = $Enums.Currency

export const Currency: typeof $Enums.Currency

export type Distributor = $Enums.Distributor

export const Distributor: typeof $Enums.Distributor

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type AccessTypeDMB = $Enums.AccessTypeDMB

export const AccessTypeDMB: typeof $Enums.AccessTypeDMB

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type CommsChannels = $Enums.CommsChannels

export const CommsChannels: typeof $Enums.CommsChannels

export type ClientStatus = $Enums.ClientStatus

export const ClientStatus: typeof $Enums.ClientStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type DebitState = $Enums.DebitState

export const DebitState: typeof $Enums.DebitState

export type ContractType = $Enums.ContractType

export const ContractType: typeof $Enums.ContractType

export type ClientType = $Enums.ClientType

export const ClientType: typeof $Enums.ClientType

export type TaxIdType = $Enums.TaxIdType

export const TaxIdType: typeof $Enums.TaxIdType

export type LabelRegistrationStatus = $Enums.LabelRegistrationStatus

export const LabelRegistrationStatus: typeof $Enums.LabelRegistrationStatus

export type LabelStatus = $Enums.LabelStatus

export const LabelStatus: typeof $Enums.LabelStatus

export type ContractStatus = $Enums.ContractStatus

export const ContractStatus: typeof $Enums.ContractStatus

export type DMBStatus = $Enums.DMBStatus

export const DMBStatus: typeof $Enums.DMBStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more InitializationStatuses
 * const initializationStatuses = await prisma.initializationStatus.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more InitializationStatuses
   * const initializationStatuses = await prisma.initializationStatus.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.initializationStatus`: Exposes CRUD operations for the **InitializationStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InitializationStatuses
    * const initializationStatuses = await prisma.initializationStatus.findMany()
    * ```
    */
  get initializationStatus(): Prisma.InitializationStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.s3File`: Exposes CRUD operations for the **S3File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more S3Files
    * const s3Files = await prisma.s3File.findMany()
    * ```
    */
  get s3File(): Prisma.S3FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userComms`: Exposes CRUD operations for the **UserComms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserComms
    * const userComms = await prisma.userComms.findMany()
    * ```
    */
  get userComms(): Prisma.UserCommsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientDMB`: Exposes CRUD operations for the **ClientDMB** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientDMBS
    * const clientDMBS = await prisma.clientDMB.findMany()
    * ```
    */
  get clientDMB(): Prisma.ClientDMBDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientPaymentInformation`: Exposes CRUD operations for the **ClientPaymentInformation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientPaymentInformations
    * const clientPaymentInformations = await prisma.clientPaymentInformation.findMany()
    * ```
    */
  get clientPaymentInformation(): Prisma.ClientPaymentInformationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balance`: Exposes CRUD operations for the **Balance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balances
    * const balances = await prisma.balance.findMany()
    * ```
    */
  get balance(): Prisma.BalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.label`: Exposes CRUD operations for the **Label** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labels
    * const labels = await prisma.label.findMany()
    * ```
    */
  get label(): Prisma.LabelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.importedRoyaltyReport`: Exposes CRUD operations for the **ImportedRoyaltyReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportedRoyaltyReports
    * const importedRoyaltyReports = await prisma.importedRoyaltyReport.findMany()
    * ```
    */
  get importedRoyaltyReport(): Prisma.ImportedRoyaltyReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.baseRoyaltyReport`: Exposes CRUD operations for the **BaseRoyaltyReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BaseRoyaltyReports
    * const baseRoyaltyReports = await prisma.baseRoyaltyReport.findMany()
    * ```
    */
  get baseRoyaltyReport(): Prisma.BaseRoyaltyReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRoyaltyReport`: Exposes CRUD operations for the **UserRoyaltyReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoyaltyReports
    * const userRoyaltyReports = await prisma.userRoyaltyReport.findMany()
    * ```
    */
  get userRoyaltyReport(): Prisma.UserRoyaltyReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kontorRoyaltyReport`: Exposes CRUD operations for the **KontorRoyaltyReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KontorRoyaltyReports
    * const kontorRoyaltyReports = await prisma.kontorRoyaltyReport.findMany()
    * ```
    */
  get kontorRoyaltyReport(): Prisma.KontorRoyaltyReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.believeRoyaltyReport`: Exposes CRUD operations for the **BelieveRoyaltyReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BelieveRoyaltyReports
    * const believeRoyaltyReports = await prisma.believeRoyaltyReport.findMany()
    * ```
    */
  get believeRoyaltyReport(): Prisma.BelieveRoyaltyReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unlinkedReport`: Exposes CRUD operations for the **UnlinkedReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnlinkedReports
    * const unlinkedReports = await prisma.unlinkedReport.findMany()
    * ```
    */
  get unlinkedReport(): Prisma.UnlinkedReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unlinkedReportDetail`: Exposes CRUD operations for the **UnlinkedReportDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnlinkedReportDetails
    * const unlinkedReportDetails = await prisma.unlinkedReportDetail.findMany()
    * ```
    */
  get unlinkedReportDetail(): Prisma.UnlinkedReportDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.failedReportDetail`: Exposes CRUD operations for the **FailedReportDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FailedReportDetails
    * const failedReportDetails = await prisma.failedReportDetail.findMany()
    * ```
    */
  get failedReportDetail(): Prisma.FailedReportDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    InitializationStatus: 'InitializationStatus',
    S3File: 'S3File',
    Log: 'Log',
    User: 'User',
    PasswordResetToken: 'PasswordResetToken',
    UserPreferences: 'UserPreferences',
    UserComms: 'UserComms',
    Client: 'Client',
    ClientDMB: 'ClientDMB',
    ClientPaymentInformation: 'ClientPaymentInformation',
    Contract: 'Contract',
    Balance: 'Balance',
    Transaction: 'Transaction',
    Address: 'Address',
    Country: 'Country',
    Label: 'Label',
    ImportedRoyaltyReport: 'ImportedRoyaltyReport',
    BaseRoyaltyReport: 'BaseRoyaltyReport',
    UserRoyaltyReport: 'UserRoyaltyReport',
    KontorRoyaltyReport: 'KontorRoyaltyReport',
    BelieveRoyaltyReport: 'BelieveRoyaltyReport',
    UnlinkedReport: 'UnlinkedReport',
    UnlinkedReportDetail: 'UnlinkedReportDetail',
    FailedReportDetail: 'FailedReportDetail',
    RefreshToken: 'RefreshToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "initializationStatus" | "s3File" | "log" | "user" | "passwordResetToken" | "userPreferences" | "userComms" | "client" | "clientDMB" | "clientPaymentInformation" | "contract" | "balance" | "transaction" | "address" | "country" | "label" | "importedRoyaltyReport" | "baseRoyaltyReport" | "userRoyaltyReport" | "kontorRoyaltyReport" | "believeRoyaltyReport" | "unlinkedReport" | "unlinkedReportDetail" | "failedReportDetail" | "refreshToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      InitializationStatus: {
        payload: Prisma.$InitializationStatusPayload<ExtArgs>
        fields: Prisma.InitializationStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InitializationStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InitializationStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload>
          }
          findFirst: {
            args: Prisma.InitializationStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InitializationStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload>
          }
          findMany: {
            args: Prisma.InitializationStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload>[]
          }
          create: {
            args: Prisma.InitializationStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload>
          }
          createMany: {
            args: Prisma.InitializationStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InitializationStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload>[]
          }
          delete: {
            args: Prisma.InitializationStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload>
          }
          update: {
            args: Prisma.InitializationStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload>
          }
          deleteMany: {
            args: Prisma.InitializationStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InitializationStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InitializationStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload>[]
          }
          upsert: {
            args: Prisma.InitializationStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InitializationStatusPayload>
          }
          aggregate: {
            args: Prisma.InitializationStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInitializationStatus>
          }
          groupBy: {
            args: Prisma.InitializationStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<InitializationStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.InitializationStatusCountArgs<ExtArgs>
            result: $Utils.Optional<InitializationStatusCountAggregateOutputType> | number
          }
        }
      }
      S3File: {
        payload: Prisma.$S3FilePayload<ExtArgs>
        fields: Prisma.S3FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.S3FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.S3FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload>
          }
          findFirst: {
            args: Prisma.S3FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.S3FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload>
          }
          findMany: {
            args: Prisma.S3FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload>[]
          }
          create: {
            args: Prisma.S3FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload>
          }
          createMany: {
            args: Prisma.S3FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.S3FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload>[]
          }
          delete: {
            args: Prisma.S3FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload>
          }
          update: {
            args: Prisma.S3FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload>
          }
          deleteMany: {
            args: Prisma.S3FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.S3FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.S3FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload>[]
          }
          upsert: {
            args: Prisma.S3FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$S3FilePayload>
          }
          aggregate: {
            args: Prisma.S3FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateS3File>
          }
          groupBy: {
            args: Prisma.S3FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<S3FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.S3FileCountArgs<ExtArgs>
            result: $Utils.Optional<S3FileCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: Prisma.$UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      UserComms: {
        payload: Prisma.$UserCommsPayload<ExtArgs>
        fields: Prisma.UserCommsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCommsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCommsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload>
          }
          findFirst: {
            args: Prisma.UserCommsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCommsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload>
          }
          findMany: {
            args: Prisma.UserCommsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload>[]
          }
          create: {
            args: Prisma.UserCommsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload>
          }
          createMany: {
            args: Prisma.UserCommsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCommsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload>[]
          }
          delete: {
            args: Prisma.UserCommsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload>
          }
          update: {
            args: Prisma.UserCommsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload>
          }
          deleteMany: {
            args: Prisma.UserCommsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCommsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCommsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload>[]
          }
          upsert: {
            args: Prisma.UserCommsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCommsPayload>
          }
          aggregate: {
            args: Prisma.UserCommsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserComms>
          }
          groupBy: {
            args: Prisma.UserCommsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCommsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCommsCountArgs<ExtArgs>
            result: $Utils.Optional<UserCommsCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ClientDMB: {
        payload: Prisma.$ClientDMBPayload<ExtArgs>
        fields: Prisma.ClientDMBFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientDMBFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientDMBFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload>
          }
          findFirst: {
            args: Prisma.ClientDMBFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientDMBFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload>
          }
          findMany: {
            args: Prisma.ClientDMBFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload>[]
          }
          create: {
            args: Prisma.ClientDMBCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload>
          }
          createMany: {
            args: Prisma.ClientDMBCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientDMBCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload>[]
          }
          delete: {
            args: Prisma.ClientDMBDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload>
          }
          update: {
            args: Prisma.ClientDMBUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload>
          }
          deleteMany: {
            args: Prisma.ClientDMBDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientDMBUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientDMBUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload>[]
          }
          upsert: {
            args: Prisma.ClientDMBUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientDMBPayload>
          }
          aggregate: {
            args: Prisma.ClientDMBAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientDMB>
          }
          groupBy: {
            args: Prisma.ClientDMBGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientDMBGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientDMBCountArgs<ExtArgs>
            result: $Utils.Optional<ClientDMBCountAggregateOutputType> | number
          }
        }
      }
      ClientPaymentInformation: {
        payload: Prisma.$ClientPaymentInformationPayload<ExtArgs>
        fields: Prisma.ClientPaymentInformationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientPaymentInformationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientPaymentInformationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload>
          }
          findFirst: {
            args: Prisma.ClientPaymentInformationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientPaymentInformationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload>
          }
          findMany: {
            args: Prisma.ClientPaymentInformationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload>[]
          }
          create: {
            args: Prisma.ClientPaymentInformationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload>
          }
          createMany: {
            args: Prisma.ClientPaymentInformationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientPaymentInformationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload>[]
          }
          delete: {
            args: Prisma.ClientPaymentInformationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload>
          }
          update: {
            args: Prisma.ClientPaymentInformationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload>
          }
          deleteMany: {
            args: Prisma.ClientPaymentInformationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientPaymentInformationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientPaymentInformationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload>[]
          }
          upsert: {
            args: Prisma.ClientPaymentInformationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPaymentInformationPayload>
          }
          aggregate: {
            args: Prisma.ClientPaymentInformationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientPaymentInformation>
          }
          groupBy: {
            args: Prisma.ClientPaymentInformationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientPaymentInformationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientPaymentInformationCountArgs<ExtArgs>
            result: $Utils.Optional<ClientPaymentInformationCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      Balance: {
        payload: Prisma.$BalancePayload<ExtArgs>
        fields: Prisma.BalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findFirst: {
            args: Prisma.BalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findMany: {
            args: Prisma.BalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          create: {
            args: Prisma.BalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          createMany: {
            args: Prisma.BalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          delete: {
            args: Prisma.BalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          update: {
            args: Prisma.BalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          deleteMany: {
            args: Prisma.BalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          upsert: {
            args: Prisma.BalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          aggregate: {
            args: Prisma.BalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalance>
          }
          groupBy: {
            args: Prisma.BalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalanceCountArgs<ExtArgs>
            result: $Utils.Optional<BalanceCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      Label: {
        payload: Prisma.$LabelPayload<ExtArgs>
        fields: Prisma.LabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findFirst: {
            args: Prisma.LabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findMany: {
            args: Prisma.LabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          create: {
            args: Prisma.LabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          createMany: {
            args: Prisma.LabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          delete: {
            args: Prisma.LabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          update: {
            args: Prisma.LabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          deleteMany: {
            args: Prisma.LabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          upsert: {
            args: Prisma.LabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          aggregate: {
            args: Prisma.LabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabel>
          }
          groupBy: {
            args: Prisma.LabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabelCountArgs<ExtArgs>
            result: $Utils.Optional<LabelCountAggregateOutputType> | number
          }
        }
      }
      ImportedRoyaltyReport: {
        payload: Prisma.$ImportedRoyaltyReportPayload<ExtArgs>
        fields: Prisma.ImportedRoyaltyReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportedRoyaltyReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportedRoyaltyReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload>
          }
          findFirst: {
            args: Prisma.ImportedRoyaltyReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportedRoyaltyReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload>
          }
          findMany: {
            args: Prisma.ImportedRoyaltyReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload>[]
          }
          create: {
            args: Prisma.ImportedRoyaltyReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload>
          }
          createMany: {
            args: Prisma.ImportedRoyaltyReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportedRoyaltyReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload>[]
          }
          delete: {
            args: Prisma.ImportedRoyaltyReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload>
          }
          update: {
            args: Prisma.ImportedRoyaltyReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload>
          }
          deleteMany: {
            args: Prisma.ImportedRoyaltyReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportedRoyaltyReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImportedRoyaltyReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload>[]
          }
          upsert: {
            args: Prisma.ImportedRoyaltyReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportedRoyaltyReportPayload>
          }
          aggregate: {
            args: Prisma.ImportedRoyaltyReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportedRoyaltyReport>
          }
          groupBy: {
            args: Prisma.ImportedRoyaltyReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportedRoyaltyReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportedRoyaltyReportCountArgs<ExtArgs>
            result: $Utils.Optional<ImportedRoyaltyReportCountAggregateOutputType> | number
          }
        }
      }
      BaseRoyaltyReport: {
        payload: Prisma.$BaseRoyaltyReportPayload<ExtArgs>
        fields: Prisma.BaseRoyaltyReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BaseRoyaltyReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BaseRoyaltyReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload>
          }
          findFirst: {
            args: Prisma.BaseRoyaltyReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BaseRoyaltyReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload>
          }
          findMany: {
            args: Prisma.BaseRoyaltyReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload>[]
          }
          create: {
            args: Prisma.BaseRoyaltyReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload>
          }
          createMany: {
            args: Prisma.BaseRoyaltyReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BaseRoyaltyReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload>[]
          }
          delete: {
            args: Prisma.BaseRoyaltyReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload>
          }
          update: {
            args: Prisma.BaseRoyaltyReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload>
          }
          deleteMany: {
            args: Prisma.BaseRoyaltyReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BaseRoyaltyReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BaseRoyaltyReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload>[]
          }
          upsert: {
            args: Prisma.BaseRoyaltyReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseRoyaltyReportPayload>
          }
          aggregate: {
            args: Prisma.BaseRoyaltyReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBaseRoyaltyReport>
          }
          groupBy: {
            args: Prisma.BaseRoyaltyReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<BaseRoyaltyReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.BaseRoyaltyReportCountArgs<ExtArgs>
            result: $Utils.Optional<BaseRoyaltyReportCountAggregateOutputType> | number
          }
        }
      }
      UserRoyaltyReport: {
        payload: Prisma.$UserRoyaltyReportPayload<ExtArgs>
        fields: Prisma.UserRoyaltyReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoyaltyReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoyaltyReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload>
          }
          findFirst: {
            args: Prisma.UserRoyaltyReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoyaltyReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload>
          }
          findMany: {
            args: Prisma.UserRoyaltyReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload>[]
          }
          create: {
            args: Prisma.UserRoyaltyReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload>
          }
          createMany: {
            args: Prisma.UserRoyaltyReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoyaltyReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload>[]
          }
          delete: {
            args: Prisma.UserRoyaltyReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload>
          }
          update: {
            args: Prisma.UserRoyaltyReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload>
          }
          deleteMany: {
            args: Prisma.UserRoyaltyReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoyaltyReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoyaltyReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload>[]
          }
          upsert: {
            args: Prisma.UserRoyaltyReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoyaltyReportPayload>
          }
          aggregate: {
            args: Prisma.UserRoyaltyReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRoyaltyReport>
          }
          groupBy: {
            args: Prisma.UserRoyaltyReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoyaltyReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoyaltyReportCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoyaltyReportCountAggregateOutputType> | number
          }
        }
      }
      KontorRoyaltyReport: {
        payload: Prisma.$KontorRoyaltyReportPayload<ExtArgs>
        fields: Prisma.KontorRoyaltyReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KontorRoyaltyReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KontorRoyaltyReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload>
          }
          findFirst: {
            args: Prisma.KontorRoyaltyReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KontorRoyaltyReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload>
          }
          findMany: {
            args: Prisma.KontorRoyaltyReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload>[]
          }
          create: {
            args: Prisma.KontorRoyaltyReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload>
          }
          createMany: {
            args: Prisma.KontorRoyaltyReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KontorRoyaltyReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload>[]
          }
          delete: {
            args: Prisma.KontorRoyaltyReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload>
          }
          update: {
            args: Prisma.KontorRoyaltyReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload>
          }
          deleteMany: {
            args: Prisma.KontorRoyaltyReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KontorRoyaltyReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KontorRoyaltyReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload>[]
          }
          upsert: {
            args: Prisma.KontorRoyaltyReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KontorRoyaltyReportPayload>
          }
          aggregate: {
            args: Prisma.KontorRoyaltyReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKontorRoyaltyReport>
          }
          groupBy: {
            args: Prisma.KontorRoyaltyReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<KontorRoyaltyReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.KontorRoyaltyReportCountArgs<ExtArgs>
            result: $Utils.Optional<KontorRoyaltyReportCountAggregateOutputType> | number
          }
        }
      }
      BelieveRoyaltyReport: {
        payload: Prisma.$BelieveRoyaltyReportPayload<ExtArgs>
        fields: Prisma.BelieveRoyaltyReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BelieveRoyaltyReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BelieveRoyaltyReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload>
          }
          findFirst: {
            args: Prisma.BelieveRoyaltyReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BelieveRoyaltyReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload>
          }
          findMany: {
            args: Prisma.BelieveRoyaltyReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload>[]
          }
          create: {
            args: Prisma.BelieveRoyaltyReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload>
          }
          createMany: {
            args: Prisma.BelieveRoyaltyReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BelieveRoyaltyReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload>[]
          }
          delete: {
            args: Prisma.BelieveRoyaltyReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload>
          }
          update: {
            args: Prisma.BelieveRoyaltyReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload>
          }
          deleteMany: {
            args: Prisma.BelieveRoyaltyReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BelieveRoyaltyReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BelieveRoyaltyReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload>[]
          }
          upsert: {
            args: Prisma.BelieveRoyaltyReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BelieveRoyaltyReportPayload>
          }
          aggregate: {
            args: Prisma.BelieveRoyaltyReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBelieveRoyaltyReport>
          }
          groupBy: {
            args: Prisma.BelieveRoyaltyReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<BelieveRoyaltyReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.BelieveRoyaltyReportCountArgs<ExtArgs>
            result: $Utils.Optional<BelieveRoyaltyReportCountAggregateOutputType> | number
          }
        }
      }
      UnlinkedReport: {
        payload: Prisma.$UnlinkedReportPayload<ExtArgs>
        fields: Prisma.UnlinkedReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnlinkedReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnlinkedReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload>
          }
          findFirst: {
            args: Prisma.UnlinkedReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnlinkedReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload>
          }
          findMany: {
            args: Prisma.UnlinkedReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload>[]
          }
          create: {
            args: Prisma.UnlinkedReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload>
          }
          createMany: {
            args: Prisma.UnlinkedReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnlinkedReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload>[]
          }
          delete: {
            args: Prisma.UnlinkedReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload>
          }
          update: {
            args: Prisma.UnlinkedReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload>
          }
          deleteMany: {
            args: Prisma.UnlinkedReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnlinkedReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnlinkedReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload>[]
          }
          upsert: {
            args: Prisma.UnlinkedReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportPayload>
          }
          aggregate: {
            args: Prisma.UnlinkedReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnlinkedReport>
          }
          groupBy: {
            args: Prisma.UnlinkedReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnlinkedReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnlinkedReportCountArgs<ExtArgs>
            result: $Utils.Optional<UnlinkedReportCountAggregateOutputType> | number
          }
        }
      }
      UnlinkedReportDetail: {
        payload: Prisma.$UnlinkedReportDetailPayload<ExtArgs>
        fields: Prisma.UnlinkedReportDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnlinkedReportDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnlinkedReportDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload>
          }
          findFirst: {
            args: Prisma.UnlinkedReportDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnlinkedReportDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload>
          }
          findMany: {
            args: Prisma.UnlinkedReportDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload>[]
          }
          create: {
            args: Prisma.UnlinkedReportDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload>
          }
          createMany: {
            args: Prisma.UnlinkedReportDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnlinkedReportDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload>[]
          }
          delete: {
            args: Prisma.UnlinkedReportDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload>
          }
          update: {
            args: Prisma.UnlinkedReportDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload>
          }
          deleteMany: {
            args: Prisma.UnlinkedReportDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnlinkedReportDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnlinkedReportDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload>[]
          }
          upsert: {
            args: Prisma.UnlinkedReportDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnlinkedReportDetailPayload>
          }
          aggregate: {
            args: Prisma.UnlinkedReportDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnlinkedReportDetail>
          }
          groupBy: {
            args: Prisma.UnlinkedReportDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnlinkedReportDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnlinkedReportDetailCountArgs<ExtArgs>
            result: $Utils.Optional<UnlinkedReportDetailCountAggregateOutputType> | number
          }
        }
      }
      FailedReportDetail: {
        payload: Prisma.$FailedReportDetailPayload<ExtArgs>
        fields: Prisma.FailedReportDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FailedReportDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FailedReportDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload>
          }
          findFirst: {
            args: Prisma.FailedReportDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FailedReportDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload>
          }
          findMany: {
            args: Prisma.FailedReportDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload>[]
          }
          create: {
            args: Prisma.FailedReportDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload>
          }
          createMany: {
            args: Prisma.FailedReportDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FailedReportDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload>[]
          }
          delete: {
            args: Prisma.FailedReportDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload>
          }
          update: {
            args: Prisma.FailedReportDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload>
          }
          deleteMany: {
            args: Prisma.FailedReportDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FailedReportDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FailedReportDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload>[]
          }
          upsert: {
            args: Prisma.FailedReportDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedReportDetailPayload>
          }
          aggregate: {
            args: Prisma.FailedReportDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFailedReportDetail>
          }
          groupBy: {
            args: Prisma.FailedReportDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<FailedReportDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.FailedReportDetailCountArgs<ExtArgs>
            result: $Utils.Optional<FailedReportDetailCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    initializationStatus?: InitializationStatusOmit
    s3File?: S3FileOmit
    log?: LogOmit
    user?: UserOmit
    passwordResetToken?: PasswordResetTokenOmit
    userPreferences?: UserPreferencesOmit
    userComms?: UserCommsOmit
    client?: ClientOmit
    clientDMB?: ClientDMBOmit
    clientPaymentInformation?: ClientPaymentInformationOmit
    contract?: ContractOmit
    balance?: BalanceOmit
    transaction?: TransactionOmit
    address?: AddressOmit
    country?: CountryOmit
    label?: LabelOmit
    importedRoyaltyReport?: ImportedRoyaltyReportOmit
    baseRoyaltyReport?: BaseRoyaltyReportOmit
    userRoyaltyReport?: UserRoyaltyReportOmit
    kontorRoyaltyReport?: KontorRoyaltyReportOmit
    believeRoyaltyReport?: BelieveRoyaltyReportOmit
    unlinkedReport?: UnlinkedReportOmit
    unlinkedReportDetail?: UnlinkedReportDetailOmit
    failedReportDetail?: FailedReportDetailOmit
    refreshToken?: RefreshTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type S3FileCountOutputType
   */

  export type S3FileCountOutputType = {
    UserRoyaltyReport: number
    BaseRoyaltyReport: number
    ImportedRoyaltyReport: number
  }

  export type S3FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserRoyaltyReport?: boolean | S3FileCountOutputTypeCountUserRoyaltyReportArgs
    BaseRoyaltyReport?: boolean | S3FileCountOutputTypeCountBaseRoyaltyReportArgs
    ImportedRoyaltyReport?: boolean | S3FileCountOutputTypeCountImportedRoyaltyReportArgs
  }

  // Custom InputTypes
  /**
   * S3FileCountOutputType without action
   */
  export type S3FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3FileCountOutputType
     */
    select?: S3FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * S3FileCountOutputType without action
   */
  export type S3FileCountOutputTypeCountUserRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoyaltyReportWhereInput
  }

  /**
   * S3FileCountOutputType without action
   */
  export type S3FileCountOutputTypeCountBaseRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaseRoyaltyReportWhereInput
  }

  /**
   * S3FileCountOutputType without action
   */
  export type S3FileCountOutputTypeCountImportedRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportedRoyaltyReportWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    preferences: number
    comms: number
    logs: number
    refreshTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preferences?: boolean | UserCountOutputTypeCountPreferencesArgs
    comms?: boolean | UserCountOutputTypeCountCommsArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCommsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    balances: number
    labels: number
    users: number
    userRoyaltyReport: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balances?: boolean | ClientCountOutputTypeCountBalancesArgs
    labels?: boolean | ClientCountOutputTypeCountLabelsArgs
    users?: boolean | ClientCountOutputTypeCountUsersArgs
    userRoyaltyReport?: boolean | ClientCountOutputTypeCountUserRoyaltyReportArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountUserRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoyaltyReportWhereInput
  }


  /**
   * Count Type BalanceCountOutputType
   */

  export type BalanceCountOutputType = {
    transactions: number
  }

  export type BalanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | BalanceCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * BalanceCountOutputType without action
   */
  export type BalanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceCountOutputType
     */
    select?: BalanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BalanceCountOutputType without action
   */
  export type BalanceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    client: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | AddressCountOutputTypeCountClientArgs
  }

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    address: number
    label: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | CountryCountOutputTypeCountAddressArgs
    label?: boolean | CountryCountOutputTypeCountLabelArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
  }


  /**
   * Count Type LabelCountOutputType
   */

  export type LabelCountOutputType = {
    KontorRoyaltyReport: number
    BelieveRoyaltyReport: number
  }

  export type LabelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KontorRoyaltyReport?: boolean | LabelCountOutputTypeCountKontorRoyaltyReportArgs
    BelieveRoyaltyReport?: boolean | LabelCountOutputTypeCountBelieveRoyaltyReportArgs
  }

  // Custom InputTypes
  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabelCountOutputType
     */
    select?: LabelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeCountKontorRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KontorRoyaltyReportWhereInput
  }

  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeCountBelieveRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BelieveRoyaltyReportWhereInput
  }


  /**
   * Count Type ImportedRoyaltyReportCountOutputType
   */

  export type ImportedRoyaltyReportCountOutputType = {
    KontorRoyaltyReport: number
    BelieveRoyaltyReport: number
  }

  export type ImportedRoyaltyReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    KontorRoyaltyReport?: boolean | ImportedRoyaltyReportCountOutputTypeCountKontorRoyaltyReportArgs
    BelieveRoyaltyReport?: boolean | ImportedRoyaltyReportCountOutputTypeCountBelieveRoyaltyReportArgs
  }

  // Custom InputTypes
  /**
   * ImportedRoyaltyReportCountOutputType without action
   */
  export type ImportedRoyaltyReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReportCountOutputType
     */
    select?: ImportedRoyaltyReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImportedRoyaltyReportCountOutputType without action
   */
  export type ImportedRoyaltyReportCountOutputTypeCountKontorRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KontorRoyaltyReportWhereInput
  }

  /**
   * ImportedRoyaltyReportCountOutputType without action
   */
  export type ImportedRoyaltyReportCountOutputTypeCountBelieveRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BelieveRoyaltyReportWhereInput
  }


  /**
   * Count Type BaseRoyaltyReportCountOutputType
   */

  export type BaseRoyaltyReportCountOutputType = {
    kontorReports: number
    believeReports: number
    userReports: number
    Transaction: number
  }

  export type BaseRoyaltyReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kontorReports?: boolean | BaseRoyaltyReportCountOutputTypeCountKontorReportsArgs
    believeReports?: boolean | BaseRoyaltyReportCountOutputTypeCountBelieveReportsArgs
    userReports?: boolean | BaseRoyaltyReportCountOutputTypeCountUserReportsArgs
    Transaction?: boolean | BaseRoyaltyReportCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * BaseRoyaltyReportCountOutputType without action
   */
  export type BaseRoyaltyReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReportCountOutputType
     */
    select?: BaseRoyaltyReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BaseRoyaltyReportCountOutputType without action
   */
  export type BaseRoyaltyReportCountOutputTypeCountKontorReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KontorRoyaltyReportWhereInput
  }

  /**
   * BaseRoyaltyReportCountOutputType without action
   */
  export type BaseRoyaltyReportCountOutputTypeCountBelieveReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BelieveRoyaltyReportWhereInput
  }

  /**
   * BaseRoyaltyReportCountOutputType without action
   */
  export type BaseRoyaltyReportCountOutputTypeCountUserReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoyaltyReportWhereInput
  }

  /**
   * BaseRoyaltyReportCountOutputType without action
   */
  export type BaseRoyaltyReportCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type UserRoyaltyReportCountOutputType
   */

  export type UserRoyaltyReportCountOutputType = {
    kontorReports: number
    believeReports: number
    transactions: number
  }

  export type UserRoyaltyReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kontorReports?: boolean | UserRoyaltyReportCountOutputTypeCountKontorReportsArgs
    believeReports?: boolean | UserRoyaltyReportCountOutputTypeCountBelieveReportsArgs
    transactions?: boolean | UserRoyaltyReportCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * UserRoyaltyReportCountOutputType without action
   */
  export type UserRoyaltyReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReportCountOutputType
     */
    select?: UserRoyaltyReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserRoyaltyReportCountOutputType without action
   */
  export type UserRoyaltyReportCountOutputTypeCountKontorReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KontorRoyaltyReportWhereInput
  }

  /**
   * UserRoyaltyReportCountOutputType without action
   */
  export type UserRoyaltyReportCountOutputTypeCountBelieveReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BelieveRoyaltyReportWhereInput
  }

  /**
   * UserRoyaltyReportCountOutputType without action
   */
  export type UserRoyaltyReportCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type UnlinkedReportCountOutputType
   */

  export type UnlinkedReportCountOutputType = {
    UnlinkedReportDetail: number
  }

  export type UnlinkedReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UnlinkedReportDetail?: boolean | UnlinkedReportCountOutputTypeCountUnlinkedReportDetailArgs
  }

  // Custom InputTypes
  /**
   * UnlinkedReportCountOutputType without action
   */
  export type UnlinkedReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportCountOutputType
     */
    select?: UnlinkedReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnlinkedReportCountOutputType without action
   */
  export type UnlinkedReportCountOutputTypeCountUnlinkedReportDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnlinkedReportDetailWhereInput
  }


  /**
   * Models
   */

  /**
   * Model InitializationStatus
   */

  export type AggregateInitializationStatus = {
    _count: InitializationStatusCountAggregateOutputType | null
    _avg: InitializationStatusAvgAggregateOutputType | null
    _sum: InitializationStatusSumAggregateOutputType | null
    _min: InitializationStatusMinAggregateOutputType | null
    _max: InitializationStatusMaxAggregateOutputType | null
  }

  export type InitializationStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type InitializationStatusSumAggregateOutputType = {
    id: number | null
  }

  export type InitializationStatusMinAggregateOutputType = {
    id: number | null
    initialized: boolean | null
    adminInit: boolean | null
  }

  export type InitializationStatusMaxAggregateOutputType = {
    id: number | null
    initialized: boolean | null
    adminInit: boolean | null
  }

  export type InitializationStatusCountAggregateOutputType = {
    id: number
    initialized: number
    adminInit: number
    _all: number
  }


  export type InitializationStatusAvgAggregateInputType = {
    id?: true
  }

  export type InitializationStatusSumAggregateInputType = {
    id?: true
  }

  export type InitializationStatusMinAggregateInputType = {
    id?: true
    initialized?: true
    adminInit?: true
  }

  export type InitializationStatusMaxAggregateInputType = {
    id?: true
    initialized?: true
    adminInit?: true
  }

  export type InitializationStatusCountAggregateInputType = {
    id?: true
    initialized?: true
    adminInit?: true
    _all?: true
  }

  export type InitializationStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InitializationStatus to aggregate.
     */
    where?: InitializationStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InitializationStatuses to fetch.
     */
    orderBy?: InitializationStatusOrderByWithRelationInput | InitializationStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InitializationStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InitializationStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InitializationStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InitializationStatuses
    **/
    _count?: true | InitializationStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InitializationStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InitializationStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InitializationStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InitializationStatusMaxAggregateInputType
  }

  export type GetInitializationStatusAggregateType<T extends InitializationStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateInitializationStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInitializationStatus[P]>
      : GetScalarType<T[P], AggregateInitializationStatus[P]>
  }




  export type InitializationStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InitializationStatusWhereInput
    orderBy?: InitializationStatusOrderByWithAggregationInput | InitializationStatusOrderByWithAggregationInput[]
    by: InitializationStatusScalarFieldEnum[] | InitializationStatusScalarFieldEnum
    having?: InitializationStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InitializationStatusCountAggregateInputType | true
    _avg?: InitializationStatusAvgAggregateInputType
    _sum?: InitializationStatusSumAggregateInputType
    _min?: InitializationStatusMinAggregateInputType
    _max?: InitializationStatusMaxAggregateInputType
  }

  export type InitializationStatusGroupByOutputType = {
    id: number
    initialized: boolean
    adminInit: boolean
    _count: InitializationStatusCountAggregateOutputType | null
    _avg: InitializationStatusAvgAggregateOutputType | null
    _sum: InitializationStatusSumAggregateOutputType | null
    _min: InitializationStatusMinAggregateOutputType | null
    _max: InitializationStatusMaxAggregateOutputType | null
  }

  type GetInitializationStatusGroupByPayload<T extends InitializationStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InitializationStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InitializationStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InitializationStatusGroupByOutputType[P]>
            : GetScalarType<T[P], InitializationStatusGroupByOutputType[P]>
        }
      >
    >


  export type InitializationStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    initialized?: boolean
    adminInit?: boolean
  }, ExtArgs["result"]["initializationStatus"]>

  export type InitializationStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    initialized?: boolean
    adminInit?: boolean
  }, ExtArgs["result"]["initializationStatus"]>

  export type InitializationStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    initialized?: boolean
    adminInit?: boolean
  }, ExtArgs["result"]["initializationStatus"]>

  export type InitializationStatusSelectScalar = {
    id?: boolean
    initialized?: boolean
    adminInit?: boolean
  }

  export type InitializationStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "initialized" | "adminInit", ExtArgs["result"]["initializationStatus"]>

  export type $InitializationStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InitializationStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      initialized: boolean
      adminInit: boolean
    }, ExtArgs["result"]["initializationStatus"]>
    composites: {}
  }

  type InitializationStatusGetPayload<S extends boolean | null | undefined | InitializationStatusDefaultArgs> = $Result.GetResult<Prisma.$InitializationStatusPayload, S>

  type InitializationStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InitializationStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InitializationStatusCountAggregateInputType | true
    }

  export interface InitializationStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InitializationStatus'], meta: { name: 'InitializationStatus' } }
    /**
     * Find zero or one InitializationStatus that matches the filter.
     * @param {InitializationStatusFindUniqueArgs} args - Arguments to find a InitializationStatus
     * @example
     * // Get one InitializationStatus
     * const initializationStatus = await prisma.initializationStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InitializationStatusFindUniqueArgs>(args: SelectSubset<T, InitializationStatusFindUniqueArgs<ExtArgs>>): Prisma__InitializationStatusClient<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InitializationStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InitializationStatusFindUniqueOrThrowArgs} args - Arguments to find a InitializationStatus
     * @example
     * // Get one InitializationStatus
     * const initializationStatus = await prisma.initializationStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InitializationStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, InitializationStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InitializationStatusClient<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InitializationStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitializationStatusFindFirstArgs} args - Arguments to find a InitializationStatus
     * @example
     * // Get one InitializationStatus
     * const initializationStatus = await prisma.initializationStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InitializationStatusFindFirstArgs>(args?: SelectSubset<T, InitializationStatusFindFirstArgs<ExtArgs>>): Prisma__InitializationStatusClient<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InitializationStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitializationStatusFindFirstOrThrowArgs} args - Arguments to find a InitializationStatus
     * @example
     * // Get one InitializationStatus
     * const initializationStatus = await prisma.initializationStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InitializationStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, InitializationStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__InitializationStatusClient<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InitializationStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitializationStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InitializationStatuses
     * const initializationStatuses = await prisma.initializationStatus.findMany()
     * 
     * // Get first 10 InitializationStatuses
     * const initializationStatuses = await prisma.initializationStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const initializationStatusWithIdOnly = await prisma.initializationStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InitializationStatusFindManyArgs>(args?: SelectSubset<T, InitializationStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InitializationStatus.
     * @param {InitializationStatusCreateArgs} args - Arguments to create a InitializationStatus.
     * @example
     * // Create one InitializationStatus
     * const InitializationStatus = await prisma.initializationStatus.create({
     *   data: {
     *     // ... data to create a InitializationStatus
     *   }
     * })
     * 
     */
    create<T extends InitializationStatusCreateArgs>(args: SelectSubset<T, InitializationStatusCreateArgs<ExtArgs>>): Prisma__InitializationStatusClient<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InitializationStatuses.
     * @param {InitializationStatusCreateManyArgs} args - Arguments to create many InitializationStatuses.
     * @example
     * // Create many InitializationStatuses
     * const initializationStatus = await prisma.initializationStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InitializationStatusCreateManyArgs>(args?: SelectSubset<T, InitializationStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InitializationStatuses and returns the data saved in the database.
     * @param {InitializationStatusCreateManyAndReturnArgs} args - Arguments to create many InitializationStatuses.
     * @example
     * // Create many InitializationStatuses
     * const initializationStatus = await prisma.initializationStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InitializationStatuses and only return the `id`
     * const initializationStatusWithIdOnly = await prisma.initializationStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InitializationStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, InitializationStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InitializationStatus.
     * @param {InitializationStatusDeleteArgs} args - Arguments to delete one InitializationStatus.
     * @example
     * // Delete one InitializationStatus
     * const InitializationStatus = await prisma.initializationStatus.delete({
     *   where: {
     *     // ... filter to delete one InitializationStatus
     *   }
     * })
     * 
     */
    delete<T extends InitializationStatusDeleteArgs>(args: SelectSubset<T, InitializationStatusDeleteArgs<ExtArgs>>): Prisma__InitializationStatusClient<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InitializationStatus.
     * @param {InitializationStatusUpdateArgs} args - Arguments to update one InitializationStatus.
     * @example
     * // Update one InitializationStatus
     * const initializationStatus = await prisma.initializationStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InitializationStatusUpdateArgs>(args: SelectSubset<T, InitializationStatusUpdateArgs<ExtArgs>>): Prisma__InitializationStatusClient<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InitializationStatuses.
     * @param {InitializationStatusDeleteManyArgs} args - Arguments to filter InitializationStatuses to delete.
     * @example
     * // Delete a few InitializationStatuses
     * const { count } = await prisma.initializationStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InitializationStatusDeleteManyArgs>(args?: SelectSubset<T, InitializationStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InitializationStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitializationStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InitializationStatuses
     * const initializationStatus = await prisma.initializationStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InitializationStatusUpdateManyArgs>(args: SelectSubset<T, InitializationStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InitializationStatuses and returns the data updated in the database.
     * @param {InitializationStatusUpdateManyAndReturnArgs} args - Arguments to update many InitializationStatuses.
     * @example
     * // Update many InitializationStatuses
     * const initializationStatus = await prisma.initializationStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InitializationStatuses and only return the `id`
     * const initializationStatusWithIdOnly = await prisma.initializationStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InitializationStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, InitializationStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InitializationStatus.
     * @param {InitializationStatusUpsertArgs} args - Arguments to update or create a InitializationStatus.
     * @example
     * // Update or create a InitializationStatus
     * const initializationStatus = await prisma.initializationStatus.upsert({
     *   create: {
     *     // ... data to create a InitializationStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InitializationStatus we want to update
     *   }
     * })
     */
    upsert<T extends InitializationStatusUpsertArgs>(args: SelectSubset<T, InitializationStatusUpsertArgs<ExtArgs>>): Prisma__InitializationStatusClient<$Result.GetResult<Prisma.$InitializationStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InitializationStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitializationStatusCountArgs} args - Arguments to filter InitializationStatuses to count.
     * @example
     * // Count the number of InitializationStatuses
     * const count = await prisma.initializationStatus.count({
     *   where: {
     *     // ... the filter for the InitializationStatuses we want to count
     *   }
     * })
    **/
    count<T extends InitializationStatusCountArgs>(
      args?: Subset<T, InitializationStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InitializationStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InitializationStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitializationStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InitializationStatusAggregateArgs>(args: Subset<T, InitializationStatusAggregateArgs>): Prisma.PrismaPromise<GetInitializationStatusAggregateType<T>>

    /**
     * Group by InitializationStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InitializationStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InitializationStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InitializationStatusGroupByArgs['orderBy'] }
        : { orderBy?: InitializationStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InitializationStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInitializationStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InitializationStatus model
   */
  readonly fields: InitializationStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InitializationStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InitializationStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InitializationStatus model
   */
  interface InitializationStatusFieldRefs {
    readonly id: FieldRef<"InitializationStatus", 'Int'>
    readonly initialized: FieldRef<"InitializationStatus", 'Boolean'>
    readonly adminInit: FieldRef<"InitializationStatus", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * InitializationStatus findUnique
   */
  export type InitializationStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * Filter, which InitializationStatus to fetch.
     */
    where: InitializationStatusWhereUniqueInput
  }

  /**
   * InitializationStatus findUniqueOrThrow
   */
  export type InitializationStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * Filter, which InitializationStatus to fetch.
     */
    where: InitializationStatusWhereUniqueInput
  }

  /**
   * InitializationStatus findFirst
   */
  export type InitializationStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * Filter, which InitializationStatus to fetch.
     */
    where?: InitializationStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InitializationStatuses to fetch.
     */
    orderBy?: InitializationStatusOrderByWithRelationInput | InitializationStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InitializationStatuses.
     */
    cursor?: InitializationStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InitializationStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InitializationStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InitializationStatuses.
     */
    distinct?: InitializationStatusScalarFieldEnum | InitializationStatusScalarFieldEnum[]
  }

  /**
   * InitializationStatus findFirstOrThrow
   */
  export type InitializationStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * Filter, which InitializationStatus to fetch.
     */
    where?: InitializationStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InitializationStatuses to fetch.
     */
    orderBy?: InitializationStatusOrderByWithRelationInput | InitializationStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InitializationStatuses.
     */
    cursor?: InitializationStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InitializationStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InitializationStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InitializationStatuses.
     */
    distinct?: InitializationStatusScalarFieldEnum | InitializationStatusScalarFieldEnum[]
  }

  /**
   * InitializationStatus findMany
   */
  export type InitializationStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * Filter, which InitializationStatuses to fetch.
     */
    where?: InitializationStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InitializationStatuses to fetch.
     */
    orderBy?: InitializationStatusOrderByWithRelationInput | InitializationStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InitializationStatuses.
     */
    cursor?: InitializationStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InitializationStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InitializationStatuses.
     */
    skip?: number
    distinct?: InitializationStatusScalarFieldEnum | InitializationStatusScalarFieldEnum[]
  }

  /**
   * InitializationStatus create
   */
  export type InitializationStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * The data needed to create a InitializationStatus.
     */
    data?: XOR<InitializationStatusCreateInput, InitializationStatusUncheckedCreateInput>
  }

  /**
   * InitializationStatus createMany
   */
  export type InitializationStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InitializationStatuses.
     */
    data: InitializationStatusCreateManyInput | InitializationStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InitializationStatus createManyAndReturn
   */
  export type InitializationStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * The data used to create many InitializationStatuses.
     */
    data: InitializationStatusCreateManyInput | InitializationStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InitializationStatus update
   */
  export type InitializationStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * The data needed to update a InitializationStatus.
     */
    data: XOR<InitializationStatusUpdateInput, InitializationStatusUncheckedUpdateInput>
    /**
     * Choose, which InitializationStatus to update.
     */
    where: InitializationStatusWhereUniqueInput
  }

  /**
   * InitializationStatus updateMany
   */
  export type InitializationStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InitializationStatuses.
     */
    data: XOR<InitializationStatusUpdateManyMutationInput, InitializationStatusUncheckedUpdateManyInput>
    /**
     * Filter which InitializationStatuses to update
     */
    where?: InitializationStatusWhereInput
    /**
     * Limit how many InitializationStatuses to update.
     */
    limit?: number
  }

  /**
   * InitializationStatus updateManyAndReturn
   */
  export type InitializationStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * The data used to update InitializationStatuses.
     */
    data: XOR<InitializationStatusUpdateManyMutationInput, InitializationStatusUncheckedUpdateManyInput>
    /**
     * Filter which InitializationStatuses to update
     */
    where?: InitializationStatusWhereInput
    /**
     * Limit how many InitializationStatuses to update.
     */
    limit?: number
  }

  /**
   * InitializationStatus upsert
   */
  export type InitializationStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * The filter to search for the InitializationStatus to update in case it exists.
     */
    where: InitializationStatusWhereUniqueInput
    /**
     * In case the InitializationStatus found by the `where` argument doesn't exist, create a new InitializationStatus with this data.
     */
    create: XOR<InitializationStatusCreateInput, InitializationStatusUncheckedCreateInput>
    /**
     * In case the InitializationStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InitializationStatusUpdateInput, InitializationStatusUncheckedUpdateInput>
  }

  /**
   * InitializationStatus delete
   */
  export type InitializationStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
    /**
     * Filter which InitializationStatus to delete.
     */
    where: InitializationStatusWhereUniqueInput
  }

  /**
   * InitializationStatus deleteMany
   */
  export type InitializationStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InitializationStatuses to delete
     */
    where?: InitializationStatusWhereInput
    /**
     * Limit how many InitializationStatuses to delete.
     */
    limit?: number
  }

  /**
   * InitializationStatus without action
   */
  export type InitializationStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InitializationStatus
     */
    select?: InitializationStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InitializationStatus
     */
    omit?: InitializationStatusOmit<ExtArgs> | null
  }


  /**
   * Model S3File
   */

  export type AggregateS3File = {
    _count: S3FileCountAggregateOutputType | null
    _avg: S3FileAvgAggregateOutputType | null
    _sum: S3FileSumAggregateOutputType | null
    _min: S3FileMinAggregateOutputType | null
    _max: S3FileMaxAggregateOutputType | null
  }

  export type S3FileAvgAggregateOutputType = {
    id: number | null
  }

  export type S3FileSumAggregateOutputType = {
    id: number | null
  }

  export type S3FileMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    fileName: string | null
    type: string | null
    folder: string | null
    bucket: string | null
    key: string | null
  }

  export type S3FileMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    fileName: string | null
    type: string | null
    folder: string | null
    bucket: string | null
    key: string | null
  }

  export type S3FileCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    fileName: number
    type: number
    folder: number
    bucket: number
    key: number
    _all: number
  }


  export type S3FileAvgAggregateInputType = {
    id?: true
  }

  export type S3FileSumAggregateInputType = {
    id?: true
  }

  export type S3FileMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fileName?: true
    type?: true
    folder?: true
    bucket?: true
    key?: true
  }

  export type S3FileMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fileName?: true
    type?: true
    folder?: true
    bucket?: true
    key?: true
  }

  export type S3FileCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fileName?: true
    type?: true
    folder?: true
    bucket?: true
    key?: true
    _all?: true
  }

  export type S3FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which S3File to aggregate.
     */
    where?: S3FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of S3Files to fetch.
     */
    orderBy?: S3FileOrderByWithRelationInput | S3FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: S3FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` S3Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` S3Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned S3Files
    **/
    _count?: true | S3FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: S3FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: S3FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: S3FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: S3FileMaxAggregateInputType
  }

  export type GetS3FileAggregateType<T extends S3FileAggregateArgs> = {
        [P in keyof T & keyof AggregateS3File]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateS3File[P]>
      : GetScalarType<T[P], AggregateS3File[P]>
  }




  export type S3FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: S3FileWhereInput
    orderBy?: S3FileOrderByWithAggregationInput | S3FileOrderByWithAggregationInput[]
    by: S3FileScalarFieldEnum[] | S3FileScalarFieldEnum
    having?: S3FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: S3FileCountAggregateInputType | true
    _avg?: S3FileAvgAggregateInputType
    _sum?: S3FileSumAggregateInputType
    _min?: S3FileMinAggregateInputType
    _max?: S3FileMaxAggregateInputType
  }

  export type S3FileGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    fileName: string
    type: string
    folder: string | null
    bucket: string
    key: string
    _count: S3FileCountAggregateOutputType | null
    _avg: S3FileAvgAggregateOutputType | null
    _sum: S3FileSumAggregateOutputType | null
    _min: S3FileMinAggregateOutputType | null
    _max: S3FileMaxAggregateOutputType | null
  }

  type GetS3FileGroupByPayload<T extends S3FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<S3FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof S3FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], S3FileGroupByOutputType[P]>
            : GetScalarType<T[P], S3FileGroupByOutputType[P]>
        }
      >
    >


  export type S3FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
    type?: boolean
    folder?: boolean
    bucket?: boolean
    key?: boolean
    UserRoyaltyReport?: boolean | S3File$UserRoyaltyReportArgs<ExtArgs>
    BaseRoyaltyReport?: boolean | S3File$BaseRoyaltyReportArgs<ExtArgs>
    ImportedRoyaltyReport?: boolean | S3File$ImportedRoyaltyReportArgs<ExtArgs>
    _count?: boolean | S3FileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["s3File"]>

  export type S3FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
    type?: boolean
    folder?: boolean
    bucket?: boolean
    key?: boolean
  }, ExtArgs["result"]["s3File"]>

  export type S3FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
    type?: boolean
    folder?: boolean
    bucket?: boolean
    key?: boolean
  }, ExtArgs["result"]["s3File"]>

  export type S3FileSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
    type?: boolean
    folder?: boolean
    bucket?: boolean
    key?: boolean
  }

  export type S3FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "fileName" | "type" | "folder" | "bucket" | "key", ExtArgs["result"]["s3File"]>
  export type S3FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserRoyaltyReport?: boolean | S3File$UserRoyaltyReportArgs<ExtArgs>
    BaseRoyaltyReport?: boolean | S3File$BaseRoyaltyReportArgs<ExtArgs>
    ImportedRoyaltyReport?: boolean | S3File$ImportedRoyaltyReportArgs<ExtArgs>
    _count?: boolean | S3FileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type S3FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type S3FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $S3FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "S3File"
    objects: {
      UserRoyaltyReport: Prisma.$UserRoyaltyReportPayload<ExtArgs>[]
      BaseRoyaltyReport: Prisma.$BaseRoyaltyReportPayload<ExtArgs>[]
      ImportedRoyaltyReport: Prisma.$ImportedRoyaltyReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      fileName: string
      type: string
      folder: string | null
      bucket: string
      key: string
    }, ExtArgs["result"]["s3File"]>
    composites: {}
  }

  type S3FileGetPayload<S extends boolean | null | undefined | S3FileDefaultArgs> = $Result.GetResult<Prisma.$S3FilePayload, S>

  type S3FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<S3FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: S3FileCountAggregateInputType | true
    }

  export interface S3FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['S3File'], meta: { name: 'S3File' } }
    /**
     * Find zero or one S3File that matches the filter.
     * @param {S3FileFindUniqueArgs} args - Arguments to find a S3File
     * @example
     * // Get one S3File
     * const s3File = await prisma.s3File.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends S3FileFindUniqueArgs>(args: SelectSubset<T, S3FileFindUniqueArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one S3File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {S3FileFindUniqueOrThrowArgs} args - Arguments to find a S3File
     * @example
     * // Get one S3File
     * const s3File = await prisma.s3File.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends S3FileFindUniqueOrThrowArgs>(args: SelectSubset<T, S3FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S3File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3FileFindFirstArgs} args - Arguments to find a S3File
     * @example
     * // Get one S3File
     * const s3File = await prisma.s3File.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends S3FileFindFirstArgs>(args?: SelectSubset<T, S3FileFindFirstArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first S3File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3FileFindFirstOrThrowArgs} args - Arguments to find a S3File
     * @example
     * // Get one S3File
     * const s3File = await prisma.s3File.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends S3FileFindFirstOrThrowArgs>(args?: SelectSubset<T, S3FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more S3Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all S3Files
     * const s3Files = await prisma.s3File.findMany()
     * 
     * // Get first 10 S3Files
     * const s3Files = await prisma.s3File.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const s3FileWithIdOnly = await prisma.s3File.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends S3FileFindManyArgs>(args?: SelectSubset<T, S3FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a S3File.
     * @param {S3FileCreateArgs} args - Arguments to create a S3File.
     * @example
     * // Create one S3File
     * const S3File = await prisma.s3File.create({
     *   data: {
     *     // ... data to create a S3File
     *   }
     * })
     * 
     */
    create<T extends S3FileCreateArgs>(args: SelectSubset<T, S3FileCreateArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many S3Files.
     * @param {S3FileCreateManyArgs} args - Arguments to create many S3Files.
     * @example
     * // Create many S3Files
     * const s3File = await prisma.s3File.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends S3FileCreateManyArgs>(args?: SelectSubset<T, S3FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many S3Files and returns the data saved in the database.
     * @param {S3FileCreateManyAndReturnArgs} args - Arguments to create many S3Files.
     * @example
     * // Create many S3Files
     * const s3File = await prisma.s3File.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many S3Files and only return the `id`
     * const s3FileWithIdOnly = await prisma.s3File.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends S3FileCreateManyAndReturnArgs>(args?: SelectSubset<T, S3FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a S3File.
     * @param {S3FileDeleteArgs} args - Arguments to delete one S3File.
     * @example
     * // Delete one S3File
     * const S3File = await prisma.s3File.delete({
     *   where: {
     *     // ... filter to delete one S3File
     *   }
     * })
     * 
     */
    delete<T extends S3FileDeleteArgs>(args: SelectSubset<T, S3FileDeleteArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one S3File.
     * @param {S3FileUpdateArgs} args - Arguments to update one S3File.
     * @example
     * // Update one S3File
     * const s3File = await prisma.s3File.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends S3FileUpdateArgs>(args: SelectSubset<T, S3FileUpdateArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more S3Files.
     * @param {S3FileDeleteManyArgs} args - Arguments to filter S3Files to delete.
     * @example
     * // Delete a few S3Files
     * const { count } = await prisma.s3File.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends S3FileDeleteManyArgs>(args?: SelectSubset<T, S3FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S3Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many S3Files
     * const s3File = await prisma.s3File.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends S3FileUpdateManyArgs>(args: SelectSubset<T, S3FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more S3Files and returns the data updated in the database.
     * @param {S3FileUpdateManyAndReturnArgs} args - Arguments to update many S3Files.
     * @example
     * // Update many S3Files
     * const s3File = await prisma.s3File.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more S3Files and only return the `id`
     * const s3FileWithIdOnly = await prisma.s3File.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends S3FileUpdateManyAndReturnArgs>(args: SelectSubset<T, S3FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one S3File.
     * @param {S3FileUpsertArgs} args - Arguments to update or create a S3File.
     * @example
     * // Update or create a S3File
     * const s3File = await prisma.s3File.upsert({
     *   create: {
     *     // ... data to create a S3File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the S3File we want to update
     *   }
     * })
     */
    upsert<T extends S3FileUpsertArgs>(args: SelectSubset<T, S3FileUpsertArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of S3Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3FileCountArgs} args - Arguments to filter S3Files to count.
     * @example
     * // Count the number of S3Files
     * const count = await prisma.s3File.count({
     *   where: {
     *     // ... the filter for the S3Files we want to count
     *   }
     * })
    **/
    count<T extends S3FileCountArgs>(
      args?: Subset<T, S3FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], S3FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a S3File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends S3FileAggregateArgs>(args: Subset<T, S3FileAggregateArgs>): Prisma.PrismaPromise<GetS3FileAggregateType<T>>

    /**
     * Group by S3File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {S3FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends S3FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: S3FileGroupByArgs['orderBy'] }
        : { orderBy?: S3FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, S3FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetS3FileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the S3File model
   */
  readonly fields: S3FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for S3File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__S3FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserRoyaltyReport<T extends S3File$UserRoyaltyReportArgs<ExtArgs> = {}>(args?: Subset<T, S3File$UserRoyaltyReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BaseRoyaltyReport<T extends S3File$BaseRoyaltyReportArgs<ExtArgs> = {}>(args?: Subset<T, S3File$BaseRoyaltyReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ImportedRoyaltyReport<T extends S3File$ImportedRoyaltyReportArgs<ExtArgs> = {}>(args?: Subset<T, S3File$ImportedRoyaltyReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the S3File model
   */
  interface S3FileFieldRefs {
    readonly id: FieldRef<"S3File", 'Int'>
    readonly createdAt: FieldRef<"S3File", 'DateTime'>
    readonly updatedAt: FieldRef<"S3File", 'DateTime'>
    readonly fileName: FieldRef<"S3File", 'String'>
    readonly type: FieldRef<"S3File", 'String'>
    readonly folder: FieldRef<"S3File", 'String'>
    readonly bucket: FieldRef<"S3File", 'String'>
    readonly key: FieldRef<"S3File", 'String'>
  }
    

  // Custom InputTypes
  /**
   * S3File findUnique
   */
  export type S3FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    /**
     * Filter, which S3File to fetch.
     */
    where: S3FileWhereUniqueInput
  }

  /**
   * S3File findUniqueOrThrow
   */
  export type S3FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    /**
     * Filter, which S3File to fetch.
     */
    where: S3FileWhereUniqueInput
  }

  /**
   * S3File findFirst
   */
  export type S3FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    /**
     * Filter, which S3File to fetch.
     */
    where?: S3FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of S3Files to fetch.
     */
    orderBy?: S3FileOrderByWithRelationInput | S3FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for S3Files.
     */
    cursor?: S3FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` S3Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` S3Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of S3Files.
     */
    distinct?: S3FileScalarFieldEnum | S3FileScalarFieldEnum[]
  }

  /**
   * S3File findFirstOrThrow
   */
  export type S3FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    /**
     * Filter, which S3File to fetch.
     */
    where?: S3FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of S3Files to fetch.
     */
    orderBy?: S3FileOrderByWithRelationInput | S3FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for S3Files.
     */
    cursor?: S3FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` S3Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` S3Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of S3Files.
     */
    distinct?: S3FileScalarFieldEnum | S3FileScalarFieldEnum[]
  }

  /**
   * S3File findMany
   */
  export type S3FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    /**
     * Filter, which S3Files to fetch.
     */
    where?: S3FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of S3Files to fetch.
     */
    orderBy?: S3FileOrderByWithRelationInput | S3FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing S3Files.
     */
    cursor?: S3FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` S3Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` S3Files.
     */
    skip?: number
    distinct?: S3FileScalarFieldEnum | S3FileScalarFieldEnum[]
  }

  /**
   * S3File create
   */
  export type S3FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    /**
     * The data needed to create a S3File.
     */
    data: XOR<S3FileCreateInput, S3FileUncheckedCreateInput>
  }

  /**
   * S3File createMany
   */
  export type S3FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many S3Files.
     */
    data: S3FileCreateManyInput | S3FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * S3File createManyAndReturn
   */
  export type S3FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * The data used to create many S3Files.
     */
    data: S3FileCreateManyInput | S3FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * S3File update
   */
  export type S3FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    /**
     * The data needed to update a S3File.
     */
    data: XOR<S3FileUpdateInput, S3FileUncheckedUpdateInput>
    /**
     * Choose, which S3File to update.
     */
    where: S3FileWhereUniqueInput
  }

  /**
   * S3File updateMany
   */
  export type S3FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update S3Files.
     */
    data: XOR<S3FileUpdateManyMutationInput, S3FileUncheckedUpdateManyInput>
    /**
     * Filter which S3Files to update
     */
    where?: S3FileWhereInput
    /**
     * Limit how many S3Files to update.
     */
    limit?: number
  }

  /**
   * S3File updateManyAndReturn
   */
  export type S3FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * The data used to update S3Files.
     */
    data: XOR<S3FileUpdateManyMutationInput, S3FileUncheckedUpdateManyInput>
    /**
     * Filter which S3Files to update
     */
    where?: S3FileWhereInput
    /**
     * Limit how many S3Files to update.
     */
    limit?: number
  }

  /**
   * S3File upsert
   */
  export type S3FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    /**
     * The filter to search for the S3File to update in case it exists.
     */
    where: S3FileWhereUniqueInput
    /**
     * In case the S3File found by the `where` argument doesn't exist, create a new S3File with this data.
     */
    create: XOR<S3FileCreateInput, S3FileUncheckedCreateInput>
    /**
     * In case the S3File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<S3FileUpdateInput, S3FileUncheckedUpdateInput>
  }

  /**
   * S3File delete
   */
  export type S3FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    /**
     * Filter which S3File to delete.
     */
    where: S3FileWhereUniqueInput
  }

  /**
   * S3File deleteMany
   */
  export type S3FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which S3Files to delete
     */
    where?: S3FileWhereInput
    /**
     * Limit how many S3Files to delete.
     */
    limit?: number
  }

  /**
   * S3File.UserRoyaltyReport
   */
  export type S3File$UserRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    where?: UserRoyaltyReportWhereInput
    orderBy?: UserRoyaltyReportOrderByWithRelationInput | UserRoyaltyReportOrderByWithRelationInput[]
    cursor?: UserRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoyaltyReportScalarFieldEnum | UserRoyaltyReportScalarFieldEnum[]
  }

  /**
   * S3File.BaseRoyaltyReport
   */
  export type S3File$BaseRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    where?: BaseRoyaltyReportWhereInput
    orderBy?: BaseRoyaltyReportOrderByWithRelationInput | BaseRoyaltyReportOrderByWithRelationInput[]
    cursor?: BaseRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BaseRoyaltyReportScalarFieldEnum | BaseRoyaltyReportScalarFieldEnum[]
  }

  /**
   * S3File.ImportedRoyaltyReport
   */
  export type S3File$ImportedRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    where?: ImportedRoyaltyReportWhereInput
    orderBy?: ImportedRoyaltyReportOrderByWithRelationInput | ImportedRoyaltyReportOrderByWithRelationInput[]
    cursor?: ImportedRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportedRoyaltyReportScalarFieldEnum | ImportedRoyaltyReportScalarFieldEnum[]
  }

  /**
   * S3File without action
   */
  export type S3FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    objectId: number | null
  }

  export type LogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    objectId: number | null
  }

  export type LogMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: number | null
    object: string | null
    objectId: number | null
    message: string | null
    script: string | null
    ip: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: number | null
    object: string | null
    objectId: number | null
    message: string | null
    script: string | null
    ip: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    object: number
    objectId: number
    message: number
    script: number
    ip: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    id?: true
    userId?: true
    objectId?: true
  }

  export type LogSumAggregateInputType = {
    id?: true
    userId?: true
    objectId?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    object?: true
    objectId?: true
    message?: true
    script?: true
    ip?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    object?: true
    objectId?: true
    message?: true
    script?: true
    ip?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    object?: true
    objectId?: true
    message?: true
    script?: true
    ip?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: number
    createdAt: Date
    userId: number
    object: string
    objectId: number | null
    message: string
    script: string | null
    ip: string | null
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    object?: boolean
    objectId?: boolean
    message?: boolean
    script?: boolean
    ip?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    object?: boolean
    objectId?: boolean
    message?: boolean
    script?: boolean
    ip?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    object?: boolean
    objectId?: boolean
    message?: boolean
    script?: boolean
    ip?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    object?: boolean
    objectId?: boolean
    message?: boolean
    script?: boolean
    ip?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "userId" | "object" | "objectId" | "message" | "script" | "ip", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      userId: number
      object: string
      objectId: number | null
      message: string
      script: string | null
      ip: string | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {LogUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogUpdateManyAndReturnArgs>(args: SelectSubset<T, LogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'Int'>
    readonly createdAt: FieldRef<"Log", 'DateTime'>
    readonly userId: FieldRef<"Log", 'Int'>
    readonly object: FieldRef<"Log", 'String'>
    readonly objectId: FieldRef<"Log", 'Int'>
    readonly message: FieldRef<"Log", 'String'>
    readonly script: FieldRef<"Log", 'String'>
    readonly ip: FieldRef<"Log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log updateManyAndReturn
   */
  export type LogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    email: string | null
    password: string | null
    fullName: string | null
    usernameDMB: string | null
    role: $Enums.Role | null
    clientId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    email: string | null
    password: string | null
    fullName: string | null
    usernameDMB: string | null
    role: $Enums.Role | null
    clientId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    username: number
    email: number
    password: number
    fullName: number
    usernameDMB: number
    role: number
    clientId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    email?: true
    password?: true
    fullName?: true
    usernameDMB?: true
    role?: true
    clientId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    email?: true
    password?: true
    fullName?: true
    usernameDMB?: true
    role?: true
    clientId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    email?: true
    password?: true
    fullName?: true
    usernameDMB?: true
    role?: true
    clientId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    username: string
    email: string
    password: string
    fullName: string
    usernameDMB: string | null
    role: $Enums.Role
    clientId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    usernameDMB?: boolean
    role?: boolean
    clientId?: boolean
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    comms?: boolean | User$commsArgs<ExtArgs>
    client?: boolean | User$clientArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    resetToken?: boolean | User$resetTokenArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    usernameDMB?: boolean
    role?: boolean
    clientId?: boolean
    client?: boolean | User$clientArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    usernameDMB?: boolean
    role?: boolean
    clientId?: boolean
    client?: boolean | User$clientArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    usernameDMB?: boolean
    role?: boolean
    clientId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "username" | "email" | "password" | "fullName" | "usernameDMB" | "role" | "clientId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    comms?: boolean | User$commsArgs<ExtArgs>
    client?: boolean | User$clientArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    resetToken?: boolean | User$resetTokenArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | User$clientArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | User$clientArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      preferences: Prisma.$UserPreferencesPayload<ExtArgs>[]
      comms: Prisma.$UserCommsPayload<ExtArgs>[]
      client: Prisma.$ClientPayload<ExtArgs> | null
      logs: Prisma.$LogPayload<ExtArgs>[]
      resetToken: Prisma.$PasswordResetTokenPayload<ExtArgs> | null
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      username: string
      email: string
      password: string
      fullName: string
      usernameDMB: string | null
      role: $Enums.Role
      clientId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comms<T extends User$commsArgs<ExtArgs> = {}>(args?: Subset<T, User$commsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client<T extends User$clientArgs<ExtArgs> = {}>(args?: Subset<T, User$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resetToken<T extends User$resetTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$resetTokenArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly usernameDMB: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly clientId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    cursor?: UserPreferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * User.comms
   */
  export type User$commsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
    where?: UserCommsWhereInput
    orderBy?: UserCommsOrderByWithRelationInput | UserCommsOrderByWithRelationInput[]
    cursor?: UserCommsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCommsScalarFieldEnum | UserCommsScalarFieldEnum[]
  }

  /**
   * User.client
   */
  export type User$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * User.resetToken
   */
  export type User$resetTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    expiresAt: Date | null
    userId: number | null
    createdAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    expiresAt: Date | null
    userId: number | null
    createdAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    token: number
    expiresAt: number
    userId: number
    createdAt: number
    _all: number
  }


  export type PasswordResetTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _avg?: PasswordResetTokenAvgAggregateInputType
    _sum?: PasswordResetTokenSumAggregateInputType
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: number
    token: string
    expiresAt: Date
    userId: number
    createdAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "expiresAt" | "userId" | "createdAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      expiresAt: Date
      userId: number
      createdAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'Int'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly userId: FieldRef<"PasswordResetToken", 'Int'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model UserPreferences
   */

  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPreferencesSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    fontSize: string | null
    mainMenuCollapsed: boolean | null
    theme: string | null
    language: string | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    fontSize: string | null
    mainMenuCollapsed: boolean | null
    theme: string | null
    language: string | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    fontSize: number
    mainMenuCollapsed: number
    theme: number
    language: number
    _all: number
  }


  export type UserPreferencesAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPreferencesSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPreferencesMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    fontSize?: true
    mainMenuCollapsed?: true
    theme?: true
    language?: true
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    fontSize?: true
    mainMenuCollapsed?: true
    theme?: true
    language?: true
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    fontSize?: true
    mainMenuCollapsed?: true
    theme?: true
    language?: true
    _all?: true
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[]
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferencesCountAggregateInputType | true
    _avg?: UserPreferencesAvgAggregateInputType
    _sum?: UserPreferencesSumAggregateInputType
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type UserPreferencesGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    userId: number | null
    fontSize: string | null
    mainMenuCollapsed: boolean | null
    theme: string | null
    language: string | null
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    fontSize?: boolean
    mainMenuCollapsed?: boolean
    theme?: boolean
    language?: boolean
    user?: boolean | UserPreferences$userArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    fontSize?: boolean
    mainMenuCollapsed?: boolean
    theme?: boolean
    language?: boolean
    user?: boolean | UserPreferences$userArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    fontSize?: boolean
    mainMenuCollapsed?: boolean
    theme?: boolean
    language?: boolean
    user?: boolean | UserPreferences$userArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    fontSize?: boolean
    mainMenuCollapsed?: boolean
    theme?: boolean
    language?: boolean
  }

  export type UserPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "userId" | "fontSize" | "mainMenuCollapsed" | "theme" | "language", ExtArgs["result"]["userPreferences"]>
  export type UserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPreferences$userArgs<ExtArgs>
  }
  export type UserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPreferences$userArgs<ExtArgs>
  }
  export type UserPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPreferences$userArgs<ExtArgs>
  }

  export type $UserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      userId: number | null
      fontSize: string | null
      mainMenuCollapsed: boolean | null
      theme: string | null
      language: string | null
    }, ExtArgs["result"]["userPreferences"]>
    composites: {}
  }

  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferencesFindUniqueArgs>(args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferencesFindFirstArgs>(args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferencesFindManyArgs>(args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
     */
    create<T extends UserPreferencesCreateArgs>(args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferencesCreateManyArgs>(args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserPreferencesDeleteArgs>(args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferencesUpdateArgs>(args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferencesUpdateManyArgs>(args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferencesUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferencesUpsertArgs>(args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserPreferences$userArgs<ExtArgs> = {}>(args?: Subset<T, UserPreferences$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferences model
   */
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'Int'>
    readonly createdAt: FieldRef<"UserPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPreferences", 'DateTime'>
    readonly userId: FieldRef<"UserPreferences", 'Int'>
    readonly fontSize: FieldRef<"UserPreferences", 'String'>
    readonly mainMenuCollapsed: FieldRef<"UserPreferences", 'Boolean'>
    readonly theme: FieldRef<"UserPreferences", 'String'>
    readonly language: FieldRef<"UserPreferences", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }

  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreferences createManyAndReturn
   */
  export type UserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreferences updateManyAndReturn
   */
  export type UserPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }

  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreferences.user
   */
  export type UserPreferences$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserPreferences without action
   */
  export type UserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model UserComms
   */

  export type AggregateUserComms = {
    _count: UserCommsCountAggregateOutputType | null
    _avg: UserCommsAvgAggregateOutputType | null
    _sum: UserCommsSumAggregateOutputType | null
    _min: UserCommsMinAggregateOutputType | null
    _max: UserCommsMaxAggregateOutputType | null
  }

  export type UserCommsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserCommsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserCommsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    type: $Enums.CommsChannels | null
    value: string | null
  }

  export type UserCommsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    type: $Enums.CommsChannels | null
    value: string | null
  }

  export type UserCommsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    type: number
    value: number
    _all: number
  }


  export type UserCommsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserCommsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserCommsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    type?: true
    value?: true
  }

  export type UserCommsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    type?: true
    value?: true
  }

  export type UserCommsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    type?: true
    value?: true
    _all?: true
  }

  export type UserCommsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserComms to aggregate.
     */
    where?: UserCommsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserComms to fetch.
     */
    orderBy?: UserCommsOrderByWithRelationInput | UserCommsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCommsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserComms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserComms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserComms
    **/
    _count?: true | UserCommsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCommsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCommsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCommsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCommsMaxAggregateInputType
  }

  export type GetUserCommsAggregateType<T extends UserCommsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserComms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserComms[P]>
      : GetScalarType<T[P], AggregateUserComms[P]>
  }




  export type UserCommsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCommsWhereInput
    orderBy?: UserCommsOrderByWithAggregationInput | UserCommsOrderByWithAggregationInput[]
    by: UserCommsScalarFieldEnum[] | UserCommsScalarFieldEnum
    having?: UserCommsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCommsCountAggregateInputType | true
    _avg?: UserCommsAvgAggregateInputType
    _sum?: UserCommsSumAggregateInputType
    _min?: UserCommsMinAggregateInputType
    _max?: UserCommsMaxAggregateInputType
  }

  export type UserCommsGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    userId: number
    type: $Enums.CommsChannels
    value: string
    _count: UserCommsCountAggregateOutputType | null
    _avg: UserCommsAvgAggregateOutputType | null
    _sum: UserCommsSumAggregateOutputType | null
    _min: UserCommsMinAggregateOutputType | null
    _max: UserCommsMaxAggregateOutputType | null
  }

  type GetUserCommsGroupByPayload<T extends UserCommsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCommsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCommsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCommsGroupByOutputType[P]>
            : GetScalarType<T[P], UserCommsGroupByOutputType[P]>
        }
      >
    >


  export type UserCommsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userComms"]>

  export type UserCommsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userComms"]>

  export type UserCommsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userComms"]>

  export type UserCommsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
  }

  export type UserCommsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "userId" | "type" | "value", ExtArgs["result"]["userComms"]>
  export type UserCommsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserCommsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserCommsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserCommsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserComms"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      userId: number
      type: $Enums.CommsChannels
      value: string
    }, ExtArgs["result"]["userComms"]>
    composites: {}
  }

  type UserCommsGetPayload<S extends boolean | null | undefined | UserCommsDefaultArgs> = $Result.GetResult<Prisma.$UserCommsPayload, S>

  type UserCommsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCommsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCommsCountAggregateInputType | true
    }

  export interface UserCommsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserComms'], meta: { name: 'UserComms' } }
    /**
     * Find zero or one UserComms that matches the filter.
     * @param {UserCommsFindUniqueArgs} args - Arguments to find a UserComms
     * @example
     * // Get one UserComms
     * const userComms = await prisma.userComms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCommsFindUniqueArgs>(args: SelectSubset<T, UserCommsFindUniqueArgs<ExtArgs>>): Prisma__UserCommsClient<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserComms that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCommsFindUniqueOrThrowArgs} args - Arguments to find a UserComms
     * @example
     * // Get one UserComms
     * const userComms = await prisma.userComms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCommsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCommsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCommsClient<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserComms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommsFindFirstArgs} args - Arguments to find a UserComms
     * @example
     * // Get one UserComms
     * const userComms = await prisma.userComms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCommsFindFirstArgs>(args?: SelectSubset<T, UserCommsFindFirstArgs<ExtArgs>>): Prisma__UserCommsClient<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserComms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommsFindFirstOrThrowArgs} args - Arguments to find a UserComms
     * @example
     * // Get one UserComms
     * const userComms = await prisma.userComms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCommsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCommsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCommsClient<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserComms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserComms
     * const userComms = await prisma.userComms.findMany()
     * 
     * // Get first 10 UserComms
     * const userComms = await prisma.userComms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCommsWithIdOnly = await prisma.userComms.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCommsFindManyArgs>(args?: SelectSubset<T, UserCommsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserComms.
     * @param {UserCommsCreateArgs} args - Arguments to create a UserComms.
     * @example
     * // Create one UserComms
     * const UserComms = await prisma.userComms.create({
     *   data: {
     *     // ... data to create a UserComms
     *   }
     * })
     * 
     */
    create<T extends UserCommsCreateArgs>(args: SelectSubset<T, UserCommsCreateArgs<ExtArgs>>): Prisma__UserCommsClient<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserComms.
     * @param {UserCommsCreateManyArgs} args - Arguments to create many UserComms.
     * @example
     * // Create many UserComms
     * const userComms = await prisma.userComms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCommsCreateManyArgs>(args?: SelectSubset<T, UserCommsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserComms and returns the data saved in the database.
     * @param {UserCommsCreateManyAndReturnArgs} args - Arguments to create many UserComms.
     * @example
     * // Create many UserComms
     * const userComms = await prisma.userComms.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserComms and only return the `id`
     * const userCommsWithIdOnly = await prisma.userComms.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCommsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCommsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserComms.
     * @param {UserCommsDeleteArgs} args - Arguments to delete one UserComms.
     * @example
     * // Delete one UserComms
     * const UserComms = await prisma.userComms.delete({
     *   where: {
     *     // ... filter to delete one UserComms
     *   }
     * })
     * 
     */
    delete<T extends UserCommsDeleteArgs>(args: SelectSubset<T, UserCommsDeleteArgs<ExtArgs>>): Prisma__UserCommsClient<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserComms.
     * @param {UserCommsUpdateArgs} args - Arguments to update one UserComms.
     * @example
     * // Update one UserComms
     * const userComms = await prisma.userComms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCommsUpdateArgs>(args: SelectSubset<T, UserCommsUpdateArgs<ExtArgs>>): Prisma__UserCommsClient<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserComms.
     * @param {UserCommsDeleteManyArgs} args - Arguments to filter UserComms to delete.
     * @example
     * // Delete a few UserComms
     * const { count } = await prisma.userComms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCommsDeleteManyArgs>(args?: SelectSubset<T, UserCommsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserComms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserComms
     * const userComms = await prisma.userComms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCommsUpdateManyArgs>(args: SelectSubset<T, UserCommsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserComms and returns the data updated in the database.
     * @param {UserCommsUpdateManyAndReturnArgs} args - Arguments to update many UserComms.
     * @example
     * // Update many UserComms
     * const userComms = await prisma.userComms.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserComms and only return the `id`
     * const userCommsWithIdOnly = await prisma.userComms.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCommsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCommsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserComms.
     * @param {UserCommsUpsertArgs} args - Arguments to update or create a UserComms.
     * @example
     * // Update or create a UserComms
     * const userComms = await prisma.userComms.upsert({
     *   create: {
     *     // ... data to create a UserComms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserComms we want to update
     *   }
     * })
     */
    upsert<T extends UserCommsUpsertArgs>(args: SelectSubset<T, UserCommsUpsertArgs<ExtArgs>>): Prisma__UserCommsClient<$Result.GetResult<Prisma.$UserCommsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserComms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommsCountArgs} args - Arguments to filter UserComms to count.
     * @example
     * // Count the number of UserComms
     * const count = await prisma.userComms.count({
     *   where: {
     *     // ... the filter for the UserComms we want to count
     *   }
     * })
    **/
    count<T extends UserCommsCountArgs>(
      args?: Subset<T, UserCommsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCommsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserComms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCommsAggregateArgs>(args: Subset<T, UserCommsAggregateArgs>): Prisma.PrismaPromise<GetUserCommsAggregateType<T>>

    /**
     * Group by UserComms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCommsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCommsGroupByArgs['orderBy'] }
        : { orderBy?: UserCommsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCommsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCommsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserComms model
   */
  readonly fields: UserCommsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserComms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCommsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserComms model
   */
  interface UserCommsFieldRefs {
    readonly id: FieldRef<"UserComms", 'Int'>
    readonly createdAt: FieldRef<"UserComms", 'DateTime'>
    readonly updatedAt: FieldRef<"UserComms", 'DateTime'>
    readonly userId: FieldRef<"UserComms", 'Int'>
    readonly type: FieldRef<"UserComms", 'CommsChannels'>
    readonly value: FieldRef<"UserComms", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserComms findUnique
   */
  export type UserCommsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
    /**
     * Filter, which UserComms to fetch.
     */
    where: UserCommsWhereUniqueInput
  }

  /**
   * UserComms findUniqueOrThrow
   */
  export type UserCommsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
    /**
     * Filter, which UserComms to fetch.
     */
    where: UserCommsWhereUniqueInput
  }

  /**
   * UserComms findFirst
   */
  export type UserCommsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
    /**
     * Filter, which UserComms to fetch.
     */
    where?: UserCommsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserComms to fetch.
     */
    orderBy?: UserCommsOrderByWithRelationInput | UserCommsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserComms.
     */
    cursor?: UserCommsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserComms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserComms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserComms.
     */
    distinct?: UserCommsScalarFieldEnum | UserCommsScalarFieldEnum[]
  }

  /**
   * UserComms findFirstOrThrow
   */
  export type UserCommsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
    /**
     * Filter, which UserComms to fetch.
     */
    where?: UserCommsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserComms to fetch.
     */
    orderBy?: UserCommsOrderByWithRelationInput | UserCommsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserComms.
     */
    cursor?: UserCommsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserComms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserComms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserComms.
     */
    distinct?: UserCommsScalarFieldEnum | UserCommsScalarFieldEnum[]
  }

  /**
   * UserComms findMany
   */
  export type UserCommsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
    /**
     * Filter, which UserComms to fetch.
     */
    where?: UserCommsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserComms to fetch.
     */
    orderBy?: UserCommsOrderByWithRelationInput | UserCommsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserComms.
     */
    cursor?: UserCommsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserComms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserComms.
     */
    skip?: number
    distinct?: UserCommsScalarFieldEnum | UserCommsScalarFieldEnum[]
  }

  /**
   * UserComms create
   */
  export type UserCommsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserComms.
     */
    data: XOR<UserCommsCreateInput, UserCommsUncheckedCreateInput>
  }

  /**
   * UserComms createMany
   */
  export type UserCommsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserComms.
     */
    data: UserCommsCreateManyInput | UserCommsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserComms createManyAndReturn
   */
  export type UserCommsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * The data used to create many UserComms.
     */
    data: UserCommsCreateManyInput | UserCommsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserComms update
   */
  export type UserCommsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserComms.
     */
    data: XOR<UserCommsUpdateInput, UserCommsUncheckedUpdateInput>
    /**
     * Choose, which UserComms to update.
     */
    where: UserCommsWhereUniqueInput
  }

  /**
   * UserComms updateMany
   */
  export type UserCommsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserComms.
     */
    data: XOR<UserCommsUpdateManyMutationInput, UserCommsUncheckedUpdateManyInput>
    /**
     * Filter which UserComms to update
     */
    where?: UserCommsWhereInput
    /**
     * Limit how many UserComms to update.
     */
    limit?: number
  }

  /**
   * UserComms updateManyAndReturn
   */
  export type UserCommsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * The data used to update UserComms.
     */
    data: XOR<UserCommsUpdateManyMutationInput, UserCommsUncheckedUpdateManyInput>
    /**
     * Filter which UserComms to update
     */
    where?: UserCommsWhereInput
    /**
     * Limit how many UserComms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserComms upsert
   */
  export type UserCommsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserComms to update in case it exists.
     */
    where: UserCommsWhereUniqueInput
    /**
     * In case the UserComms found by the `where` argument doesn't exist, create a new UserComms with this data.
     */
    create: XOR<UserCommsCreateInput, UserCommsUncheckedCreateInput>
    /**
     * In case the UserComms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCommsUpdateInput, UserCommsUncheckedUpdateInput>
  }

  /**
   * UserComms delete
   */
  export type UserCommsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
    /**
     * Filter which UserComms to delete.
     */
    where: UserCommsWhereUniqueInput
  }

  /**
   * UserComms deleteMany
   */
  export type UserCommsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserComms to delete
     */
    where?: UserCommsWhereInput
    /**
     * Limit how many UserComms to delete.
     */
    limit?: number
  }

  /**
   * UserComms without action
   */
  export type UserCommsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserComms
     */
    select?: UserCommsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserComms
     */
    omit?: UserCommsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCommsInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
    wp_id: number | null
    addressId: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
    wp_id: number | null
    addressId: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    wp_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientName: string | null
    firstName: string | null
    lastName: string | null
    type: $Enums.ClientType | null
    addressId: number | null
    taxIdType: $Enums.TaxIdType | null
    taxId: string | null
    vatRegistered: boolean | null
    vatId: string | null
    status: $Enums.ClientStatus | null
    isBlocked: boolean | null
    isPaymentsBlocked: boolean | null
    isPaymentInProgress: boolean | null
    isPaymentDataInValidation: boolean | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    wp_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientName: string | null
    firstName: string | null
    lastName: string | null
    type: $Enums.ClientType | null
    addressId: number | null
    taxIdType: $Enums.TaxIdType | null
    taxId: string | null
    vatRegistered: boolean | null
    vatId: string | null
    status: $Enums.ClientStatus | null
    isBlocked: boolean | null
    isPaymentsBlocked: boolean | null
    isPaymentInProgress: boolean | null
    isPaymentDataInValidation: boolean | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    wp_id: number
    createdAt: number
    updatedAt: number
    clientName: number
    firstName: number
    lastName: number
    type: number
    addressId: number
    taxIdType: number
    taxId: number
    vatRegistered: number
    vatId: number
    status: number
    isBlocked: number
    isPaymentsBlocked: number
    isPaymentInProgress: number
    isPaymentDataInValidation: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
    wp_id?: true
    addressId?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
    wp_id?: true
    addressId?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    wp_id?: true
    createdAt?: true
    updatedAt?: true
    clientName?: true
    firstName?: true
    lastName?: true
    type?: true
    addressId?: true
    taxIdType?: true
    taxId?: true
    vatRegistered?: true
    vatId?: true
    status?: true
    isBlocked?: true
    isPaymentsBlocked?: true
    isPaymentInProgress?: true
    isPaymentDataInValidation?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    wp_id?: true
    createdAt?: true
    updatedAt?: true
    clientName?: true
    firstName?: true
    lastName?: true
    type?: true
    addressId?: true
    taxIdType?: true
    taxId?: true
    vatRegistered?: true
    vatId?: true
    status?: true
    isBlocked?: true
    isPaymentsBlocked?: true
    isPaymentInProgress?: true
    isPaymentDataInValidation?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    wp_id?: true
    createdAt?: true
    updatedAt?: true
    clientName?: true
    firstName?: true
    lastName?: true
    type?: true
    addressId?: true
    taxIdType?: true
    taxId?: true
    vatRegistered?: true
    vatId?: true
    status?: true
    isBlocked?: true
    isPaymentsBlocked?: true
    isPaymentInProgress?: true
    isPaymentDataInValidation?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    wp_id: number | null
    createdAt: Date
    updatedAt: Date
    clientName: string
    firstName: string
    lastName: string
    type: $Enums.ClientType
    addressId: number
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered: boolean
    vatId: string | null
    status: $Enums.ClientStatus
    isBlocked: boolean | null
    isPaymentsBlocked: boolean | null
    isPaymentInProgress: boolean
    isPaymentDataInValidation: boolean
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wp_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientName?: boolean
    firstName?: boolean
    lastName?: boolean
    type?: boolean
    addressId?: boolean
    taxIdType?: boolean
    taxId?: boolean
    vatRegistered?: boolean
    vatId?: boolean
    status?: boolean
    isBlocked?: boolean
    isPaymentsBlocked?: boolean
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
    dmb?: boolean | Client$dmbArgs<ExtArgs>
    balances?: boolean | Client$balancesArgs<ExtArgs>
    paymentData?: boolean | Client$paymentDataArgs<ExtArgs>
    labels?: boolean | Client$labelsArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    contract?: boolean | Client$contractArgs<ExtArgs>
    userRoyaltyReport?: boolean | Client$userRoyaltyReportArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wp_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientName?: boolean
    firstName?: boolean
    lastName?: boolean
    type?: boolean
    addressId?: boolean
    taxIdType?: boolean
    taxId?: boolean
    vatRegistered?: boolean
    vatId?: boolean
    status?: boolean
    isBlocked?: boolean
    isPaymentsBlocked?: boolean
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wp_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientName?: boolean
    firstName?: boolean
    lastName?: boolean
    type?: boolean
    addressId?: boolean
    taxIdType?: boolean
    taxId?: boolean
    vatRegistered?: boolean
    vatId?: boolean
    status?: boolean
    isBlocked?: boolean
    isPaymentsBlocked?: boolean
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    wp_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientName?: boolean
    firstName?: boolean
    lastName?: boolean
    type?: boolean
    addressId?: boolean
    taxIdType?: boolean
    taxId?: boolean
    vatRegistered?: boolean
    vatId?: boolean
    status?: boolean
    isBlocked?: boolean
    isPaymentsBlocked?: boolean
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wp_id" | "createdAt" | "updatedAt" | "clientName" | "firstName" | "lastName" | "type" | "addressId" | "taxIdType" | "taxId" | "vatRegistered" | "vatId" | "status" | "isBlocked" | "isPaymentsBlocked" | "isPaymentInProgress" | "isPaymentDataInValidation", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
    dmb?: boolean | Client$dmbArgs<ExtArgs>
    balances?: boolean | Client$balancesArgs<ExtArgs>
    paymentData?: boolean | Client$paymentDataArgs<ExtArgs>
    labels?: boolean | Client$labelsArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    contract?: boolean | Client$contractArgs<ExtArgs>
    userRoyaltyReport?: boolean | Client$userRoyaltyReportArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>
      dmb: Prisma.$ClientDMBPayload<ExtArgs> | null
      balances: Prisma.$BalancePayload<ExtArgs>[]
      paymentData: Prisma.$ClientPaymentInformationPayload<ExtArgs> | null
      labels: Prisma.$LabelPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      contract: Prisma.$ContractPayload<ExtArgs> | null
      userRoyaltyReport: Prisma.$UserRoyaltyReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      wp_id: number | null
      createdAt: Date
      updatedAt: Date
      clientName: string
      firstName: string
      lastName: string
      type: $Enums.ClientType
      addressId: number
      taxIdType: $Enums.TaxIdType
      taxId: string
      vatRegistered: boolean
      vatId: string | null
      status: $Enums.ClientStatus
      isBlocked: boolean | null
      isPaymentsBlocked: boolean | null
      isPaymentInProgress: boolean
      isPaymentDataInValidation: boolean
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends AddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressDefaultArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dmb<T extends Client$dmbArgs<ExtArgs> = {}>(args?: Subset<T, Client$dmbArgs<ExtArgs>>): Prisma__ClientDMBClient<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    balances<T extends Client$balancesArgs<ExtArgs> = {}>(args?: Subset<T, Client$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentData<T extends Client$paymentDataArgs<ExtArgs> = {}>(args?: Subset<T, Client$paymentDataArgs<ExtArgs>>): Prisma__ClientPaymentInformationClient<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    labels<T extends Client$labelsArgs<ExtArgs> = {}>(args?: Subset<T, Client$labelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Client$usersArgs<ExtArgs> = {}>(args?: Subset<T, Client$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contract<T extends Client$contractArgs<ExtArgs> = {}>(args?: Subset<T, Client$contractArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userRoyaltyReport<T extends Client$userRoyaltyReportArgs<ExtArgs> = {}>(args?: Subset<T, Client$userRoyaltyReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly wp_id: FieldRef<"Client", 'Int'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
    readonly clientName: FieldRef<"Client", 'String'>
    readonly firstName: FieldRef<"Client", 'String'>
    readonly lastName: FieldRef<"Client", 'String'>
    readonly type: FieldRef<"Client", 'ClientType'>
    readonly addressId: FieldRef<"Client", 'Int'>
    readonly taxIdType: FieldRef<"Client", 'TaxIdType'>
    readonly taxId: FieldRef<"Client", 'String'>
    readonly vatRegistered: FieldRef<"Client", 'Boolean'>
    readonly vatId: FieldRef<"Client", 'String'>
    readonly status: FieldRef<"Client", 'ClientStatus'>
    readonly isBlocked: FieldRef<"Client", 'Boolean'>
    readonly isPaymentsBlocked: FieldRef<"Client", 'Boolean'>
    readonly isPaymentInProgress: FieldRef<"Client", 'Boolean'>
    readonly isPaymentDataInValidation: FieldRef<"Client", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.dmb
   */
  export type Client$dmbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
    where?: ClientDMBWhereInput
  }

  /**
   * Client.balances
   */
  export type Client$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    cursor?: BalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Client.paymentData
   */
  export type Client$paymentDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
    where?: ClientPaymentInformationWhereInput
  }

  /**
   * Client.labels
   */
  export type Client$labelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    cursor?: LabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Client.users
   */
  export type Client$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Client.contract
   */
  export type Client$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
  }

  /**
   * Client.userRoyaltyReport
   */
  export type Client$userRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    where?: UserRoyaltyReportWhereInput
    orderBy?: UserRoyaltyReportOrderByWithRelationInput | UserRoyaltyReportOrderByWithRelationInput[]
    cursor?: UserRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoyaltyReportScalarFieldEnum | UserRoyaltyReportScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ClientDMB
   */

  export type AggregateClientDMB = {
    _count: ClientDMBCountAggregateOutputType | null
    _avg: ClientDMBAvgAggregateOutputType | null
    _sum: ClientDMBSumAggregateOutputType | null
    _min: ClientDMBMinAggregateOutputType | null
    _max: ClientDMBMaxAggregateOutputType | null
  }

  export type ClientDMBAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type ClientDMBSumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type ClientDMBMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: number | null
    accessType: $Enums.AccessTypeDMB | null
    status: $Enums.DMBStatus | null
    subclientName: string | null
    username: string | null
  }

  export type ClientDMBMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: number | null
    accessType: $Enums.AccessTypeDMB | null
    status: $Enums.DMBStatus | null
    subclientName: string | null
    username: string | null
  }

  export type ClientDMBCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    clientId: number
    accessType: number
    status: number
    subclientName: number
    username: number
    _all: number
  }


  export type ClientDMBAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type ClientDMBSumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type ClientDMBMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    accessType?: true
    status?: true
    subclientName?: true
    username?: true
  }

  export type ClientDMBMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    accessType?: true
    status?: true
    subclientName?: true
    username?: true
  }

  export type ClientDMBCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    accessType?: true
    status?: true
    subclientName?: true
    username?: true
    _all?: true
  }

  export type ClientDMBAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientDMB to aggregate.
     */
    where?: ClientDMBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDMBS to fetch.
     */
    orderBy?: ClientDMBOrderByWithRelationInput | ClientDMBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientDMBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDMBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDMBS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientDMBS
    **/
    _count?: true | ClientDMBCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientDMBAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientDMBSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientDMBMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientDMBMaxAggregateInputType
  }

  export type GetClientDMBAggregateType<T extends ClientDMBAggregateArgs> = {
        [P in keyof T & keyof AggregateClientDMB]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientDMB[P]>
      : GetScalarType<T[P], AggregateClientDMB[P]>
  }




  export type ClientDMBGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientDMBWhereInput
    orderBy?: ClientDMBOrderByWithAggregationInput | ClientDMBOrderByWithAggregationInput[]
    by: ClientDMBScalarFieldEnum[] | ClientDMBScalarFieldEnum
    having?: ClientDMBScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientDMBCountAggregateInputType | true
    _avg?: ClientDMBAvgAggregateInputType
    _sum?: ClientDMBSumAggregateInputType
    _min?: ClientDMBMinAggregateInputType
    _max?: ClientDMBMaxAggregateInputType
  }

  export type ClientDMBGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    clientId: number
    accessType: $Enums.AccessTypeDMB
    status: $Enums.DMBStatus
    subclientName: string | null
    username: string | null
    _count: ClientDMBCountAggregateOutputType | null
    _avg: ClientDMBAvgAggregateOutputType | null
    _sum: ClientDMBSumAggregateOutputType | null
    _min: ClientDMBMinAggregateOutputType | null
    _max: ClientDMBMaxAggregateOutputType | null
  }

  type GetClientDMBGroupByPayload<T extends ClientDMBGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientDMBGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientDMBGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientDMBGroupByOutputType[P]>
            : GetScalarType<T[P], ClientDMBGroupByOutputType[P]>
        }
      >
    >


  export type ClientDMBSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    accessType?: boolean
    status?: boolean
    subclientName?: boolean
    username?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientDMB"]>

  export type ClientDMBSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    accessType?: boolean
    status?: boolean
    subclientName?: boolean
    username?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientDMB"]>

  export type ClientDMBSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    accessType?: boolean
    status?: boolean
    subclientName?: boolean
    username?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientDMB"]>

  export type ClientDMBSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    accessType?: boolean
    status?: boolean
    subclientName?: boolean
    username?: boolean
  }

  export type ClientDMBOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "clientId" | "accessType" | "status" | "subclientName" | "username", ExtArgs["result"]["clientDMB"]>
  export type ClientDMBInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientDMBIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientDMBIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientDMBPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientDMB"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      clientId: number
      accessType: $Enums.AccessTypeDMB
      status: $Enums.DMBStatus
      subclientName: string | null
      username: string | null
    }, ExtArgs["result"]["clientDMB"]>
    composites: {}
  }

  type ClientDMBGetPayload<S extends boolean | null | undefined | ClientDMBDefaultArgs> = $Result.GetResult<Prisma.$ClientDMBPayload, S>

  type ClientDMBCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientDMBFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientDMBCountAggregateInputType | true
    }

  export interface ClientDMBDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientDMB'], meta: { name: 'ClientDMB' } }
    /**
     * Find zero or one ClientDMB that matches the filter.
     * @param {ClientDMBFindUniqueArgs} args - Arguments to find a ClientDMB
     * @example
     * // Get one ClientDMB
     * const clientDMB = await prisma.clientDMB.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientDMBFindUniqueArgs>(args: SelectSubset<T, ClientDMBFindUniqueArgs<ExtArgs>>): Prisma__ClientDMBClient<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientDMB that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientDMBFindUniqueOrThrowArgs} args - Arguments to find a ClientDMB
     * @example
     * // Get one ClientDMB
     * const clientDMB = await prisma.clientDMB.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientDMBFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientDMBFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientDMBClient<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientDMB that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDMBFindFirstArgs} args - Arguments to find a ClientDMB
     * @example
     * // Get one ClientDMB
     * const clientDMB = await prisma.clientDMB.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientDMBFindFirstArgs>(args?: SelectSubset<T, ClientDMBFindFirstArgs<ExtArgs>>): Prisma__ClientDMBClient<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientDMB that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDMBFindFirstOrThrowArgs} args - Arguments to find a ClientDMB
     * @example
     * // Get one ClientDMB
     * const clientDMB = await prisma.clientDMB.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientDMBFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientDMBFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientDMBClient<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientDMBS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDMBFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientDMBS
     * const clientDMBS = await prisma.clientDMB.findMany()
     * 
     * // Get first 10 ClientDMBS
     * const clientDMBS = await prisma.clientDMB.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientDMBWithIdOnly = await prisma.clientDMB.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientDMBFindManyArgs>(args?: SelectSubset<T, ClientDMBFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientDMB.
     * @param {ClientDMBCreateArgs} args - Arguments to create a ClientDMB.
     * @example
     * // Create one ClientDMB
     * const ClientDMB = await prisma.clientDMB.create({
     *   data: {
     *     // ... data to create a ClientDMB
     *   }
     * })
     * 
     */
    create<T extends ClientDMBCreateArgs>(args: SelectSubset<T, ClientDMBCreateArgs<ExtArgs>>): Prisma__ClientDMBClient<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientDMBS.
     * @param {ClientDMBCreateManyArgs} args - Arguments to create many ClientDMBS.
     * @example
     * // Create many ClientDMBS
     * const clientDMB = await prisma.clientDMB.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientDMBCreateManyArgs>(args?: SelectSubset<T, ClientDMBCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientDMBS and returns the data saved in the database.
     * @param {ClientDMBCreateManyAndReturnArgs} args - Arguments to create many ClientDMBS.
     * @example
     * // Create many ClientDMBS
     * const clientDMB = await prisma.clientDMB.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientDMBS and only return the `id`
     * const clientDMBWithIdOnly = await prisma.clientDMB.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientDMBCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientDMBCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientDMB.
     * @param {ClientDMBDeleteArgs} args - Arguments to delete one ClientDMB.
     * @example
     * // Delete one ClientDMB
     * const ClientDMB = await prisma.clientDMB.delete({
     *   where: {
     *     // ... filter to delete one ClientDMB
     *   }
     * })
     * 
     */
    delete<T extends ClientDMBDeleteArgs>(args: SelectSubset<T, ClientDMBDeleteArgs<ExtArgs>>): Prisma__ClientDMBClient<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientDMB.
     * @param {ClientDMBUpdateArgs} args - Arguments to update one ClientDMB.
     * @example
     * // Update one ClientDMB
     * const clientDMB = await prisma.clientDMB.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientDMBUpdateArgs>(args: SelectSubset<T, ClientDMBUpdateArgs<ExtArgs>>): Prisma__ClientDMBClient<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientDMBS.
     * @param {ClientDMBDeleteManyArgs} args - Arguments to filter ClientDMBS to delete.
     * @example
     * // Delete a few ClientDMBS
     * const { count } = await prisma.clientDMB.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDMBDeleteManyArgs>(args?: SelectSubset<T, ClientDMBDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientDMBS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDMBUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientDMBS
     * const clientDMB = await prisma.clientDMB.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientDMBUpdateManyArgs>(args: SelectSubset<T, ClientDMBUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientDMBS and returns the data updated in the database.
     * @param {ClientDMBUpdateManyAndReturnArgs} args - Arguments to update many ClientDMBS.
     * @example
     * // Update many ClientDMBS
     * const clientDMB = await prisma.clientDMB.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientDMBS and only return the `id`
     * const clientDMBWithIdOnly = await prisma.clientDMB.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientDMBUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientDMBUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientDMB.
     * @param {ClientDMBUpsertArgs} args - Arguments to update or create a ClientDMB.
     * @example
     * // Update or create a ClientDMB
     * const clientDMB = await prisma.clientDMB.upsert({
     *   create: {
     *     // ... data to create a ClientDMB
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientDMB we want to update
     *   }
     * })
     */
    upsert<T extends ClientDMBUpsertArgs>(args: SelectSubset<T, ClientDMBUpsertArgs<ExtArgs>>): Prisma__ClientDMBClient<$Result.GetResult<Prisma.$ClientDMBPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientDMBS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDMBCountArgs} args - Arguments to filter ClientDMBS to count.
     * @example
     * // Count the number of ClientDMBS
     * const count = await prisma.clientDMB.count({
     *   where: {
     *     // ... the filter for the ClientDMBS we want to count
     *   }
     * })
    **/
    count<T extends ClientDMBCountArgs>(
      args?: Subset<T, ClientDMBCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientDMBCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientDMB.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDMBAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientDMBAggregateArgs>(args: Subset<T, ClientDMBAggregateArgs>): Prisma.PrismaPromise<GetClientDMBAggregateType<T>>

    /**
     * Group by ClientDMB.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientDMBGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientDMBGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientDMBGroupByArgs['orderBy'] }
        : { orderBy?: ClientDMBGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientDMBGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientDMBGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientDMB model
   */
  readonly fields: ClientDMBFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientDMB.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientDMBClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientDMB model
   */
  interface ClientDMBFieldRefs {
    readonly id: FieldRef<"ClientDMB", 'Int'>
    readonly createdAt: FieldRef<"ClientDMB", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientDMB", 'DateTime'>
    readonly clientId: FieldRef<"ClientDMB", 'Int'>
    readonly accessType: FieldRef<"ClientDMB", 'AccessTypeDMB'>
    readonly status: FieldRef<"ClientDMB", 'DMBStatus'>
    readonly subclientName: FieldRef<"ClientDMB", 'String'>
    readonly username: FieldRef<"ClientDMB", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientDMB findUnique
   */
  export type ClientDMBFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
    /**
     * Filter, which ClientDMB to fetch.
     */
    where: ClientDMBWhereUniqueInput
  }

  /**
   * ClientDMB findUniqueOrThrow
   */
  export type ClientDMBFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
    /**
     * Filter, which ClientDMB to fetch.
     */
    where: ClientDMBWhereUniqueInput
  }

  /**
   * ClientDMB findFirst
   */
  export type ClientDMBFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
    /**
     * Filter, which ClientDMB to fetch.
     */
    where?: ClientDMBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDMBS to fetch.
     */
    orderBy?: ClientDMBOrderByWithRelationInput | ClientDMBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientDMBS.
     */
    cursor?: ClientDMBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDMBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDMBS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientDMBS.
     */
    distinct?: ClientDMBScalarFieldEnum | ClientDMBScalarFieldEnum[]
  }

  /**
   * ClientDMB findFirstOrThrow
   */
  export type ClientDMBFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
    /**
     * Filter, which ClientDMB to fetch.
     */
    where?: ClientDMBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDMBS to fetch.
     */
    orderBy?: ClientDMBOrderByWithRelationInput | ClientDMBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientDMBS.
     */
    cursor?: ClientDMBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDMBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDMBS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientDMBS.
     */
    distinct?: ClientDMBScalarFieldEnum | ClientDMBScalarFieldEnum[]
  }

  /**
   * ClientDMB findMany
   */
  export type ClientDMBFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
    /**
     * Filter, which ClientDMBS to fetch.
     */
    where?: ClientDMBWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientDMBS to fetch.
     */
    orderBy?: ClientDMBOrderByWithRelationInput | ClientDMBOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientDMBS.
     */
    cursor?: ClientDMBWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientDMBS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientDMBS.
     */
    skip?: number
    distinct?: ClientDMBScalarFieldEnum | ClientDMBScalarFieldEnum[]
  }

  /**
   * ClientDMB create
   */
  export type ClientDMBCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientDMB.
     */
    data: XOR<ClientDMBCreateInput, ClientDMBUncheckedCreateInput>
  }

  /**
   * ClientDMB createMany
   */
  export type ClientDMBCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientDMBS.
     */
    data: ClientDMBCreateManyInput | ClientDMBCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientDMB createManyAndReturn
   */
  export type ClientDMBCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * The data used to create many ClientDMBS.
     */
    data: ClientDMBCreateManyInput | ClientDMBCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientDMB update
   */
  export type ClientDMBUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientDMB.
     */
    data: XOR<ClientDMBUpdateInput, ClientDMBUncheckedUpdateInput>
    /**
     * Choose, which ClientDMB to update.
     */
    where: ClientDMBWhereUniqueInput
  }

  /**
   * ClientDMB updateMany
   */
  export type ClientDMBUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientDMBS.
     */
    data: XOR<ClientDMBUpdateManyMutationInput, ClientDMBUncheckedUpdateManyInput>
    /**
     * Filter which ClientDMBS to update
     */
    where?: ClientDMBWhereInput
    /**
     * Limit how many ClientDMBS to update.
     */
    limit?: number
  }

  /**
   * ClientDMB updateManyAndReturn
   */
  export type ClientDMBUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * The data used to update ClientDMBS.
     */
    data: XOR<ClientDMBUpdateManyMutationInput, ClientDMBUncheckedUpdateManyInput>
    /**
     * Filter which ClientDMBS to update
     */
    where?: ClientDMBWhereInput
    /**
     * Limit how many ClientDMBS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientDMB upsert
   */
  export type ClientDMBUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientDMB to update in case it exists.
     */
    where: ClientDMBWhereUniqueInput
    /**
     * In case the ClientDMB found by the `where` argument doesn't exist, create a new ClientDMB with this data.
     */
    create: XOR<ClientDMBCreateInput, ClientDMBUncheckedCreateInput>
    /**
     * In case the ClientDMB was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientDMBUpdateInput, ClientDMBUncheckedUpdateInput>
  }

  /**
   * ClientDMB delete
   */
  export type ClientDMBDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
    /**
     * Filter which ClientDMB to delete.
     */
    where: ClientDMBWhereUniqueInput
  }

  /**
   * ClientDMB deleteMany
   */
  export type ClientDMBDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientDMBS to delete
     */
    where?: ClientDMBWhereInput
    /**
     * Limit how many ClientDMBS to delete.
     */
    limit?: number
  }

  /**
   * ClientDMB without action
   */
  export type ClientDMBDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientDMB
     */
    select?: ClientDMBSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientDMB
     */
    omit?: ClientDMBOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientDMBInclude<ExtArgs> | null
  }


  /**
   * Model ClientPaymentInformation
   */

  export type AggregateClientPaymentInformation = {
    _count: ClientPaymentInformationCountAggregateOutputType | null
    _avg: ClientPaymentInformationAvgAggregateOutputType | null
    _sum: ClientPaymentInformationSumAggregateOutputType | null
    _min: ClientPaymentInformationMinAggregateOutputType | null
    _max: ClientPaymentInformationMaxAggregateOutputType | null
  }

  export type ClientPaymentInformationAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type ClientPaymentInformationSumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type ClientPaymentInformationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: number | null
    paymentMethod: $Enums.PaymentMethod | null
  }

  export type ClientPaymentInformationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: number | null
    paymentMethod: $Enums.PaymentMethod | null
  }

  export type ClientPaymentInformationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    clientId: number
    paymentMethod: number
    data: number
    _all: number
  }


  export type ClientPaymentInformationAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type ClientPaymentInformationSumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type ClientPaymentInformationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    paymentMethod?: true
  }

  export type ClientPaymentInformationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    paymentMethod?: true
  }

  export type ClientPaymentInformationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    paymentMethod?: true
    data?: true
    _all?: true
  }

  export type ClientPaymentInformationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPaymentInformation to aggregate.
     */
    where?: ClientPaymentInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPaymentInformations to fetch.
     */
    orderBy?: ClientPaymentInformationOrderByWithRelationInput | ClientPaymentInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientPaymentInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPaymentInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPaymentInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientPaymentInformations
    **/
    _count?: true | ClientPaymentInformationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientPaymentInformationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientPaymentInformationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientPaymentInformationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientPaymentInformationMaxAggregateInputType
  }

  export type GetClientPaymentInformationAggregateType<T extends ClientPaymentInformationAggregateArgs> = {
        [P in keyof T & keyof AggregateClientPaymentInformation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientPaymentInformation[P]>
      : GetScalarType<T[P], AggregateClientPaymentInformation[P]>
  }




  export type ClientPaymentInformationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPaymentInformationWhereInput
    orderBy?: ClientPaymentInformationOrderByWithAggregationInput | ClientPaymentInformationOrderByWithAggregationInput[]
    by: ClientPaymentInformationScalarFieldEnum[] | ClientPaymentInformationScalarFieldEnum
    having?: ClientPaymentInformationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientPaymentInformationCountAggregateInputType | true
    _avg?: ClientPaymentInformationAvgAggregateInputType
    _sum?: ClientPaymentInformationSumAggregateInputType
    _min?: ClientPaymentInformationMinAggregateInputType
    _max?: ClientPaymentInformationMaxAggregateInputType
  }

  export type ClientPaymentInformationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    clientId: number
    paymentMethod: $Enums.PaymentMethod | null
    data: JsonValue | null
    _count: ClientPaymentInformationCountAggregateOutputType | null
    _avg: ClientPaymentInformationAvgAggregateOutputType | null
    _sum: ClientPaymentInformationSumAggregateOutputType | null
    _min: ClientPaymentInformationMinAggregateOutputType | null
    _max: ClientPaymentInformationMaxAggregateOutputType | null
  }

  type GetClientPaymentInformationGroupByPayload<T extends ClientPaymentInformationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientPaymentInformationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientPaymentInformationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientPaymentInformationGroupByOutputType[P]>
            : GetScalarType<T[P], ClientPaymentInformationGroupByOutputType[P]>
        }
      >
    >


  export type ClientPaymentInformationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    paymentMethod?: boolean
    data?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientPaymentInformation"]>

  export type ClientPaymentInformationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    paymentMethod?: boolean
    data?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientPaymentInformation"]>

  export type ClientPaymentInformationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    paymentMethod?: boolean
    data?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientPaymentInformation"]>

  export type ClientPaymentInformationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    paymentMethod?: boolean
    data?: boolean
  }

  export type ClientPaymentInformationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "clientId" | "paymentMethod" | "data", ExtArgs["result"]["clientPaymentInformation"]>
  export type ClientPaymentInformationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientPaymentInformationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientPaymentInformationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientPaymentInformationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientPaymentInformation"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      clientId: number
      paymentMethod: $Enums.PaymentMethod | null
      data: Prisma.JsonValue | null
    }, ExtArgs["result"]["clientPaymentInformation"]>
    composites: {}
  }

  type ClientPaymentInformationGetPayload<S extends boolean | null | undefined | ClientPaymentInformationDefaultArgs> = $Result.GetResult<Prisma.$ClientPaymentInformationPayload, S>

  type ClientPaymentInformationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientPaymentInformationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientPaymentInformationCountAggregateInputType | true
    }

  export interface ClientPaymentInformationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientPaymentInformation'], meta: { name: 'ClientPaymentInformation' } }
    /**
     * Find zero or one ClientPaymentInformation that matches the filter.
     * @param {ClientPaymentInformationFindUniqueArgs} args - Arguments to find a ClientPaymentInformation
     * @example
     * // Get one ClientPaymentInformation
     * const clientPaymentInformation = await prisma.clientPaymentInformation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientPaymentInformationFindUniqueArgs>(args: SelectSubset<T, ClientPaymentInformationFindUniqueArgs<ExtArgs>>): Prisma__ClientPaymentInformationClient<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientPaymentInformation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientPaymentInformationFindUniqueOrThrowArgs} args - Arguments to find a ClientPaymentInformation
     * @example
     * // Get one ClientPaymentInformation
     * const clientPaymentInformation = await prisma.clientPaymentInformation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientPaymentInformationFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientPaymentInformationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientPaymentInformationClient<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientPaymentInformation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPaymentInformationFindFirstArgs} args - Arguments to find a ClientPaymentInformation
     * @example
     * // Get one ClientPaymentInformation
     * const clientPaymentInformation = await prisma.clientPaymentInformation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientPaymentInformationFindFirstArgs>(args?: SelectSubset<T, ClientPaymentInformationFindFirstArgs<ExtArgs>>): Prisma__ClientPaymentInformationClient<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientPaymentInformation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPaymentInformationFindFirstOrThrowArgs} args - Arguments to find a ClientPaymentInformation
     * @example
     * // Get one ClientPaymentInformation
     * const clientPaymentInformation = await prisma.clientPaymentInformation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientPaymentInformationFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientPaymentInformationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientPaymentInformationClient<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientPaymentInformations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPaymentInformationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientPaymentInformations
     * const clientPaymentInformations = await prisma.clientPaymentInformation.findMany()
     * 
     * // Get first 10 ClientPaymentInformations
     * const clientPaymentInformations = await prisma.clientPaymentInformation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientPaymentInformationWithIdOnly = await prisma.clientPaymentInformation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientPaymentInformationFindManyArgs>(args?: SelectSubset<T, ClientPaymentInformationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientPaymentInformation.
     * @param {ClientPaymentInformationCreateArgs} args - Arguments to create a ClientPaymentInformation.
     * @example
     * // Create one ClientPaymentInformation
     * const ClientPaymentInformation = await prisma.clientPaymentInformation.create({
     *   data: {
     *     // ... data to create a ClientPaymentInformation
     *   }
     * })
     * 
     */
    create<T extends ClientPaymentInformationCreateArgs>(args: SelectSubset<T, ClientPaymentInformationCreateArgs<ExtArgs>>): Prisma__ClientPaymentInformationClient<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientPaymentInformations.
     * @param {ClientPaymentInformationCreateManyArgs} args - Arguments to create many ClientPaymentInformations.
     * @example
     * // Create many ClientPaymentInformations
     * const clientPaymentInformation = await prisma.clientPaymentInformation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientPaymentInformationCreateManyArgs>(args?: SelectSubset<T, ClientPaymentInformationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientPaymentInformations and returns the data saved in the database.
     * @param {ClientPaymentInformationCreateManyAndReturnArgs} args - Arguments to create many ClientPaymentInformations.
     * @example
     * // Create many ClientPaymentInformations
     * const clientPaymentInformation = await prisma.clientPaymentInformation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientPaymentInformations and only return the `id`
     * const clientPaymentInformationWithIdOnly = await prisma.clientPaymentInformation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientPaymentInformationCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientPaymentInformationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientPaymentInformation.
     * @param {ClientPaymentInformationDeleteArgs} args - Arguments to delete one ClientPaymentInformation.
     * @example
     * // Delete one ClientPaymentInformation
     * const ClientPaymentInformation = await prisma.clientPaymentInformation.delete({
     *   where: {
     *     // ... filter to delete one ClientPaymentInformation
     *   }
     * })
     * 
     */
    delete<T extends ClientPaymentInformationDeleteArgs>(args: SelectSubset<T, ClientPaymentInformationDeleteArgs<ExtArgs>>): Prisma__ClientPaymentInformationClient<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientPaymentInformation.
     * @param {ClientPaymentInformationUpdateArgs} args - Arguments to update one ClientPaymentInformation.
     * @example
     * // Update one ClientPaymentInformation
     * const clientPaymentInformation = await prisma.clientPaymentInformation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientPaymentInformationUpdateArgs>(args: SelectSubset<T, ClientPaymentInformationUpdateArgs<ExtArgs>>): Prisma__ClientPaymentInformationClient<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientPaymentInformations.
     * @param {ClientPaymentInformationDeleteManyArgs} args - Arguments to filter ClientPaymentInformations to delete.
     * @example
     * // Delete a few ClientPaymentInformations
     * const { count } = await prisma.clientPaymentInformation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientPaymentInformationDeleteManyArgs>(args?: SelectSubset<T, ClientPaymentInformationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPaymentInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPaymentInformationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientPaymentInformations
     * const clientPaymentInformation = await prisma.clientPaymentInformation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientPaymentInformationUpdateManyArgs>(args: SelectSubset<T, ClientPaymentInformationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPaymentInformations and returns the data updated in the database.
     * @param {ClientPaymentInformationUpdateManyAndReturnArgs} args - Arguments to update many ClientPaymentInformations.
     * @example
     * // Update many ClientPaymentInformations
     * const clientPaymentInformation = await prisma.clientPaymentInformation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientPaymentInformations and only return the `id`
     * const clientPaymentInformationWithIdOnly = await prisma.clientPaymentInformation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientPaymentInformationUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientPaymentInformationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientPaymentInformation.
     * @param {ClientPaymentInformationUpsertArgs} args - Arguments to update or create a ClientPaymentInformation.
     * @example
     * // Update or create a ClientPaymentInformation
     * const clientPaymentInformation = await prisma.clientPaymentInformation.upsert({
     *   create: {
     *     // ... data to create a ClientPaymentInformation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientPaymentInformation we want to update
     *   }
     * })
     */
    upsert<T extends ClientPaymentInformationUpsertArgs>(args: SelectSubset<T, ClientPaymentInformationUpsertArgs<ExtArgs>>): Prisma__ClientPaymentInformationClient<$Result.GetResult<Prisma.$ClientPaymentInformationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientPaymentInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPaymentInformationCountArgs} args - Arguments to filter ClientPaymentInformations to count.
     * @example
     * // Count the number of ClientPaymentInformations
     * const count = await prisma.clientPaymentInformation.count({
     *   where: {
     *     // ... the filter for the ClientPaymentInformations we want to count
     *   }
     * })
    **/
    count<T extends ClientPaymentInformationCountArgs>(
      args?: Subset<T, ClientPaymentInformationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientPaymentInformationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientPaymentInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPaymentInformationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientPaymentInformationAggregateArgs>(args: Subset<T, ClientPaymentInformationAggregateArgs>): Prisma.PrismaPromise<GetClientPaymentInformationAggregateType<T>>

    /**
     * Group by ClientPaymentInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPaymentInformationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientPaymentInformationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientPaymentInformationGroupByArgs['orderBy'] }
        : { orderBy?: ClientPaymentInformationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientPaymentInformationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientPaymentInformationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientPaymentInformation model
   */
  readonly fields: ClientPaymentInformationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientPaymentInformation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientPaymentInformationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientPaymentInformation model
   */
  interface ClientPaymentInformationFieldRefs {
    readonly id: FieldRef<"ClientPaymentInformation", 'Int'>
    readonly createdAt: FieldRef<"ClientPaymentInformation", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientPaymentInformation", 'DateTime'>
    readonly clientId: FieldRef<"ClientPaymentInformation", 'Int'>
    readonly paymentMethod: FieldRef<"ClientPaymentInformation", 'PaymentMethod'>
    readonly data: FieldRef<"ClientPaymentInformation", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ClientPaymentInformation findUnique
   */
  export type ClientPaymentInformationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
    /**
     * Filter, which ClientPaymentInformation to fetch.
     */
    where: ClientPaymentInformationWhereUniqueInput
  }

  /**
   * ClientPaymentInformation findUniqueOrThrow
   */
  export type ClientPaymentInformationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
    /**
     * Filter, which ClientPaymentInformation to fetch.
     */
    where: ClientPaymentInformationWhereUniqueInput
  }

  /**
   * ClientPaymentInformation findFirst
   */
  export type ClientPaymentInformationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
    /**
     * Filter, which ClientPaymentInformation to fetch.
     */
    where?: ClientPaymentInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPaymentInformations to fetch.
     */
    orderBy?: ClientPaymentInformationOrderByWithRelationInput | ClientPaymentInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPaymentInformations.
     */
    cursor?: ClientPaymentInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPaymentInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPaymentInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPaymentInformations.
     */
    distinct?: ClientPaymentInformationScalarFieldEnum | ClientPaymentInformationScalarFieldEnum[]
  }

  /**
   * ClientPaymentInformation findFirstOrThrow
   */
  export type ClientPaymentInformationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
    /**
     * Filter, which ClientPaymentInformation to fetch.
     */
    where?: ClientPaymentInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPaymentInformations to fetch.
     */
    orderBy?: ClientPaymentInformationOrderByWithRelationInput | ClientPaymentInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPaymentInformations.
     */
    cursor?: ClientPaymentInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPaymentInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPaymentInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPaymentInformations.
     */
    distinct?: ClientPaymentInformationScalarFieldEnum | ClientPaymentInformationScalarFieldEnum[]
  }

  /**
   * ClientPaymentInformation findMany
   */
  export type ClientPaymentInformationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
    /**
     * Filter, which ClientPaymentInformations to fetch.
     */
    where?: ClientPaymentInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPaymentInformations to fetch.
     */
    orderBy?: ClientPaymentInformationOrderByWithRelationInput | ClientPaymentInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientPaymentInformations.
     */
    cursor?: ClientPaymentInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPaymentInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPaymentInformations.
     */
    skip?: number
    distinct?: ClientPaymentInformationScalarFieldEnum | ClientPaymentInformationScalarFieldEnum[]
  }

  /**
   * ClientPaymentInformation create
   */
  export type ClientPaymentInformationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientPaymentInformation.
     */
    data: XOR<ClientPaymentInformationCreateInput, ClientPaymentInformationUncheckedCreateInput>
  }

  /**
   * ClientPaymentInformation createMany
   */
  export type ClientPaymentInformationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientPaymentInformations.
     */
    data: ClientPaymentInformationCreateManyInput | ClientPaymentInformationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientPaymentInformation createManyAndReturn
   */
  export type ClientPaymentInformationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * The data used to create many ClientPaymentInformations.
     */
    data: ClientPaymentInformationCreateManyInput | ClientPaymentInformationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientPaymentInformation update
   */
  export type ClientPaymentInformationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientPaymentInformation.
     */
    data: XOR<ClientPaymentInformationUpdateInput, ClientPaymentInformationUncheckedUpdateInput>
    /**
     * Choose, which ClientPaymentInformation to update.
     */
    where: ClientPaymentInformationWhereUniqueInput
  }

  /**
   * ClientPaymentInformation updateMany
   */
  export type ClientPaymentInformationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientPaymentInformations.
     */
    data: XOR<ClientPaymentInformationUpdateManyMutationInput, ClientPaymentInformationUncheckedUpdateManyInput>
    /**
     * Filter which ClientPaymentInformations to update
     */
    where?: ClientPaymentInformationWhereInput
    /**
     * Limit how many ClientPaymentInformations to update.
     */
    limit?: number
  }

  /**
   * ClientPaymentInformation updateManyAndReturn
   */
  export type ClientPaymentInformationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * The data used to update ClientPaymentInformations.
     */
    data: XOR<ClientPaymentInformationUpdateManyMutationInput, ClientPaymentInformationUncheckedUpdateManyInput>
    /**
     * Filter which ClientPaymentInformations to update
     */
    where?: ClientPaymentInformationWhereInput
    /**
     * Limit how many ClientPaymentInformations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientPaymentInformation upsert
   */
  export type ClientPaymentInformationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientPaymentInformation to update in case it exists.
     */
    where: ClientPaymentInformationWhereUniqueInput
    /**
     * In case the ClientPaymentInformation found by the `where` argument doesn't exist, create a new ClientPaymentInformation with this data.
     */
    create: XOR<ClientPaymentInformationCreateInput, ClientPaymentInformationUncheckedCreateInput>
    /**
     * In case the ClientPaymentInformation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientPaymentInformationUpdateInput, ClientPaymentInformationUncheckedUpdateInput>
  }

  /**
   * ClientPaymentInformation delete
   */
  export type ClientPaymentInformationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
    /**
     * Filter which ClientPaymentInformation to delete.
     */
    where: ClientPaymentInformationWhereUniqueInput
  }

  /**
   * ClientPaymentInformation deleteMany
   */
  export type ClientPaymentInformationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPaymentInformations to delete
     */
    where?: ClientPaymentInformationWhereInput
    /**
     * Limit how many ClientPaymentInformations to delete.
     */
    limit?: number
  }

  /**
   * ClientPaymentInformation without action
   */
  export type ClientPaymentInformationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPaymentInformation
     */
    select?: ClientPaymentInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPaymentInformation
     */
    omit?: ClientPaymentInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPaymentInformationInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    ppd: number | null
  }

  export type ContractSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    ppd: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: number | null
    uuid: string | null
    type: $Enums.ContractType | null
    ppd: number | null
    status: $Enums.ContractStatus | null
    docUrl: string | null
    startDate: Date | null
    endDate: Date | null
    signed: boolean | null
    signedAt: Date | null
    signedBy: string | null
  }

  export type ContractMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: number | null
    uuid: string | null
    type: $Enums.ContractType | null
    ppd: number | null
    status: $Enums.ContractStatus | null
    docUrl: string | null
    startDate: Date | null
    endDate: Date | null
    signed: boolean | null
    signedAt: Date | null
    signedBy: string | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    clientId: number
    uuid: number
    type: number
    ppd: number
    status: number
    docUrl: number
    startDate: number
    endDate: number
    signed: number
    signedAt: number
    signedBy: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    id?: true
    clientId?: true
    ppd?: true
  }

  export type ContractSumAggregateInputType = {
    id?: true
    clientId?: true
    ppd?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    uuid?: true
    type?: true
    ppd?: true
    status?: true
    docUrl?: true
    startDate?: true
    endDate?: true
    signed?: true
    signedAt?: true
    signedBy?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    uuid?: true
    type?: true
    ppd?: true
    status?: true
    docUrl?: true
    startDate?: true
    endDate?: true
    signed?: true
    signedAt?: true
    signedBy?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    uuid?: true
    type?: true
    ppd?: true
    status?: true
    docUrl?: true
    startDate?: true
    endDate?: true
    signed?: true
    signedAt?: true
    signedBy?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    clientId: number | null
    uuid: string
    type: $Enums.ContractType
    ppd: number | null
    status: $Enums.ContractStatus
    docUrl: string | null
    startDate: Date
    endDate: Date | null
    signed: boolean
    signedAt: Date | null
    signedBy: string | null
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    uuid?: boolean
    type?: boolean
    ppd?: boolean
    status?: boolean
    docUrl?: boolean
    startDate?: boolean
    endDate?: boolean
    signed?: boolean
    signedAt?: boolean
    signedBy?: boolean
    client?: boolean | Contract$clientArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    uuid?: boolean
    type?: boolean
    ppd?: boolean
    status?: boolean
    docUrl?: boolean
    startDate?: boolean
    endDate?: boolean
    signed?: boolean
    signedAt?: boolean
    signedBy?: boolean
    client?: boolean | Contract$clientArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    uuid?: boolean
    type?: boolean
    ppd?: boolean
    status?: boolean
    docUrl?: boolean
    startDate?: boolean
    endDate?: boolean
    signed?: boolean
    signedAt?: boolean
    signedBy?: boolean
    client?: boolean | Contract$clientArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    uuid?: boolean
    type?: boolean
    ppd?: boolean
    status?: boolean
    docUrl?: boolean
    startDate?: boolean
    endDate?: boolean
    signed?: boolean
    signedAt?: boolean
    signedBy?: boolean
  }

  export type ContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "clientId" | "uuid" | "type" | "ppd" | "status" | "docUrl" | "startDate" | "endDate" | "signed" | "signedAt" | "signedBy", ExtArgs["result"]["contract"]>
  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Contract$clientArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Contract$clientArgs<ExtArgs>
  }
  export type ContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Contract$clientArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      clientId: number | null
      uuid: string
      type: $Enums.ContractType
      ppd: number | null
      status: $Enums.ContractStatus
      docUrl: string | null
      startDate: Date
      endDate: Date | null
      signed: boolean
      signedAt: Date | null
      signedBy: string | null
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts and returns the data updated in the database.
     * @param {ContractUpdateManyAndReturnArgs} args - Arguments to update many Contracts.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Contract$clientArgs<ExtArgs> = {}>(args?: Subset<T, Contract$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'Int'>
    readonly createdAt: FieldRef<"Contract", 'DateTime'>
    readonly updatedAt: FieldRef<"Contract", 'DateTime'>
    readonly clientId: FieldRef<"Contract", 'Int'>
    readonly uuid: FieldRef<"Contract", 'String'>
    readonly type: FieldRef<"Contract", 'ContractType'>
    readonly ppd: FieldRef<"Contract", 'Float'>
    readonly status: FieldRef<"Contract", 'ContractStatus'>
    readonly docUrl: FieldRef<"Contract", 'String'>
    readonly startDate: FieldRef<"Contract", 'DateTime'>
    readonly endDate: FieldRef<"Contract", 'DateTime'>
    readonly signed: FieldRef<"Contract", 'Boolean'>
    readonly signedAt: FieldRef<"Contract", 'DateTime'>
    readonly signedBy: FieldRef<"Contract", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data?: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
  }

  /**
   * Contract updateManyAndReturn
   */
  export type ContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to delete.
     */
    limit?: number
  }

  /**
   * Contract.client
   */
  export type Contract$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model Balance
   */

  export type AggregateBalance = {
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  export type BalanceAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    amount: Decimal | null
    amountRetain: Decimal | null
    amountTerminated: Decimal | null
  }

  export type BalanceSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    amount: Decimal | null
    amountRetain: Decimal | null
    amountTerminated: Decimal | null
  }

  export type BalanceMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    currency: $Enums.Currency | null
    amount: Decimal | null
    amountRetain: Decimal | null
    amountTerminated: Decimal | null
  }

  export type BalanceMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    currency: $Enums.Currency | null
    amount: Decimal | null
    amountRetain: Decimal | null
    amountTerminated: Decimal | null
  }

  export type BalanceCountAggregateOutputType = {
    id: number
    clientId: number
    currency: number
    amount: number
    amountRetain: number
    amountTerminated: number
    _all: number
  }


  export type BalanceAvgAggregateInputType = {
    id?: true
    clientId?: true
    amount?: true
    amountRetain?: true
    amountTerminated?: true
  }

  export type BalanceSumAggregateInputType = {
    id?: true
    clientId?: true
    amount?: true
    amountRetain?: true
    amountTerminated?: true
  }

  export type BalanceMinAggregateInputType = {
    id?: true
    clientId?: true
    currency?: true
    amount?: true
    amountRetain?: true
    amountTerminated?: true
  }

  export type BalanceMaxAggregateInputType = {
    id?: true
    clientId?: true
    currency?: true
    amount?: true
    amountRetain?: true
    amountTerminated?: true
  }

  export type BalanceCountAggregateInputType = {
    id?: true
    clientId?: true
    currency?: true
    amount?: true
    amountRetain?: true
    amountTerminated?: true
    _all?: true
  }

  export type BalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balance to aggregate.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Balances
    **/
    _count?: true | BalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceMaxAggregateInputType
  }

  export type GetBalanceAggregateType<T extends BalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalance[P]>
      : GetScalarType<T[P], AggregateBalance[P]>
  }




  export type BalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithAggregationInput | BalanceOrderByWithAggregationInput[]
    by: BalanceScalarFieldEnum[] | BalanceScalarFieldEnum
    having?: BalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceCountAggregateInputType | true
    _avg?: BalanceAvgAggregateInputType
    _sum?: BalanceSumAggregateInputType
    _min?: BalanceMinAggregateInputType
    _max?: BalanceMaxAggregateInputType
  }

  export type BalanceGroupByOutputType = {
    id: number
    clientId: number
    currency: $Enums.Currency
    amount: Decimal
    amountRetain: Decimal
    amountTerminated: Decimal
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  type GetBalanceGroupByPayload<T extends BalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalanceGroupByOutputType[P]>
            : GetScalarType<T[P], BalanceGroupByOutputType[P]>
        }
      >
    >


  export type BalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    currency?: boolean
    amount?: boolean
    amountRetain?: boolean
    amountTerminated?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    transactions?: boolean | Balance$transactionsArgs<ExtArgs>
    _count?: boolean | BalanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    currency?: boolean
    amount?: boolean
    amountRetain?: boolean
    amountTerminated?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    currency?: boolean
    amount?: boolean
    amountRetain?: boolean
    amountTerminated?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectScalar = {
    id?: boolean
    clientId?: boolean
    currency?: boolean
    amount?: boolean
    amountRetain?: boolean
    amountTerminated?: boolean
  }

  export type BalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "currency" | "amount" | "amountRetain" | "amountTerminated", ExtArgs["result"]["balance"]>
  export type BalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    transactions?: boolean | Balance$transactionsArgs<ExtArgs>
    _count?: boolean | BalanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type BalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $BalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Balance"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clientId: number
      currency: $Enums.Currency
      amount: Prisma.Decimal
      amountRetain: Prisma.Decimal
      amountTerminated: Prisma.Decimal
    }, ExtArgs["result"]["balance"]>
    composites: {}
  }

  type BalanceGetPayload<S extends boolean | null | undefined | BalanceDefaultArgs> = $Result.GetResult<Prisma.$BalancePayload, S>

  type BalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BalanceCountAggregateInputType | true
    }

  export interface BalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Balance'], meta: { name: 'Balance' } }
    /**
     * Find zero or one Balance that matches the filter.
     * @param {BalanceFindUniqueArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalanceFindUniqueArgs>(args: SelectSubset<T, BalanceFindUniqueArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Balance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BalanceFindUniqueOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, BalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalanceFindFirstArgs>(args?: SelectSubset<T, BalanceFindFirstArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, BalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balances
     * const balances = await prisma.balance.findMany()
     * 
     * // Get first 10 Balances
     * const balances = await prisma.balance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceWithIdOnly = await prisma.balance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalanceFindManyArgs>(args?: SelectSubset<T, BalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Balance.
     * @param {BalanceCreateArgs} args - Arguments to create a Balance.
     * @example
     * // Create one Balance
     * const Balance = await prisma.balance.create({
     *   data: {
     *     // ... data to create a Balance
     *   }
     * })
     * 
     */
    create<T extends BalanceCreateArgs>(args: SelectSubset<T, BalanceCreateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Balances.
     * @param {BalanceCreateManyArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalanceCreateManyArgs>(args?: SelectSubset<T, BalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Balances and returns the data saved in the database.
     * @param {BalanceCreateManyAndReturnArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Balances and only return the `id`
     * const balanceWithIdOnly = await prisma.balance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, BalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Balance.
     * @param {BalanceDeleteArgs} args - Arguments to delete one Balance.
     * @example
     * // Delete one Balance
     * const Balance = await prisma.balance.delete({
     *   where: {
     *     // ... filter to delete one Balance
     *   }
     * })
     * 
     */
    delete<T extends BalanceDeleteArgs>(args: SelectSubset<T, BalanceDeleteArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Balance.
     * @param {BalanceUpdateArgs} args - Arguments to update one Balance.
     * @example
     * // Update one Balance
     * const balance = await prisma.balance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalanceUpdateArgs>(args: SelectSubset<T, BalanceUpdateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Balances.
     * @param {BalanceDeleteManyArgs} args - Arguments to filter Balances to delete.
     * @example
     * // Delete a few Balances
     * const { count } = await prisma.balance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalanceDeleteManyArgs>(args?: SelectSubset<T, BalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalanceUpdateManyArgs>(args: SelectSubset<T, BalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances and returns the data updated in the database.
     * @param {BalanceUpdateManyAndReturnArgs} args - Arguments to update many Balances.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Balances and only return the `id`
     * const balanceWithIdOnly = await prisma.balance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, BalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Balance.
     * @param {BalanceUpsertArgs} args - Arguments to update or create a Balance.
     * @example
     * // Update or create a Balance
     * const balance = await prisma.balance.upsert({
     *   create: {
     *     // ... data to create a Balance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balance we want to update
     *   }
     * })
     */
    upsert<T extends BalanceUpsertArgs>(args: SelectSubset<T, BalanceUpsertArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceCountArgs} args - Arguments to filter Balances to count.
     * @example
     * // Count the number of Balances
     * const count = await prisma.balance.count({
     *   where: {
     *     // ... the filter for the Balances we want to count
     *   }
     * })
    **/
    count<T extends BalanceCountArgs>(
      args?: Subset<T, BalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceAggregateArgs>(args: Subset<T, BalanceAggregateArgs>): Prisma.PrismaPromise<GetBalanceAggregateType<T>>

    /**
     * Group by Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceGroupByArgs['orderBy'] }
        : { orderBy?: BalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Balance model
   */
  readonly fields: BalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Balance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Balance$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Balance$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Balance model
   */
  interface BalanceFieldRefs {
    readonly id: FieldRef<"Balance", 'Int'>
    readonly clientId: FieldRef<"Balance", 'Int'>
    readonly currency: FieldRef<"Balance", 'Currency'>
    readonly amount: FieldRef<"Balance", 'Decimal'>
    readonly amountRetain: FieldRef<"Balance", 'Decimal'>
    readonly amountTerminated: FieldRef<"Balance", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Balance findUnique
   */
  export type BalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findUniqueOrThrow
   */
  export type BalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findFirst
   */
  export type BalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findFirstOrThrow
   */
  export type BalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findMany
   */
  export type BalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance create
   */
  export type BalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Balance.
     */
    data: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
  }

  /**
   * Balance createMany
   */
  export type BalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Balance createManyAndReturn
   */
  export type BalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Balance update
   */
  export type BalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Balance.
     */
    data: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
    /**
     * Choose, which Balance to update.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance updateMany
   */
  export type BalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Balances.
     */
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to update.
     */
    limit?: number
  }

  /**
   * Balance updateManyAndReturn
   */
  export type BalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * The data used to update Balances.
     */
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Balance upsert
   */
  export type BalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Balance to update in case it exists.
     */
    where: BalanceWhereUniqueInput
    /**
     * In case the Balance found by the `where` argument doesn't exist, create a new Balance with this data.
     */
    create: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
    /**
     * In case the Balance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
  }

  /**
   * Balance delete
   */
  export type BalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter which Balance to delete.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance deleteMany
   */
  export type BalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balances to delete
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to delete.
     */
    limit?: number
  }

  /**
   * Balance.transactions
   */
  export type Balance$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Balance without action
   */
  export type BalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    balanceAmount: Decimal | null
    balanceId: number | null
    baseReportId: number | null
    userReportId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
    balanceAmount: Decimal | null
    balanceId: number | null
    baseReportId: number | null
    userReportId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    type: $Enums.TransactionType | null
    description: string | null
    amount: Decimal | null
    balanceAmount: Decimal | null
    reversed: boolean | null
    distributor: $Enums.Distributor | null
    balanceId: number | null
    baseReportId: number | null
    userReportId: number | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    type: $Enums.TransactionType | null
    description: string | null
    amount: Decimal | null
    balanceAmount: Decimal | null
    reversed: boolean | null
    distributor: $Enums.Distributor | null
    balanceId: number | null
    baseReportId: number | null
    userReportId: number | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    type: number
    description: number
    amount: number
    balanceAmount: number
    reversed: number
    distributor: number
    balanceId: number
    baseReportId: number
    userReportId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    amount?: true
    balanceAmount?: true
    balanceId?: true
    baseReportId?: true
    userReportId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    amount?: true
    balanceAmount?: true
    balanceId?: true
    baseReportId?: true
    userReportId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    description?: true
    amount?: true
    balanceAmount?: true
    reversed?: true
    distributor?: true
    balanceId?: true
    baseReportId?: true
    userReportId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    description?: true
    amount?: true
    balanceAmount?: true
    reversed?: true
    distributor?: true
    balanceId?: true
    baseReportId?: true
    userReportId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    description?: true
    amount?: true
    balanceAmount?: true
    reversed?: true
    distributor?: true
    balanceId?: true
    baseReportId?: true
    userReportId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    type: $Enums.TransactionType
    description: string
    amount: Decimal
    balanceAmount: Decimal
    reversed: boolean
    distributor: $Enums.Distributor | null
    balanceId: number
    baseReportId: number | null
    userReportId: number | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    balanceAmount?: boolean
    reversed?: boolean
    distributor?: boolean
    balanceId?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    balance?: boolean | BalanceDefaultArgs<ExtArgs>
    baseReport?: boolean | Transaction$baseReportArgs<ExtArgs>
    userReport?: boolean | Transaction$userReportArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    balanceAmount?: boolean
    reversed?: boolean
    distributor?: boolean
    balanceId?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    balance?: boolean | BalanceDefaultArgs<ExtArgs>
    baseReport?: boolean | Transaction$baseReportArgs<ExtArgs>
    userReport?: boolean | Transaction$userReportArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    balanceAmount?: boolean
    reversed?: boolean
    distributor?: boolean
    balanceId?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    balance?: boolean | BalanceDefaultArgs<ExtArgs>
    baseReport?: boolean | Transaction$baseReportArgs<ExtArgs>
    userReport?: boolean | Transaction$userReportArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    balanceAmount?: boolean
    reversed?: boolean
    distributor?: boolean
    balanceId?: boolean
    baseReportId?: boolean
    userReportId?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "type" | "description" | "amount" | "balanceAmount" | "reversed" | "distributor" | "balanceId" | "baseReportId" | "userReportId", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balance?: boolean | BalanceDefaultArgs<ExtArgs>
    baseReport?: boolean | Transaction$baseReportArgs<ExtArgs>
    userReport?: boolean | Transaction$userReportArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balance?: boolean | BalanceDefaultArgs<ExtArgs>
    baseReport?: boolean | Transaction$baseReportArgs<ExtArgs>
    userReport?: boolean | Transaction$userReportArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balance?: boolean | BalanceDefaultArgs<ExtArgs>
    baseReport?: boolean | Transaction$baseReportArgs<ExtArgs>
    userReport?: boolean | Transaction$userReportArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      balance: Prisma.$BalancePayload<ExtArgs>
      baseReport: Prisma.$BaseRoyaltyReportPayload<ExtArgs> | null
      userReport: Prisma.$UserRoyaltyReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      type: $Enums.TransactionType
      description: string
      amount: Prisma.Decimal
      balanceAmount: Prisma.Decimal
      reversed: boolean
      distributor: $Enums.Distributor | null
      balanceId: number
      baseReportId: number | null
      userReportId: number | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    balance<T extends BalanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BalanceDefaultArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    baseReport<T extends Transaction$baseReportArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$baseReportArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userReport<T extends Transaction$userReportArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$userReportArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly balanceAmount: FieldRef<"Transaction", 'Decimal'>
    readonly reversed: FieldRef<"Transaction", 'Boolean'>
    readonly distributor: FieldRef<"Transaction", 'Distributor'>
    readonly balanceId: FieldRef<"Transaction", 'Int'>
    readonly baseReportId: FieldRef<"Transaction", 'Int'>
    readonly userReportId: FieldRef<"Transaction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.baseReport
   */
  export type Transaction$baseReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    where?: BaseRoyaltyReportWhereInput
  }

  /**
   * Transaction.userReport
   */
  export type Transaction$userReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    where?: UserRoyaltyReportWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    street: string | null
    street2: string | null
    city: string | null
    state: string | null
    countryId: number | null
    zip: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    street: string | null
    street2: string | null
    city: string | null
    state: string | null
    countryId: number | null
    zip: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    street: number
    street2: number
    city: number
    state: number
    countryId: number
    zip: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    street?: true
    street2?: true
    city?: true
    state?: true
    countryId?: true
    zip?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    street?: true
    street2?: true
    city?: true
    state?: true
    countryId?: true
    zip?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    street?: true
    street2?: true
    city?: true
    state?: true
    countryId?: true
    zip?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    street: string
    street2: string | null
    city: string
    state: string
    countryId: number
    zip: string
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    street?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    countryId?: boolean
    zip?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    client?: boolean | Address$clientArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    street?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    countryId?: boolean
    zip?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    street?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    countryId?: boolean
    zip?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    street?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    countryId?: boolean
    zip?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "street" | "street2" | "city" | "state" | "countryId" | "zip", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    client?: boolean | Address$clientArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      street: string
      street2: string | null
      city: string
      state: string
      countryId: number
      zip: string
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends Address$clientArgs<ExtArgs> = {}>(args?: Subset<T, Address$clientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Int'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
    readonly street: FieldRef<"Address", 'String'>
    readonly street2: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly countryId: FieldRef<"Address", 'Int'>
    readonly zip: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.client
   */
  export type Address$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    name: string | null
    shortCode: string | null
    code: string | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    shortCode: string | null
    code: string | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    shortCode: number
    code: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    shortCode?: true
    code?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    shortCode?: true
    code?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    shortCode?: true
    code?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: number
    name: string
    shortCode: string
    code: string
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortCode?: boolean
    code?: boolean
    address?: boolean | Country$addressArgs<ExtArgs>
    label?: boolean | Country$labelArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortCode?: boolean
    code?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortCode?: boolean
    code?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    shortCode?: boolean
    code?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "shortCode" | "code", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Country$addressArgs<ExtArgs>
    label?: boolean | Country$labelArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>[]
      label: Prisma.$LabelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      shortCode: string
      code: string
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends Country$addressArgs<ExtArgs> = {}>(args?: Subset<T, Country$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    label<T extends Country$labelArgs<ExtArgs> = {}>(args?: Subset<T, Country$labelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'Int'>
    readonly name: FieldRef<"Country", 'String'>
    readonly shortCode: FieldRef<"Country", 'String'>
    readonly code: FieldRef<"Country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country.address
   */
  export type Country$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Country.label
   */
  export type Country$labelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    cursor?: LabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model Label
   */

  export type AggregateLabel = {
    _count: LabelCountAggregateOutputType | null
    _avg: LabelAvgAggregateOutputType | null
    _sum: LabelSumAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  export type LabelAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    countryId: number | null
  }

  export type LabelSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    countryId: number | null
  }

  export type LabelMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: number | null
    name: string | null
    status: $Enums.LabelStatus | null
    website: string | null
    countryId: number | null
    beatportStatus: $Enums.LabelRegistrationStatus | null
    traxsourceStatus: $Enums.LabelRegistrationStatus | null
    beatportUrl: string | null
    traxsourceUrl: string | null
  }

  export type LabelMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: number | null
    name: string | null
    status: $Enums.LabelStatus | null
    website: string | null
    countryId: number | null
    beatportStatus: $Enums.LabelRegistrationStatus | null
    traxsourceStatus: $Enums.LabelRegistrationStatus | null
    beatportUrl: string | null
    traxsourceUrl: string | null
  }

  export type LabelCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    clientId: number
    name: number
    status: number
    website: number
    countryId: number
    beatportStatus: number
    traxsourceStatus: number
    beatportUrl: number
    traxsourceUrl: number
    _all: number
  }


  export type LabelAvgAggregateInputType = {
    id?: true
    clientId?: true
    countryId?: true
  }

  export type LabelSumAggregateInputType = {
    id?: true
    clientId?: true
    countryId?: true
  }

  export type LabelMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    name?: true
    status?: true
    website?: true
    countryId?: true
    beatportStatus?: true
    traxsourceStatus?: true
    beatportUrl?: true
    traxsourceUrl?: true
  }

  export type LabelMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    name?: true
    status?: true
    website?: true
    countryId?: true
    beatportStatus?: true
    traxsourceStatus?: true
    beatportUrl?: true
    traxsourceUrl?: true
  }

  export type LabelCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    name?: true
    status?: true
    website?: true
    countryId?: true
    beatportStatus?: true
    traxsourceStatus?: true
    beatportUrl?: true
    traxsourceUrl?: true
    _all?: true
  }

  export type LabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Label to aggregate.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labels
    **/
    _count?: true | LabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelMaxAggregateInputType
  }

  export type GetLabelAggregateType<T extends LabelAggregateArgs> = {
        [P in keyof T & keyof AggregateLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabel[P]>
      : GetScalarType<T[P], AggregateLabel[P]>
  }




  export type LabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithAggregationInput | LabelOrderByWithAggregationInput[]
    by: LabelScalarFieldEnum[] | LabelScalarFieldEnum
    having?: LabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelCountAggregateInputType | true
    _avg?: LabelAvgAggregateInputType
    _sum?: LabelSumAggregateInputType
    _min?: LabelMinAggregateInputType
    _max?: LabelMaxAggregateInputType
  }

  export type LabelGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    clientId: number
    name: string
    status: $Enums.LabelStatus
    website: string | null
    countryId: number | null
    beatportStatus: $Enums.LabelRegistrationStatus
    traxsourceStatus: $Enums.LabelRegistrationStatus
    beatportUrl: string | null
    traxsourceUrl: string | null
    _count: LabelCountAggregateOutputType | null
    _avg: LabelAvgAggregateOutputType | null
    _sum: LabelSumAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  type GetLabelGroupByPayload<T extends LabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelGroupByOutputType[P]>
            : GetScalarType<T[P], LabelGroupByOutputType[P]>
        }
      >
    >


  export type LabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    name?: boolean
    status?: boolean
    website?: boolean
    countryId?: boolean
    beatportStatus?: boolean
    traxsourceStatus?: boolean
    beatportUrl?: boolean
    traxsourceUrl?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    country?: boolean | Label$countryArgs<ExtArgs>
    KontorRoyaltyReport?: boolean | Label$KontorRoyaltyReportArgs<ExtArgs>
    BelieveRoyaltyReport?: boolean | Label$BelieveRoyaltyReportArgs<ExtArgs>
    _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    name?: boolean
    status?: boolean
    website?: boolean
    countryId?: boolean
    beatportStatus?: boolean
    traxsourceStatus?: boolean
    beatportUrl?: boolean
    traxsourceUrl?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    country?: boolean | Label$countryArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    name?: boolean
    status?: boolean
    website?: boolean
    countryId?: boolean
    beatportStatus?: boolean
    traxsourceStatus?: boolean
    beatportUrl?: boolean
    traxsourceUrl?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    country?: boolean | Label$countryArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>

  export type LabelSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    name?: boolean
    status?: boolean
    website?: boolean
    countryId?: boolean
    beatportStatus?: boolean
    traxsourceStatus?: boolean
    beatportUrl?: boolean
    traxsourceUrl?: boolean
  }

  export type LabelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "clientId" | "name" | "status" | "website" | "countryId" | "beatportStatus" | "traxsourceStatus" | "beatportUrl" | "traxsourceUrl", ExtArgs["result"]["label"]>
  export type LabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    country?: boolean | Label$countryArgs<ExtArgs>
    KontorRoyaltyReport?: boolean | Label$KontorRoyaltyReportArgs<ExtArgs>
    BelieveRoyaltyReport?: boolean | Label$BelieveRoyaltyReportArgs<ExtArgs>
    _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    country?: boolean | Label$countryArgs<ExtArgs>
  }
  export type LabelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    country?: boolean | Label$countryArgs<ExtArgs>
  }

  export type $LabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Label"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      country: Prisma.$CountryPayload<ExtArgs> | null
      KontorRoyaltyReport: Prisma.$KontorRoyaltyReportPayload<ExtArgs>[]
      BelieveRoyaltyReport: Prisma.$BelieveRoyaltyReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      clientId: number
      name: string
      status: $Enums.LabelStatus
      website: string | null
      countryId: number | null
      beatportStatus: $Enums.LabelRegistrationStatus
      traxsourceStatus: $Enums.LabelRegistrationStatus
      beatportUrl: string | null
      traxsourceUrl: string | null
    }, ExtArgs["result"]["label"]>
    composites: {}
  }

  type LabelGetPayload<S extends boolean | null | undefined | LabelDefaultArgs> = $Result.GetResult<Prisma.$LabelPayload, S>

  type LabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabelCountAggregateInputType | true
    }

  export interface LabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Label'], meta: { name: 'Label' } }
    /**
     * Find zero or one Label that matches the filter.
     * @param {LabelFindUniqueArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabelFindUniqueArgs>(args: SelectSubset<T, LabelFindUniqueArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Label that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabelFindUniqueOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabelFindUniqueOrThrowArgs>(args: SelectSubset<T, LabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Label that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabelFindFirstArgs>(args?: SelectSubset<T, LabelFindFirstArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Label that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabelFindFirstOrThrowArgs>(args?: SelectSubset<T, LabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Labels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labels
     * const labels = await prisma.label.findMany()
     * 
     * // Get first 10 Labels
     * const labels = await prisma.label.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labelWithIdOnly = await prisma.label.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabelFindManyArgs>(args?: SelectSubset<T, LabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Label.
     * @param {LabelCreateArgs} args - Arguments to create a Label.
     * @example
     * // Create one Label
     * const Label = await prisma.label.create({
     *   data: {
     *     // ... data to create a Label
     *   }
     * })
     * 
     */
    create<T extends LabelCreateArgs>(args: SelectSubset<T, LabelCreateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Labels.
     * @param {LabelCreateManyArgs} args - Arguments to create many Labels.
     * @example
     * // Create many Labels
     * const label = await prisma.label.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabelCreateManyArgs>(args?: SelectSubset<T, LabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Labels and returns the data saved in the database.
     * @param {LabelCreateManyAndReturnArgs} args - Arguments to create many Labels.
     * @example
     * // Create many Labels
     * const label = await prisma.label.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Labels and only return the `id`
     * const labelWithIdOnly = await prisma.label.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabelCreateManyAndReturnArgs>(args?: SelectSubset<T, LabelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Label.
     * @param {LabelDeleteArgs} args - Arguments to delete one Label.
     * @example
     * // Delete one Label
     * const Label = await prisma.label.delete({
     *   where: {
     *     // ... filter to delete one Label
     *   }
     * })
     * 
     */
    delete<T extends LabelDeleteArgs>(args: SelectSubset<T, LabelDeleteArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Label.
     * @param {LabelUpdateArgs} args - Arguments to update one Label.
     * @example
     * // Update one Label
     * const label = await prisma.label.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabelUpdateArgs>(args: SelectSubset<T, LabelUpdateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Labels.
     * @param {LabelDeleteManyArgs} args - Arguments to filter Labels to delete.
     * @example
     * // Delete a few Labels
     * const { count } = await prisma.label.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabelDeleteManyArgs>(args?: SelectSubset<T, LabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabelUpdateManyArgs>(args: SelectSubset<T, LabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels and returns the data updated in the database.
     * @param {LabelUpdateManyAndReturnArgs} args - Arguments to update many Labels.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Labels and only return the `id`
     * const labelWithIdOnly = await prisma.label.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabelUpdateManyAndReturnArgs>(args: SelectSubset<T, LabelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Label.
     * @param {LabelUpsertArgs} args - Arguments to update or create a Label.
     * @example
     * // Update or create a Label
     * const label = await prisma.label.upsert({
     *   create: {
     *     // ... data to create a Label
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Label we want to update
     *   }
     * })
     */
    upsert<T extends LabelUpsertArgs>(args: SelectSubset<T, LabelUpsertArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCountArgs} args - Arguments to filter Labels to count.
     * @example
     * // Count the number of Labels
     * const count = await prisma.label.count({
     *   where: {
     *     // ... the filter for the Labels we want to count
     *   }
     * })
    **/
    count<T extends LabelCountArgs>(
      args?: Subset<T, LabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelAggregateArgs>(args: Subset<T, LabelAggregateArgs>): Prisma.PrismaPromise<GetLabelAggregateType<T>>

    /**
     * Group by Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelGroupByArgs['orderBy'] }
        : { orderBy?: LabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Label model
   */
  readonly fields: LabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Label.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    country<T extends Label$countryArgs<ExtArgs> = {}>(args?: Subset<T, Label$countryArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    KontorRoyaltyReport<T extends Label$KontorRoyaltyReportArgs<ExtArgs> = {}>(args?: Subset<T, Label$KontorRoyaltyReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BelieveRoyaltyReport<T extends Label$BelieveRoyaltyReportArgs<ExtArgs> = {}>(args?: Subset<T, Label$BelieveRoyaltyReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Label model
   */
  interface LabelFieldRefs {
    readonly id: FieldRef<"Label", 'Int'>
    readonly createdAt: FieldRef<"Label", 'DateTime'>
    readonly updatedAt: FieldRef<"Label", 'DateTime'>
    readonly clientId: FieldRef<"Label", 'Int'>
    readonly name: FieldRef<"Label", 'String'>
    readonly status: FieldRef<"Label", 'LabelStatus'>
    readonly website: FieldRef<"Label", 'String'>
    readonly countryId: FieldRef<"Label", 'Int'>
    readonly beatportStatus: FieldRef<"Label", 'LabelRegistrationStatus'>
    readonly traxsourceStatus: FieldRef<"Label", 'LabelRegistrationStatus'>
    readonly beatportUrl: FieldRef<"Label", 'String'>
    readonly traxsourceUrl: FieldRef<"Label", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Label findUnique
   */
  export type LabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findUniqueOrThrow
   */
  export type LabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findFirst
   */
  export type LabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findFirstOrThrow
   */
  export type LabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findMany
   */
  export type LabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Labels to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label create
   */
  export type LabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to create a Label.
     */
    data: XOR<LabelCreateInput, LabelUncheckedCreateInput>
  }

  /**
   * Label createMany
   */
  export type LabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Labels.
     */
    data: LabelCreateManyInput | LabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Label createManyAndReturn
   */
  export type LabelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * The data used to create many Labels.
     */
    data: LabelCreateManyInput | LabelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Label update
   */
  export type LabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to update a Label.
     */
    data: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
    /**
     * Choose, which Label to update.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label updateMany
   */
  export type LabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Labels.
     */
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to update.
     */
    limit?: number
  }

  /**
   * Label updateManyAndReturn
   */
  export type LabelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * The data used to update Labels.
     */
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Label upsert
   */
  export type LabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The filter to search for the Label to update in case it exists.
     */
    where: LabelWhereUniqueInput
    /**
     * In case the Label found by the `where` argument doesn't exist, create a new Label with this data.
     */
    create: XOR<LabelCreateInput, LabelUncheckedCreateInput>
    /**
     * In case the Label was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
  }

  /**
   * Label delete
   */
  export type LabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter which Label to delete.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label deleteMany
   */
  export type LabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Labels to delete
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to delete.
     */
    limit?: number
  }

  /**
   * Label.country
   */
  export type Label$countryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    where?: CountryWhereInput
  }

  /**
   * Label.KontorRoyaltyReport
   */
  export type Label$KontorRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    where?: KontorRoyaltyReportWhereInput
    orderBy?: KontorRoyaltyReportOrderByWithRelationInput | KontorRoyaltyReportOrderByWithRelationInput[]
    cursor?: KontorRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KontorRoyaltyReportScalarFieldEnum | KontorRoyaltyReportScalarFieldEnum[]
  }

  /**
   * Label.BelieveRoyaltyReport
   */
  export type Label$BelieveRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    where?: BelieveRoyaltyReportWhereInput
    orderBy?: BelieveRoyaltyReportOrderByWithRelationInput | BelieveRoyaltyReportOrderByWithRelationInput[]
    cursor?: BelieveRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BelieveRoyaltyReportScalarFieldEnum | BelieveRoyaltyReportScalarFieldEnum[]
  }

  /**
   * Label without action
   */
  export type LabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
  }


  /**
   * Model ImportedRoyaltyReport
   */

  export type AggregateImportedRoyaltyReport = {
    _count: ImportedRoyaltyReportCountAggregateOutputType | null
    _avg: ImportedRoyaltyReportAvgAggregateOutputType | null
    _sum: ImportedRoyaltyReportSumAggregateOutputType | null
    _min: ImportedRoyaltyReportMinAggregateOutputType | null
    _max: ImportedRoyaltyReportMaxAggregateOutputType | null
  }

  export type ImportedRoyaltyReportAvgAggregateOutputType = {
    id: number | null
    s3FileId: number | null
  }

  export type ImportedRoyaltyReportSumAggregateOutputType = {
    id: number | null
    s3FileId: number | null
  }

  export type ImportedRoyaltyReportMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    distributor: $Enums.Distributor | null
    reportingMonth: string | null
    importStatus: string | null
    s3FileId: number | null
  }

  export type ImportedRoyaltyReportMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    distributor: $Enums.Distributor | null
    reportingMonth: string | null
    importStatus: string | null
    s3FileId: number | null
  }

  export type ImportedRoyaltyReportCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    distributor: number
    reportingMonth: number
    importStatus: number
    s3FileId: number
    _all: number
  }


  export type ImportedRoyaltyReportAvgAggregateInputType = {
    id?: true
    s3FileId?: true
  }

  export type ImportedRoyaltyReportSumAggregateInputType = {
    id?: true
    s3FileId?: true
  }

  export type ImportedRoyaltyReportMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributor?: true
    reportingMonth?: true
    importStatus?: true
    s3FileId?: true
  }

  export type ImportedRoyaltyReportMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributor?: true
    reportingMonth?: true
    importStatus?: true
    s3FileId?: true
  }

  export type ImportedRoyaltyReportCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributor?: true
    reportingMonth?: true
    importStatus?: true
    s3FileId?: true
    _all?: true
  }

  export type ImportedRoyaltyReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportedRoyaltyReport to aggregate.
     */
    where?: ImportedRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportedRoyaltyReports to fetch.
     */
    orderBy?: ImportedRoyaltyReportOrderByWithRelationInput | ImportedRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportedRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportedRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportedRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportedRoyaltyReports
    **/
    _count?: true | ImportedRoyaltyReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportedRoyaltyReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportedRoyaltyReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportedRoyaltyReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportedRoyaltyReportMaxAggregateInputType
  }

  export type GetImportedRoyaltyReportAggregateType<T extends ImportedRoyaltyReportAggregateArgs> = {
        [P in keyof T & keyof AggregateImportedRoyaltyReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportedRoyaltyReport[P]>
      : GetScalarType<T[P], AggregateImportedRoyaltyReport[P]>
  }




  export type ImportedRoyaltyReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportedRoyaltyReportWhereInput
    orderBy?: ImportedRoyaltyReportOrderByWithAggregationInput | ImportedRoyaltyReportOrderByWithAggregationInput[]
    by: ImportedRoyaltyReportScalarFieldEnum[] | ImportedRoyaltyReportScalarFieldEnum
    having?: ImportedRoyaltyReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportedRoyaltyReportCountAggregateInputType | true
    _avg?: ImportedRoyaltyReportAvgAggregateInputType
    _sum?: ImportedRoyaltyReportSumAggregateInputType
    _min?: ImportedRoyaltyReportMinAggregateInputType
    _max?: ImportedRoyaltyReportMaxAggregateInputType
  }

  export type ImportedRoyaltyReportGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
    s3FileId: number | null
    _count: ImportedRoyaltyReportCountAggregateOutputType | null
    _avg: ImportedRoyaltyReportAvgAggregateOutputType | null
    _sum: ImportedRoyaltyReportSumAggregateOutputType | null
    _min: ImportedRoyaltyReportMinAggregateOutputType | null
    _max: ImportedRoyaltyReportMaxAggregateOutputType | null
  }

  type GetImportedRoyaltyReportGroupByPayload<T extends ImportedRoyaltyReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportedRoyaltyReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportedRoyaltyReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportedRoyaltyReportGroupByOutputType[P]>
            : GetScalarType<T[P], ImportedRoyaltyReportGroupByOutputType[P]>
        }
      >
    >


  export type ImportedRoyaltyReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    importStatus?: boolean
    s3FileId?: boolean
    s3File?: boolean | ImportedRoyaltyReport$s3FileArgs<ExtArgs>
    KontorRoyaltyReport?: boolean | ImportedRoyaltyReport$KontorRoyaltyReportArgs<ExtArgs>
    BelieveRoyaltyReport?: boolean | ImportedRoyaltyReport$BelieveRoyaltyReportArgs<ExtArgs>
    _count?: boolean | ImportedRoyaltyReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importedRoyaltyReport"]>

  export type ImportedRoyaltyReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    importStatus?: boolean
    s3FileId?: boolean
    s3File?: boolean | ImportedRoyaltyReport$s3FileArgs<ExtArgs>
  }, ExtArgs["result"]["importedRoyaltyReport"]>

  export type ImportedRoyaltyReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    importStatus?: boolean
    s3FileId?: boolean
    s3File?: boolean | ImportedRoyaltyReport$s3FileArgs<ExtArgs>
  }, ExtArgs["result"]["importedRoyaltyReport"]>

  export type ImportedRoyaltyReportSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    importStatus?: boolean
    s3FileId?: boolean
  }

  export type ImportedRoyaltyReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "distributor" | "reportingMonth" | "importStatus" | "s3FileId", ExtArgs["result"]["importedRoyaltyReport"]>
  export type ImportedRoyaltyReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    s3File?: boolean | ImportedRoyaltyReport$s3FileArgs<ExtArgs>
    KontorRoyaltyReport?: boolean | ImportedRoyaltyReport$KontorRoyaltyReportArgs<ExtArgs>
    BelieveRoyaltyReport?: boolean | ImportedRoyaltyReport$BelieveRoyaltyReportArgs<ExtArgs>
    _count?: boolean | ImportedRoyaltyReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImportedRoyaltyReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    s3File?: boolean | ImportedRoyaltyReport$s3FileArgs<ExtArgs>
  }
  export type ImportedRoyaltyReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    s3File?: boolean | ImportedRoyaltyReport$s3FileArgs<ExtArgs>
  }

  export type $ImportedRoyaltyReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportedRoyaltyReport"
    objects: {
      s3File: Prisma.$S3FilePayload<ExtArgs> | null
      KontorRoyaltyReport: Prisma.$KontorRoyaltyReportPayload<ExtArgs>[]
      BelieveRoyaltyReport: Prisma.$BelieveRoyaltyReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      distributor: $Enums.Distributor
      reportingMonth: string
      importStatus: string
      s3FileId: number | null
    }, ExtArgs["result"]["importedRoyaltyReport"]>
    composites: {}
  }

  type ImportedRoyaltyReportGetPayload<S extends boolean | null | undefined | ImportedRoyaltyReportDefaultArgs> = $Result.GetResult<Prisma.$ImportedRoyaltyReportPayload, S>

  type ImportedRoyaltyReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImportedRoyaltyReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImportedRoyaltyReportCountAggregateInputType | true
    }

  export interface ImportedRoyaltyReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportedRoyaltyReport'], meta: { name: 'ImportedRoyaltyReport' } }
    /**
     * Find zero or one ImportedRoyaltyReport that matches the filter.
     * @param {ImportedRoyaltyReportFindUniqueArgs} args - Arguments to find a ImportedRoyaltyReport
     * @example
     * // Get one ImportedRoyaltyReport
     * const importedRoyaltyReport = await prisma.importedRoyaltyReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportedRoyaltyReportFindUniqueArgs>(args: SelectSubset<T, ImportedRoyaltyReportFindUniqueArgs<ExtArgs>>): Prisma__ImportedRoyaltyReportClient<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImportedRoyaltyReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImportedRoyaltyReportFindUniqueOrThrowArgs} args - Arguments to find a ImportedRoyaltyReport
     * @example
     * // Get one ImportedRoyaltyReport
     * const importedRoyaltyReport = await prisma.importedRoyaltyReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportedRoyaltyReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportedRoyaltyReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportedRoyaltyReportClient<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportedRoyaltyReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportedRoyaltyReportFindFirstArgs} args - Arguments to find a ImportedRoyaltyReport
     * @example
     * // Get one ImportedRoyaltyReport
     * const importedRoyaltyReport = await prisma.importedRoyaltyReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportedRoyaltyReportFindFirstArgs>(args?: SelectSubset<T, ImportedRoyaltyReportFindFirstArgs<ExtArgs>>): Prisma__ImportedRoyaltyReportClient<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportedRoyaltyReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportedRoyaltyReportFindFirstOrThrowArgs} args - Arguments to find a ImportedRoyaltyReport
     * @example
     * // Get one ImportedRoyaltyReport
     * const importedRoyaltyReport = await prisma.importedRoyaltyReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportedRoyaltyReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportedRoyaltyReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportedRoyaltyReportClient<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImportedRoyaltyReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportedRoyaltyReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportedRoyaltyReports
     * const importedRoyaltyReports = await prisma.importedRoyaltyReport.findMany()
     * 
     * // Get first 10 ImportedRoyaltyReports
     * const importedRoyaltyReports = await prisma.importedRoyaltyReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importedRoyaltyReportWithIdOnly = await prisma.importedRoyaltyReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportedRoyaltyReportFindManyArgs>(args?: SelectSubset<T, ImportedRoyaltyReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImportedRoyaltyReport.
     * @param {ImportedRoyaltyReportCreateArgs} args - Arguments to create a ImportedRoyaltyReport.
     * @example
     * // Create one ImportedRoyaltyReport
     * const ImportedRoyaltyReport = await prisma.importedRoyaltyReport.create({
     *   data: {
     *     // ... data to create a ImportedRoyaltyReport
     *   }
     * })
     * 
     */
    create<T extends ImportedRoyaltyReportCreateArgs>(args: SelectSubset<T, ImportedRoyaltyReportCreateArgs<ExtArgs>>): Prisma__ImportedRoyaltyReportClient<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImportedRoyaltyReports.
     * @param {ImportedRoyaltyReportCreateManyArgs} args - Arguments to create many ImportedRoyaltyReports.
     * @example
     * // Create many ImportedRoyaltyReports
     * const importedRoyaltyReport = await prisma.importedRoyaltyReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportedRoyaltyReportCreateManyArgs>(args?: SelectSubset<T, ImportedRoyaltyReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportedRoyaltyReports and returns the data saved in the database.
     * @param {ImportedRoyaltyReportCreateManyAndReturnArgs} args - Arguments to create many ImportedRoyaltyReports.
     * @example
     * // Create many ImportedRoyaltyReports
     * const importedRoyaltyReport = await prisma.importedRoyaltyReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportedRoyaltyReports and only return the `id`
     * const importedRoyaltyReportWithIdOnly = await prisma.importedRoyaltyReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportedRoyaltyReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportedRoyaltyReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImportedRoyaltyReport.
     * @param {ImportedRoyaltyReportDeleteArgs} args - Arguments to delete one ImportedRoyaltyReport.
     * @example
     * // Delete one ImportedRoyaltyReport
     * const ImportedRoyaltyReport = await prisma.importedRoyaltyReport.delete({
     *   where: {
     *     // ... filter to delete one ImportedRoyaltyReport
     *   }
     * })
     * 
     */
    delete<T extends ImportedRoyaltyReportDeleteArgs>(args: SelectSubset<T, ImportedRoyaltyReportDeleteArgs<ExtArgs>>): Prisma__ImportedRoyaltyReportClient<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImportedRoyaltyReport.
     * @param {ImportedRoyaltyReportUpdateArgs} args - Arguments to update one ImportedRoyaltyReport.
     * @example
     * // Update one ImportedRoyaltyReport
     * const importedRoyaltyReport = await prisma.importedRoyaltyReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportedRoyaltyReportUpdateArgs>(args: SelectSubset<T, ImportedRoyaltyReportUpdateArgs<ExtArgs>>): Prisma__ImportedRoyaltyReportClient<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImportedRoyaltyReports.
     * @param {ImportedRoyaltyReportDeleteManyArgs} args - Arguments to filter ImportedRoyaltyReports to delete.
     * @example
     * // Delete a few ImportedRoyaltyReports
     * const { count } = await prisma.importedRoyaltyReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportedRoyaltyReportDeleteManyArgs>(args?: SelectSubset<T, ImportedRoyaltyReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportedRoyaltyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportedRoyaltyReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportedRoyaltyReports
     * const importedRoyaltyReport = await prisma.importedRoyaltyReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportedRoyaltyReportUpdateManyArgs>(args: SelectSubset<T, ImportedRoyaltyReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportedRoyaltyReports and returns the data updated in the database.
     * @param {ImportedRoyaltyReportUpdateManyAndReturnArgs} args - Arguments to update many ImportedRoyaltyReports.
     * @example
     * // Update many ImportedRoyaltyReports
     * const importedRoyaltyReport = await prisma.importedRoyaltyReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImportedRoyaltyReports and only return the `id`
     * const importedRoyaltyReportWithIdOnly = await prisma.importedRoyaltyReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImportedRoyaltyReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ImportedRoyaltyReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImportedRoyaltyReport.
     * @param {ImportedRoyaltyReportUpsertArgs} args - Arguments to update or create a ImportedRoyaltyReport.
     * @example
     * // Update or create a ImportedRoyaltyReport
     * const importedRoyaltyReport = await prisma.importedRoyaltyReport.upsert({
     *   create: {
     *     // ... data to create a ImportedRoyaltyReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportedRoyaltyReport we want to update
     *   }
     * })
     */
    upsert<T extends ImportedRoyaltyReportUpsertArgs>(args: SelectSubset<T, ImportedRoyaltyReportUpsertArgs<ExtArgs>>): Prisma__ImportedRoyaltyReportClient<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImportedRoyaltyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportedRoyaltyReportCountArgs} args - Arguments to filter ImportedRoyaltyReports to count.
     * @example
     * // Count the number of ImportedRoyaltyReports
     * const count = await prisma.importedRoyaltyReport.count({
     *   where: {
     *     // ... the filter for the ImportedRoyaltyReports we want to count
     *   }
     * })
    **/
    count<T extends ImportedRoyaltyReportCountArgs>(
      args?: Subset<T, ImportedRoyaltyReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportedRoyaltyReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportedRoyaltyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportedRoyaltyReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportedRoyaltyReportAggregateArgs>(args: Subset<T, ImportedRoyaltyReportAggregateArgs>): Prisma.PrismaPromise<GetImportedRoyaltyReportAggregateType<T>>

    /**
     * Group by ImportedRoyaltyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportedRoyaltyReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportedRoyaltyReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportedRoyaltyReportGroupByArgs['orderBy'] }
        : { orderBy?: ImportedRoyaltyReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportedRoyaltyReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportedRoyaltyReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportedRoyaltyReport model
   */
  readonly fields: ImportedRoyaltyReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportedRoyaltyReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportedRoyaltyReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    s3File<T extends ImportedRoyaltyReport$s3FileArgs<ExtArgs> = {}>(args?: Subset<T, ImportedRoyaltyReport$s3FileArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    KontorRoyaltyReport<T extends ImportedRoyaltyReport$KontorRoyaltyReportArgs<ExtArgs> = {}>(args?: Subset<T, ImportedRoyaltyReport$KontorRoyaltyReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BelieveRoyaltyReport<T extends ImportedRoyaltyReport$BelieveRoyaltyReportArgs<ExtArgs> = {}>(args?: Subset<T, ImportedRoyaltyReport$BelieveRoyaltyReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportedRoyaltyReport model
   */
  interface ImportedRoyaltyReportFieldRefs {
    readonly id: FieldRef<"ImportedRoyaltyReport", 'Int'>
    readonly createdAt: FieldRef<"ImportedRoyaltyReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ImportedRoyaltyReport", 'DateTime'>
    readonly distributor: FieldRef<"ImportedRoyaltyReport", 'Distributor'>
    readonly reportingMonth: FieldRef<"ImportedRoyaltyReport", 'String'>
    readonly importStatus: FieldRef<"ImportedRoyaltyReport", 'String'>
    readonly s3FileId: FieldRef<"ImportedRoyaltyReport", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ImportedRoyaltyReport findUnique
   */
  export type ImportedRoyaltyReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which ImportedRoyaltyReport to fetch.
     */
    where: ImportedRoyaltyReportWhereUniqueInput
  }

  /**
   * ImportedRoyaltyReport findUniqueOrThrow
   */
  export type ImportedRoyaltyReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which ImportedRoyaltyReport to fetch.
     */
    where: ImportedRoyaltyReportWhereUniqueInput
  }

  /**
   * ImportedRoyaltyReport findFirst
   */
  export type ImportedRoyaltyReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which ImportedRoyaltyReport to fetch.
     */
    where?: ImportedRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportedRoyaltyReports to fetch.
     */
    orderBy?: ImportedRoyaltyReportOrderByWithRelationInput | ImportedRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportedRoyaltyReports.
     */
    cursor?: ImportedRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportedRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportedRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportedRoyaltyReports.
     */
    distinct?: ImportedRoyaltyReportScalarFieldEnum | ImportedRoyaltyReportScalarFieldEnum[]
  }

  /**
   * ImportedRoyaltyReport findFirstOrThrow
   */
  export type ImportedRoyaltyReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which ImportedRoyaltyReport to fetch.
     */
    where?: ImportedRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportedRoyaltyReports to fetch.
     */
    orderBy?: ImportedRoyaltyReportOrderByWithRelationInput | ImportedRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportedRoyaltyReports.
     */
    cursor?: ImportedRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportedRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportedRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportedRoyaltyReports.
     */
    distinct?: ImportedRoyaltyReportScalarFieldEnum | ImportedRoyaltyReportScalarFieldEnum[]
  }

  /**
   * ImportedRoyaltyReport findMany
   */
  export type ImportedRoyaltyReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which ImportedRoyaltyReports to fetch.
     */
    where?: ImportedRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportedRoyaltyReports to fetch.
     */
    orderBy?: ImportedRoyaltyReportOrderByWithRelationInput | ImportedRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportedRoyaltyReports.
     */
    cursor?: ImportedRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportedRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportedRoyaltyReports.
     */
    skip?: number
    distinct?: ImportedRoyaltyReportScalarFieldEnum | ImportedRoyaltyReportScalarFieldEnum[]
  }

  /**
   * ImportedRoyaltyReport create
   */
  export type ImportedRoyaltyReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportedRoyaltyReport.
     */
    data: XOR<ImportedRoyaltyReportCreateInput, ImportedRoyaltyReportUncheckedCreateInput>
  }

  /**
   * ImportedRoyaltyReport createMany
   */
  export type ImportedRoyaltyReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportedRoyaltyReports.
     */
    data: ImportedRoyaltyReportCreateManyInput | ImportedRoyaltyReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportedRoyaltyReport createManyAndReturn
   */
  export type ImportedRoyaltyReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * The data used to create many ImportedRoyaltyReports.
     */
    data: ImportedRoyaltyReportCreateManyInput | ImportedRoyaltyReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportedRoyaltyReport update
   */
  export type ImportedRoyaltyReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportedRoyaltyReport.
     */
    data: XOR<ImportedRoyaltyReportUpdateInput, ImportedRoyaltyReportUncheckedUpdateInput>
    /**
     * Choose, which ImportedRoyaltyReport to update.
     */
    where: ImportedRoyaltyReportWhereUniqueInput
  }

  /**
   * ImportedRoyaltyReport updateMany
   */
  export type ImportedRoyaltyReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportedRoyaltyReports.
     */
    data: XOR<ImportedRoyaltyReportUpdateManyMutationInput, ImportedRoyaltyReportUncheckedUpdateManyInput>
    /**
     * Filter which ImportedRoyaltyReports to update
     */
    where?: ImportedRoyaltyReportWhereInput
    /**
     * Limit how many ImportedRoyaltyReports to update.
     */
    limit?: number
  }

  /**
   * ImportedRoyaltyReport updateManyAndReturn
   */
  export type ImportedRoyaltyReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * The data used to update ImportedRoyaltyReports.
     */
    data: XOR<ImportedRoyaltyReportUpdateManyMutationInput, ImportedRoyaltyReportUncheckedUpdateManyInput>
    /**
     * Filter which ImportedRoyaltyReports to update
     */
    where?: ImportedRoyaltyReportWhereInput
    /**
     * Limit how many ImportedRoyaltyReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportedRoyaltyReport upsert
   */
  export type ImportedRoyaltyReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportedRoyaltyReport to update in case it exists.
     */
    where: ImportedRoyaltyReportWhereUniqueInput
    /**
     * In case the ImportedRoyaltyReport found by the `where` argument doesn't exist, create a new ImportedRoyaltyReport with this data.
     */
    create: XOR<ImportedRoyaltyReportCreateInput, ImportedRoyaltyReportUncheckedCreateInput>
    /**
     * In case the ImportedRoyaltyReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportedRoyaltyReportUpdateInput, ImportedRoyaltyReportUncheckedUpdateInput>
  }

  /**
   * ImportedRoyaltyReport delete
   */
  export type ImportedRoyaltyReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter which ImportedRoyaltyReport to delete.
     */
    where: ImportedRoyaltyReportWhereUniqueInput
  }

  /**
   * ImportedRoyaltyReport deleteMany
   */
  export type ImportedRoyaltyReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportedRoyaltyReports to delete
     */
    where?: ImportedRoyaltyReportWhereInput
    /**
     * Limit how many ImportedRoyaltyReports to delete.
     */
    limit?: number
  }

  /**
   * ImportedRoyaltyReport.s3File
   */
  export type ImportedRoyaltyReport$s3FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    where?: S3FileWhereInput
  }

  /**
   * ImportedRoyaltyReport.KontorRoyaltyReport
   */
  export type ImportedRoyaltyReport$KontorRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    where?: KontorRoyaltyReportWhereInput
    orderBy?: KontorRoyaltyReportOrderByWithRelationInput | KontorRoyaltyReportOrderByWithRelationInput[]
    cursor?: KontorRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KontorRoyaltyReportScalarFieldEnum | KontorRoyaltyReportScalarFieldEnum[]
  }

  /**
   * ImportedRoyaltyReport.BelieveRoyaltyReport
   */
  export type ImportedRoyaltyReport$BelieveRoyaltyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    where?: BelieveRoyaltyReportWhereInput
    orderBy?: BelieveRoyaltyReportOrderByWithRelationInput | BelieveRoyaltyReportOrderByWithRelationInput[]
    cursor?: BelieveRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BelieveRoyaltyReportScalarFieldEnum | BelieveRoyaltyReportScalarFieldEnum[]
  }

  /**
   * ImportedRoyaltyReport without action
   */
  export type ImportedRoyaltyReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
  }


  /**
   * Model BaseRoyaltyReport
   */

  export type AggregateBaseRoyaltyReport = {
    _count: BaseRoyaltyReportCountAggregateOutputType | null
    _avg: BaseRoyaltyReportAvgAggregateOutputType | null
    _sum: BaseRoyaltyReportSumAggregateOutputType | null
    _min: BaseRoyaltyReportMinAggregateOutputType | null
    _max: BaseRoyaltyReportMaxAggregateOutputType | null
  }

  export type BaseRoyaltyReportAvgAggregateOutputType = {
    id: number | null
    totalRoyalties: number | null
    totalEarnings: number | null
    s3FileId: number | null
  }

  export type BaseRoyaltyReportSumAggregateOutputType = {
    id: number | null
    totalRoyalties: number | null
    totalEarnings: number | null
    s3FileId: number | null
  }

  export type BaseRoyaltyReportMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: $Enums.Currency | null
    distributor: $Enums.Distributor | null
    reportingMonth: string | null
    totalRoyalties: number | null
    totalEarnings: number | null
    debitState: $Enums.DebitState | null
    paidOn: Date | null
    s3FileId: number | null
  }

  export type BaseRoyaltyReportMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: $Enums.Currency | null
    distributor: $Enums.Distributor | null
    reportingMonth: string | null
    totalRoyalties: number | null
    totalEarnings: number | null
    debitState: $Enums.DebitState | null
    paidOn: Date | null
    s3FileId: number | null
  }

  export type BaseRoyaltyReportCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    currency: number
    distributor: number
    reportingMonth: number
    totalRoyalties: number
    totalEarnings: number
    debitState: number
    paidOn: number
    s3FileId: number
    _all: number
  }


  export type BaseRoyaltyReportAvgAggregateInputType = {
    id?: true
    totalRoyalties?: true
    totalEarnings?: true
    s3FileId?: true
  }

  export type BaseRoyaltyReportSumAggregateInputType = {
    id?: true
    totalRoyalties?: true
    totalEarnings?: true
    s3FileId?: true
  }

  export type BaseRoyaltyReportMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    distributor?: true
    reportingMonth?: true
    totalRoyalties?: true
    totalEarnings?: true
    debitState?: true
    paidOn?: true
    s3FileId?: true
  }

  export type BaseRoyaltyReportMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    distributor?: true
    reportingMonth?: true
    totalRoyalties?: true
    totalEarnings?: true
    debitState?: true
    paidOn?: true
    s3FileId?: true
  }

  export type BaseRoyaltyReportCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    distributor?: true
    reportingMonth?: true
    totalRoyalties?: true
    totalEarnings?: true
    debitState?: true
    paidOn?: true
    s3FileId?: true
    _all?: true
  }

  export type BaseRoyaltyReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseRoyaltyReport to aggregate.
     */
    where?: BaseRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseRoyaltyReports to fetch.
     */
    orderBy?: BaseRoyaltyReportOrderByWithRelationInput | BaseRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BaseRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BaseRoyaltyReports
    **/
    _count?: true | BaseRoyaltyReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BaseRoyaltyReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BaseRoyaltyReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaseRoyaltyReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaseRoyaltyReportMaxAggregateInputType
  }

  export type GetBaseRoyaltyReportAggregateType<T extends BaseRoyaltyReportAggregateArgs> = {
        [P in keyof T & keyof AggregateBaseRoyaltyReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaseRoyaltyReport[P]>
      : GetScalarType<T[P], AggregateBaseRoyaltyReport[P]>
  }




  export type BaseRoyaltyReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaseRoyaltyReportWhereInput
    orderBy?: BaseRoyaltyReportOrderByWithAggregationInput | BaseRoyaltyReportOrderByWithAggregationInput[]
    by: BaseRoyaltyReportScalarFieldEnum[] | BaseRoyaltyReportScalarFieldEnum
    having?: BaseRoyaltyReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaseRoyaltyReportCountAggregateInputType | true
    _avg?: BaseRoyaltyReportAvgAggregateInputType
    _sum?: BaseRoyaltyReportSumAggregateInputType
    _min?: BaseRoyaltyReportMinAggregateInputType
    _max?: BaseRoyaltyReportMaxAggregateInputType
  }

  export type BaseRoyaltyReportGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    currency: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState: $Enums.DebitState
    paidOn: Date | null
    s3FileId: number | null
    _count: BaseRoyaltyReportCountAggregateOutputType | null
    _avg: BaseRoyaltyReportAvgAggregateOutputType | null
    _sum: BaseRoyaltyReportSumAggregateOutputType | null
    _min: BaseRoyaltyReportMinAggregateOutputType | null
    _max: BaseRoyaltyReportMaxAggregateOutputType | null
  }

  type GetBaseRoyaltyReportGroupByPayload<T extends BaseRoyaltyReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BaseRoyaltyReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaseRoyaltyReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaseRoyaltyReportGroupByOutputType[P]>
            : GetScalarType<T[P], BaseRoyaltyReportGroupByOutputType[P]>
        }
      >
    >


  export type BaseRoyaltyReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    totalRoyalties?: boolean
    totalEarnings?: boolean
    debitState?: boolean
    paidOn?: boolean
    s3FileId?: boolean
    s3File?: boolean | BaseRoyaltyReport$s3FileArgs<ExtArgs>
    kontorReports?: boolean | BaseRoyaltyReport$kontorReportsArgs<ExtArgs>
    believeReports?: boolean | BaseRoyaltyReport$believeReportsArgs<ExtArgs>
    userReports?: boolean | BaseRoyaltyReport$userReportsArgs<ExtArgs>
    Transaction?: boolean | BaseRoyaltyReport$TransactionArgs<ExtArgs>
    _count?: boolean | BaseRoyaltyReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["baseRoyaltyReport"]>

  export type BaseRoyaltyReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    totalRoyalties?: boolean
    totalEarnings?: boolean
    debitState?: boolean
    paidOn?: boolean
    s3FileId?: boolean
    s3File?: boolean | BaseRoyaltyReport$s3FileArgs<ExtArgs>
  }, ExtArgs["result"]["baseRoyaltyReport"]>

  export type BaseRoyaltyReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    totalRoyalties?: boolean
    totalEarnings?: boolean
    debitState?: boolean
    paidOn?: boolean
    s3FileId?: boolean
    s3File?: boolean | BaseRoyaltyReport$s3FileArgs<ExtArgs>
  }, ExtArgs["result"]["baseRoyaltyReport"]>

  export type BaseRoyaltyReportSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    totalRoyalties?: boolean
    totalEarnings?: boolean
    debitState?: boolean
    paidOn?: boolean
    s3FileId?: boolean
  }

  export type BaseRoyaltyReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "currency" | "distributor" | "reportingMonth" | "totalRoyalties" | "totalEarnings" | "debitState" | "paidOn" | "s3FileId", ExtArgs["result"]["baseRoyaltyReport"]>
  export type BaseRoyaltyReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    s3File?: boolean | BaseRoyaltyReport$s3FileArgs<ExtArgs>
    kontorReports?: boolean | BaseRoyaltyReport$kontorReportsArgs<ExtArgs>
    believeReports?: boolean | BaseRoyaltyReport$believeReportsArgs<ExtArgs>
    userReports?: boolean | BaseRoyaltyReport$userReportsArgs<ExtArgs>
    Transaction?: boolean | BaseRoyaltyReport$TransactionArgs<ExtArgs>
    _count?: boolean | BaseRoyaltyReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BaseRoyaltyReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    s3File?: boolean | BaseRoyaltyReport$s3FileArgs<ExtArgs>
  }
  export type BaseRoyaltyReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    s3File?: boolean | BaseRoyaltyReport$s3FileArgs<ExtArgs>
  }

  export type $BaseRoyaltyReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BaseRoyaltyReport"
    objects: {
      s3File: Prisma.$S3FilePayload<ExtArgs> | null
      kontorReports: Prisma.$KontorRoyaltyReportPayload<ExtArgs>[]
      believeReports: Prisma.$BelieveRoyaltyReportPayload<ExtArgs>[]
      userReports: Prisma.$UserRoyaltyReportPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      currency: $Enums.Currency
      distributor: $Enums.Distributor
      reportingMonth: string
      totalRoyalties: number
      totalEarnings: number
      debitState: $Enums.DebitState
      paidOn: Date | null
      s3FileId: number | null
    }, ExtArgs["result"]["baseRoyaltyReport"]>
    composites: {}
  }

  type BaseRoyaltyReportGetPayload<S extends boolean | null | undefined | BaseRoyaltyReportDefaultArgs> = $Result.GetResult<Prisma.$BaseRoyaltyReportPayload, S>

  type BaseRoyaltyReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BaseRoyaltyReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BaseRoyaltyReportCountAggregateInputType | true
    }

  export interface BaseRoyaltyReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BaseRoyaltyReport'], meta: { name: 'BaseRoyaltyReport' } }
    /**
     * Find zero or one BaseRoyaltyReport that matches the filter.
     * @param {BaseRoyaltyReportFindUniqueArgs} args - Arguments to find a BaseRoyaltyReport
     * @example
     * // Get one BaseRoyaltyReport
     * const baseRoyaltyReport = await prisma.baseRoyaltyReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BaseRoyaltyReportFindUniqueArgs>(args: SelectSubset<T, BaseRoyaltyReportFindUniqueArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BaseRoyaltyReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BaseRoyaltyReportFindUniqueOrThrowArgs} args - Arguments to find a BaseRoyaltyReport
     * @example
     * // Get one BaseRoyaltyReport
     * const baseRoyaltyReport = await prisma.baseRoyaltyReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BaseRoyaltyReportFindUniqueOrThrowArgs>(args: SelectSubset<T, BaseRoyaltyReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseRoyaltyReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseRoyaltyReportFindFirstArgs} args - Arguments to find a BaseRoyaltyReport
     * @example
     * // Get one BaseRoyaltyReport
     * const baseRoyaltyReport = await prisma.baseRoyaltyReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BaseRoyaltyReportFindFirstArgs>(args?: SelectSubset<T, BaseRoyaltyReportFindFirstArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseRoyaltyReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseRoyaltyReportFindFirstOrThrowArgs} args - Arguments to find a BaseRoyaltyReport
     * @example
     * // Get one BaseRoyaltyReport
     * const baseRoyaltyReport = await prisma.baseRoyaltyReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BaseRoyaltyReportFindFirstOrThrowArgs>(args?: SelectSubset<T, BaseRoyaltyReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BaseRoyaltyReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseRoyaltyReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BaseRoyaltyReports
     * const baseRoyaltyReports = await prisma.baseRoyaltyReport.findMany()
     * 
     * // Get first 10 BaseRoyaltyReports
     * const baseRoyaltyReports = await prisma.baseRoyaltyReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baseRoyaltyReportWithIdOnly = await prisma.baseRoyaltyReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BaseRoyaltyReportFindManyArgs>(args?: SelectSubset<T, BaseRoyaltyReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BaseRoyaltyReport.
     * @param {BaseRoyaltyReportCreateArgs} args - Arguments to create a BaseRoyaltyReport.
     * @example
     * // Create one BaseRoyaltyReport
     * const BaseRoyaltyReport = await prisma.baseRoyaltyReport.create({
     *   data: {
     *     // ... data to create a BaseRoyaltyReport
     *   }
     * })
     * 
     */
    create<T extends BaseRoyaltyReportCreateArgs>(args: SelectSubset<T, BaseRoyaltyReportCreateArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BaseRoyaltyReports.
     * @param {BaseRoyaltyReportCreateManyArgs} args - Arguments to create many BaseRoyaltyReports.
     * @example
     * // Create many BaseRoyaltyReports
     * const baseRoyaltyReport = await prisma.baseRoyaltyReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BaseRoyaltyReportCreateManyArgs>(args?: SelectSubset<T, BaseRoyaltyReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BaseRoyaltyReports and returns the data saved in the database.
     * @param {BaseRoyaltyReportCreateManyAndReturnArgs} args - Arguments to create many BaseRoyaltyReports.
     * @example
     * // Create many BaseRoyaltyReports
     * const baseRoyaltyReport = await prisma.baseRoyaltyReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BaseRoyaltyReports and only return the `id`
     * const baseRoyaltyReportWithIdOnly = await prisma.baseRoyaltyReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BaseRoyaltyReportCreateManyAndReturnArgs>(args?: SelectSubset<T, BaseRoyaltyReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BaseRoyaltyReport.
     * @param {BaseRoyaltyReportDeleteArgs} args - Arguments to delete one BaseRoyaltyReport.
     * @example
     * // Delete one BaseRoyaltyReport
     * const BaseRoyaltyReport = await prisma.baseRoyaltyReport.delete({
     *   where: {
     *     // ... filter to delete one BaseRoyaltyReport
     *   }
     * })
     * 
     */
    delete<T extends BaseRoyaltyReportDeleteArgs>(args: SelectSubset<T, BaseRoyaltyReportDeleteArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BaseRoyaltyReport.
     * @param {BaseRoyaltyReportUpdateArgs} args - Arguments to update one BaseRoyaltyReport.
     * @example
     * // Update one BaseRoyaltyReport
     * const baseRoyaltyReport = await prisma.baseRoyaltyReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BaseRoyaltyReportUpdateArgs>(args: SelectSubset<T, BaseRoyaltyReportUpdateArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BaseRoyaltyReports.
     * @param {BaseRoyaltyReportDeleteManyArgs} args - Arguments to filter BaseRoyaltyReports to delete.
     * @example
     * // Delete a few BaseRoyaltyReports
     * const { count } = await prisma.baseRoyaltyReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BaseRoyaltyReportDeleteManyArgs>(args?: SelectSubset<T, BaseRoyaltyReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseRoyaltyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseRoyaltyReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BaseRoyaltyReports
     * const baseRoyaltyReport = await prisma.baseRoyaltyReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BaseRoyaltyReportUpdateManyArgs>(args: SelectSubset<T, BaseRoyaltyReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseRoyaltyReports and returns the data updated in the database.
     * @param {BaseRoyaltyReportUpdateManyAndReturnArgs} args - Arguments to update many BaseRoyaltyReports.
     * @example
     * // Update many BaseRoyaltyReports
     * const baseRoyaltyReport = await prisma.baseRoyaltyReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BaseRoyaltyReports and only return the `id`
     * const baseRoyaltyReportWithIdOnly = await prisma.baseRoyaltyReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BaseRoyaltyReportUpdateManyAndReturnArgs>(args: SelectSubset<T, BaseRoyaltyReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BaseRoyaltyReport.
     * @param {BaseRoyaltyReportUpsertArgs} args - Arguments to update or create a BaseRoyaltyReport.
     * @example
     * // Update or create a BaseRoyaltyReport
     * const baseRoyaltyReport = await prisma.baseRoyaltyReport.upsert({
     *   create: {
     *     // ... data to create a BaseRoyaltyReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BaseRoyaltyReport we want to update
     *   }
     * })
     */
    upsert<T extends BaseRoyaltyReportUpsertArgs>(args: SelectSubset<T, BaseRoyaltyReportUpsertArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BaseRoyaltyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseRoyaltyReportCountArgs} args - Arguments to filter BaseRoyaltyReports to count.
     * @example
     * // Count the number of BaseRoyaltyReports
     * const count = await prisma.baseRoyaltyReport.count({
     *   where: {
     *     // ... the filter for the BaseRoyaltyReports we want to count
     *   }
     * })
    **/
    count<T extends BaseRoyaltyReportCountArgs>(
      args?: Subset<T, BaseRoyaltyReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaseRoyaltyReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BaseRoyaltyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseRoyaltyReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaseRoyaltyReportAggregateArgs>(args: Subset<T, BaseRoyaltyReportAggregateArgs>): Prisma.PrismaPromise<GetBaseRoyaltyReportAggregateType<T>>

    /**
     * Group by BaseRoyaltyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseRoyaltyReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaseRoyaltyReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaseRoyaltyReportGroupByArgs['orderBy'] }
        : { orderBy?: BaseRoyaltyReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaseRoyaltyReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaseRoyaltyReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BaseRoyaltyReport model
   */
  readonly fields: BaseRoyaltyReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BaseRoyaltyReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BaseRoyaltyReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    s3File<T extends BaseRoyaltyReport$s3FileArgs<ExtArgs> = {}>(args?: Subset<T, BaseRoyaltyReport$s3FileArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    kontorReports<T extends BaseRoyaltyReport$kontorReportsArgs<ExtArgs> = {}>(args?: Subset<T, BaseRoyaltyReport$kontorReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    believeReports<T extends BaseRoyaltyReport$believeReportsArgs<ExtArgs> = {}>(args?: Subset<T, BaseRoyaltyReport$believeReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userReports<T extends BaseRoyaltyReport$userReportsArgs<ExtArgs> = {}>(args?: Subset<T, BaseRoyaltyReport$userReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends BaseRoyaltyReport$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, BaseRoyaltyReport$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BaseRoyaltyReport model
   */
  interface BaseRoyaltyReportFieldRefs {
    readonly id: FieldRef<"BaseRoyaltyReport", 'Int'>
    readonly createdAt: FieldRef<"BaseRoyaltyReport", 'DateTime'>
    readonly updatedAt: FieldRef<"BaseRoyaltyReport", 'DateTime'>
    readonly currency: FieldRef<"BaseRoyaltyReport", 'Currency'>
    readonly distributor: FieldRef<"BaseRoyaltyReport", 'Distributor'>
    readonly reportingMonth: FieldRef<"BaseRoyaltyReport", 'String'>
    readonly totalRoyalties: FieldRef<"BaseRoyaltyReport", 'Float'>
    readonly totalEarnings: FieldRef<"BaseRoyaltyReport", 'Float'>
    readonly debitState: FieldRef<"BaseRoyaltyReport", 'DebitState'>
    readonly paidOn: FieldRef<"BaseRoyaltyReport", 'DateTime'>
    readonly s3FileId: FieldRef<"BaseRoyaltyReport", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BaseRoyaltyReport findUnique
   */
  export type BaseRoyaltyReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which BaseRoyaltyReport to fetch.
     */
    where: BaseRoyaltyReportWhereUniqueInput
  }

  /**
   * BaseRoyaltyReport findUniqueOrThrow
   */
  export type BaseRoyaltyReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which BaseRoyaltyReport to fetch.
     */
    where: BaseRoyaltyReportWhereUniqueInput
  }

  /**
   * BaseRoyaltyReport findFirst
   */
  export type BaseRoyaltyReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which BaseRoyaltyReport to fetch.
     */
    where?: BaseRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseRoyaltyReports to fetch.
     */
    orderBy?: BaseRoyaltyReportOrderByWithRelationInput | BaseRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseRoyaltyReports.
     */
    cursor?: BaseRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseRoyaltyReports.
     */
    distinct?: BaseRoyaltyReportScalarFieldEnum | BaseRoyaltyReportScalarFieldEnum[]
  }

  /**
   * BaseRoyaltyReport findFirstOrThrow
   */
  export type BaseRoyaltyReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which BaseRoyaltyReport to fetch.
     */
    where?: BaseRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseRoyaltyReports to fetch.
     */
    orderBy?: BaseRoyaltyReportOrderByWithRelationInput | BaseRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseRoyaltyReports.
     */
    cursor?: BaseRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseRoyaltyReports.
     */
    distinct?: BaseRoyaltyReportScalarFieldEnum | BaseRoyaltyReportScalarFieldEnum[]
  }

  /**
   * BaseRoyaltyReport findMany
   */
  export type BaseRoyaltyReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which BaseRoyaltyReports to fetch.
     */
    where?: BaseRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseRoyaltyReports to fetch.
     */
    orderBy?: BaseRoyaltyReportOrderByWithRelationInput | BaseRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BaseRoyaltyReports.
     */
    cursor?: BaseRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseRoyaltyReports.
     */
    skip?: number
    distinct?: BaseRoyaltyReportScalarFieldEnum | BaseRoyaltyReportScalarFieldEnum[]
  }

  /**
   * BaseRoyaltyReport create
   */
  export type BaseRoyaltyReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    /**
     * The data needed to create a BaseRoyaltyReport.
     */
    data: XOR<BaseRoyaltyReportCreateInput, BaseRoyaltyReportUncheckedCreateInput>
  }

  /**
   * BaseRoyaltyReport createMany
   */
  export type BaseRoyaltyReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BaseRoyaltyReports.
     */
    data: BaseRoyaltyReportCreateManyInput | BaseRoyaltyReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseRoyaltyReport createManyAndReturn
   */
  export type BaseRoyaltyReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * The data used to create many BaseRoyaltyReports.
     */
    data: BaseRoyaltyReportCreateManyInput | BaseRoyaltyReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BaseRoyaltyReport update
   */
  export type BaseRoyaltyReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    /**
     * The data needed to update a BaseRoyaltyReport.
     */
    data: XOR<BaseRoyaltyReportUpdateInput, BaseRoyaltyReportUncheckedUpdateInput>
    /**
     * Choose, which BaseRoyaltyReport to update.
     */
    where: BaseRoyaltyReportWhereUniqueInput
  }

  /**
   * BaseRoyaltyReport updateMany
   */
  export type BaseRoyaltyReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BaseRoyaltyReports.
     */
    data: XOR<BaseRoyaltyReportUpdateManyMutationInput, BaseRoyaltyReportUncheckedUpdateManyInput>
    /**
     * Filter which BaseRoyaltyReports to update
     */
    where?: BaseRoyaltyReportWhereInput
    /**
     * Limit how many BaseRoyaltyReports to update.
     */
    limit?: number
  }

  /**
   * BaseRoyaltyReport updateManyAndReturn
   */
  export type BaseRoyaltyReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * The data used to update BaseRoyaltyReports.
     */
    data: XOR<BaseRoyaltyReportUpdateManyMutationInput, BaseRoyaltyReportUncheckedUpdateManyInput>
    /**
     * Filter which BaseRoyaltyReports to update
     */
    where?: BaseRoyaltyReportWhereInput
    /**
     * Limit how many BaseRoyaltyReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BaseRoyaltyReport upsert
   */
  export type BaseRoyaltyReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    /**
     * The filter to search for the BaseRoyaltyReport to update in case it exists.
     */
    where: BaseRoyaltyReportWhereUniqueInput
    /**
     * In case the BaseRoyaltyReport found by the `where` argument doesn't exist, create a new BaseRoyaltyReport with this data.
     */
    create: XOR<BaseRoyaltyReportCreateInput, BaseRoyaltyReportUncheckedCreateInput>
    /**
     * In case the BaseRoyaltyReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BaseRoyaltyReportUpdateInput, BaseRoyaltyReportUncheckedUpdateInput>
  }

  /**
   * BaseRoyaltyReport delete
   */
  export type BaseRoyaltyReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter which BaseRoyaltyReport to delete.
     */
    where: BaseRoyaltyReportWhereUniqueInput
  }

  /**
   * BaseRoyaltyReport deleteMany
   */
  export type BaseRoyaltyReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseRoyaltyReports to delete
     */
    where?: BaseRoyaltyReportWhereInput
    /**
     * Limit how many BaseRoyaltyReports to delete.
     */
    limit?: number
  }

  /**
   * BaseRoyaltyReport.s3File
   */
  export type BaseRoyaltyReport$s3FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    where?: S3FileWhereInput
  }

  /**
   * BaseRoyaltyReport.kontorReports
   */
  export type BaseRoyaltyReport$kontorReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    where?: KontorRoyaltyReportWhereInput
    orderBy?: KontorRoyaltyReportOrderByWithRelationInput | KontorRoyaltyReportOrderByWithRelationInput[]
    cursor?: KontorRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KontorRoyaltyReportScalarFieldEnum | KontorRoyaltyReportScalarFieldEnum[]
  }

  /**
   * BaseRoyaltyReport.believeReports
   */
  export type BaseRoyaltyReport$believeReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    where?: BelieveRoyaltyReportWhereInput
    orderBy?: BelieveRoyaltyReportOrderByWithRelationInput | BelieveRoyaltyReportOrderByWithRelationInput[]
    cursor?: BelieveRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BelieveRoyaltyReportScalarFieldEnum | BelieveRoyaltyReportScalarFieldEnum[]
  }

  /**
   * BaseRoyaltyReport.userReports
   */
  export type BaseRoyaltyReport$userReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    where?: UserRoyaltyReportWhereInput
    orderBy?: UserRoyaltyReportOrderByWithRelationInput | UserRoyaltyReportOrderByWithRelationInput[]
    cursor?: UserRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoyaltyReportScalarFieldEnum | UserRoyaltyReportScalarFieldEnum[]
  }

  /**
   * BaseRoyaltyReport.Transaction
   */
  export type BaseRoyaltyReport$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * BaseRoyaltyReport without action
   */
  export type BaseRoyaltyReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
  }


  /**
   * Model UserRoyaltyReport
   */

  export type AggregateUserRoyaltyReport = {
    _count: UserRoyaltyReportCountAggregateOutputType | null
    _avg: UserRoyaltyReportAvgAggregateOutputType | null
    _sum: UserRoyaltyReportSumAggregateOutputType | null
    _min: UserRoyaltyReportMinAggregateOutputType | null
    _max: UserRoyaltyReportMaxAggregateOutputType | null
  }

  export type UserRoyaltyReportAvgAggregateOutputType = {
    id: number | null
    totalRoyalties: number | null
    s3FileId: number | null
    baseReportId: number | null
    clientId: number | null
  }

  export type UserRoyaltyReportSumAggregateOutputType = {
    id: number | null
    totalRoyalties: number | null
    s3FileId: number | null
    baseReportId: number | null
    clientId: number | null
  }

  export type UserRoyaltyReportMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: $Enums.Currency | null
    distributor: $Enums.Distributor | null
    reportingMonth: string | null
    totalRoyalties: number | null
    debitState: $Enums.DebitState | null
    paidOn: Date | null
    s3FileId: number | null
    baseReportId: number | null
    clientId: number | null
  }

  export type UserRoyaltyReportMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: $Enums.Currency | null
    distributor: $Enums.Distributor | null
    reportingMonth: string | null
    totalRoyalties: number | null
    debitState: $Enums.DebitState | null
    paidOn: Date | null
    s3FileId: number | null
    baseReportId: number | null
    clientId: number | null
  }

  export type UserRoyaltyReportCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    currency: number
    distributor: number
    reportingMonth: number
    totalRoyalties: number
    debitState: number
    paidOn: number
    s3FileId: number
    baseReportId: number
    clientId: number
    _all: number
  }


  export type UserRoyaltyReportAvgAggregateInputType = {
    id?: true
    totalRoyalties?: true
    s3FileId?: true
    baseReportId?: true
    clientId?: true
  }

  export type UserRoyaltyReportSumAggregateInputType = {
    id?: true
    totalRoyalties?: true
    s3FileId?: true
    baseReportId?: true
    clientId?: true
  }

  export type UserRoyaltyReportMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    distributor?: true
    reportingMonth?: true
    totalRoyalties?: true
    debitState?: true
    paidOn?: true
    s3FileId?: true
    baseReportId?: true
    clientId?: true
  }

  export type UserRoyaltyReportMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    distributor?: true
    reportingMonth?: true
    totalRoyalties?: true
    debitState?: true
    paidOn?: true
    s3FileId?: true
    baseReportId?: true
    clientId?: true
  }

  export type UserRoyaltyReportCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    distributor?: true
    reportingMonth?: true
    totalRoyalties?: true
    debitState?: true
    paidOn?: true
    s3FileId?: true
    baseReportId?: true
    clientId?: true
    _all?: true
  }

  export type UserRoyaltyReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoyaltyReport to aggregate.
     */
    where?: UserRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoyaltyReports to fetch.
     */
    orderBy?: UserRoyaltyReportOrderByWithRelationInput | UserRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoyaltyReports
    **/
    _count?: true | UserRoyaltyReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoyaltyReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoyaltyReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoyaltyReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoyaltyReportMaxAggregateInputType
  }

  export type GetUserRoyaltyReportAggregateType<T extends UserRoyaltyReportAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoyaltyReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoyaltyReport[P]>
      : GetScalarType<T[P], AggregateUserRoyaltyReport[P]>
  }




  export type UserRoyaltyReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoyaltyReportWhereInput
    orderBy?: UserRoyaltyReportOrderByWithAggregationInput | UserRoyaltyReportOrderByWithAggregationInput[]
    by: UserRoyaltyReportScalarFieldEnum[] | UserRoyaltyReportScalarFieldEnum
    having?: UserRoyaltyReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoyaltyReportCountAggregateInputType | true
    _avg?: UserRoyaltyReportAvgAggregateInputType
    _sum?: UserRoyaltyReportSumAggregateInputType
    _min?: UserRoyaltyReportMinAggregateInputType
    _max?: UserRoyaltyReportMaxAggregateInputType
  }

  export type UserRoyaltyReportGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    currency: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState: $Enums.DebitState
    paidOn: Date | null
    s3FileId: number | null
    baseReportId: number | null
    clientId: number | null
    _count: UserRoyaltyReportCountAggregateOutputType | null
    _avg: UserRoyaltyReportAvgAggregateOutputType | null
    _sum: UserRoyaltyReportSumAggregateOutputType | null
    _min: UserRoyaltyReportMinAggregateOutputType | null
    _max: UserRoyaltyReportMaxAggregateOutputType | null
  }

  type GetUserRoyaltyReportGroupByPayload<T extends UserRoyaltyReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoyaltyReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoyaltyReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoyaltyReportGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoyaltyReportGroupByOutputType[P]>
        }
      >
    >


  export type UserRoyaltyReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    totalRoyalties?: boolean
    debitState?: boolean
    paidOn?: boolean
    s3FileId?: boolean
    baseReportId?: boolean
    clientId?: boolean
    s3File?: boolean | UserRoyaltyReport$s3FileArgs<ExtArgs>
    kontorReports?: boolean | UserRoyaltyReport$kontorReportsArgs<ExtArgs>
    believeReports?: boolean | UserRoyaltyReport$believeReportsArgs<ExtArgs>
    baseReport?: boolean | UserRoyaltyReport$baseReportArgs<ExtArgs>
    client?: boolean | UserRoyaltyReport$clientArgs<ExtArgs>
    transactions?: boolean | UserRoyaltyReport$transactionsArgs<ExtArgs>
    _count?: boolean | UserRoyaltyReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoyaltyReport"]>

  export type UserRoyaltyReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    totalRoyalties?: boolean
    debitState?: boolean
    paidOn?: boolean
    s3FileId?: boolean
    baseReportId?: boolean
    clientId?: boolean
    s3File?: boolean | UserRoyaltyReport$s3FileArgs<ExtArgs>
    baseReport?: boolean | UserRoyaltyReport$baseReportArgs<ExtArgs>
    client?: boolean | UserRoyaltyReport$clientArgs<ExtArgs>
  }, ExtArgs["result"]["userRoyaltyReport"]>

  export type UserRoyaltyReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    totalRoyalties?: boolean
    debitState?: boolean
    paidOn?: boolean
    s3FileId?: boolean
    baseReportId?: boolean
    clientId?: boolean
    s3File?: boolean | UserRoyaltyReport$s3FileArgs<ExtArgs>
    baseReport?: boolean | UserRoyaltyReport$baseReportArgs<ExtArgs>
    client?: boolean | UserRoyaltyReport$clientArgs<ExtArgs>
  }, ExtArgs["result"]["userRoyaltyReport"]>

  export type UserRoyaltyReportSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    totalRoyalties?: boolean
    debitState?: boolean
    paidOn?: boolean
    s3FileId?: boolean
    baseReportId?: boolean
    clientId?: boolean
  }

  export type UserRoyaltyReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "currency" | "distributor" | "reportingMonth" | "totalRoyalties" | "debitState" | "paidOn" | "s3FileId" | "baseReportId" | "clientId", ExtArgs["result"]["userRoyaltyReport"]>
  export type UserRoyaltyReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    s3File?: boolean | UserRoyaltyReport$s3FileArgs<ExtArgs>
    kontorReports?: boolean | UserRoyaltyReport$kontorReportsArgs<ExtArgs>
    believeReports?: boolean | UserRoyaltyReport$believeReportsArgs<ExtArgs>
    baseReport?: boolean | UserRoyaltyReport$baseReportArgs<ExtArgs>
    client?: boolean | UserRoyaltyReport$clientArgs<ExtArgs>
    transactions?: boolean | UserRoyaltyReport$transactionsArgs<ExtArgs>
    _count?: boolean | UserRoyaltyReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserRoyaltyReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    s3File?: boolean | UserRoyaltyReport$s3FileArgs<ExtArgs>
    baseReport?: boolean | UserRoyaltyReport$baseReportArgs<ExtArgs>
    client?: boolean | UserRoyaltyReport$clientArgs<ExtArgs>
  }
  export type UserRoyaltyReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    s3File?: boolean | UserRoyaltyReport$s3FileArgs<ExtArgs>
    baseReport?: boolean | UserRoyaltyReport$baseReportArgs<ExtArgs>
    client?: boolean | UserRoyaltyReport$clientArgs<ExtArgs>
  }

  export type $UserRoyaltyReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRoyaltyReport"
    objects: {
      s3File: Prisma.$S3FilePayload<ExtArgs> | null
      kontorReports: Prisma.$KontorRoyaltyReportPayload<ExtArgs>[]
      believeReports: Prisma.$BelieveRoyaltyReportPayload<ExtArgs>[]
      baseReport: Prisma.$BaseRoyaltyReportPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      currency: $Enums.Currency
      distributor: $Enums.Distributor
      reportingMonth: string
      totalRoyalties: number
      debitState: $Enums.DebitState
      paidOn: Date | null
      s3FileId: number | null
      baseReportId: number | null
      clientId: number | null
    }, ExtArgs["result"]["userRoyaltyReport"]>
    composites: {}
  }

  type UserRoyaltyReportGetPayload<S extends boolean | null | undefined | UserRoyaltyReportDefaultArgs> = $Result.GetResult<Prisma.$UserRoyaltyReportPayload, S>

  type UserRoyaltyReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoyaltyReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoyaltyReportCountAggregateInputType | true
    }

  export interface UserRoyaltyReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRoyaltyReport'], meta: { name: 'UserRoyaltyReport' } }
    /**
     * Find zero or one UserRoyaltyReport that matches the filter.
     * @param {UserRoyaltyReportFindUniqueArgs} args - Arguments to find a UserRoyaltyReport
     * @example
     * // Get one UserRoyaltyReport
     * const userRoyaltyReport = await prisma.userRoyaltyReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoyaltyReportFindUniqueArgs>(args: SelectSubset<T, UserRoyaltyReportFindUniqueArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRoyaltyReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoyaltyReportFindUniqueOrThrowArgs} args - Arguments to find a UserRoyaltyReport
     * @example
     * // Get one UserRoyaltyReport
     * const userRoyaltyReport = await prisma.userRoyaltyReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoyaltyReportFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoyaltyReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRoyaltyReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoyaltyReportFindFirstArgs} args - Arguments to find a UserRoyaltyReport
     * @example
     * // Get one UserRoyaltyReport
     * const userRoyaltyReport = await prisma.userRoyaltyReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoyaltyReportFindFirstArgs>(args?: SelectSubset<T, UserRoyaltyReportFindFirstArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRoyaltyReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoyaltyReportFindFirstOrThrowArgs} args - Arguments to find a UserRoyaltyReport
     * @example
     * // Get one UserRoyaltyReport
     * const userRoyaltyReport = await prisma.userRoyaltyReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoyaltyReportFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoyaltyReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoyaltyReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoyaltyReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoyaltyReports
     * const userRoyaltyReports = await prisma.userRoyaltyReport.findMany()
     * 
     * // Get first 10 UserRoyaltyReports
     * const userRoyaltyReports = await prisma.userRoyaltyReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoyaltyReportWithIdOnly = await prisma.userRoyaltyReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoyaltyReportFindManyArgs>(args?: SelectSubset<T, UserRoyaltyReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRoyaltyReport.
     * @param {UserRoyaltyReportCreateArgs} args - Arguments to create a UserRoyaltyReport.
     * @example
     * // Create one UserRoyaltyReport
     * const UserRoyaltyReport = await prisma.userRoyaltyReport.create({
     *   data: {
     *     // ... data to create a UserRoyaltyReport
     *   }
     * })
     * 
     */
    create<T extends UserRoyaltyReportCreateArgs>(args: SelectSubset<T, UserRoyaltyReportCreateArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoyaltyReports.
     * @param {UserRoyaltyReportCreateManyArgs} args - Arguments to create many UserRoyaltyReports.
     * @example
     * // Create many UserRoyaltyReports
     * const userRoyaltyReport = await prisma.userRoyaltyReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoyaltyReportCreateManyArgs>(args?: SelectSubset<T, UserRoyaltyReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoyaltyReports and returns the data saved in the database.
     * @param {UserRoyaltyReportCreateManyAndReturnArgs} args - Arguments to create many UserRoyaltyReports.
     * @example
     * // Create many UserRoyaltyReports
     * const userRoyaltyReport = await prisma.userRoyaltyReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoyaltyReports and only return the `id`
     * const userRoyaltyReportWithIdOnly = await prisma.userRoyaltyReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoyaltyReportCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoyaltyReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRoyaltyReport.
     * @param {UserRoyaltyReportDeleteArgs} args - Arguments to delete one UserRoyaltyReport.
     * @example
     * // Delete one UserRoyaltyReport
     * const UserRoyaltyReport = await prisma.userRoyaltyReport.delete({
     *   where: {
     *     // ... filter to delete one UserRoyaltyReport
     *   }
     * })
     * 
     */
    delete<T extends UserRoyaltyReportDeleteArgs>(args: SelectSubset<T, UserRoyaltyReportDeleteArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRoyaltyReport.
     * @param {UserRoyaltyReportUpdateArgs} args - Arguments to update one UserRoyaltyReport.
     * @example
     * // Update one UserRoyaltyReport
     * const userRoyaltyReport = await prisma.userRoyaltyReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoyaltyReportUpdateArgs>(args: SelectSubset<T, UserRoyaltyReportUpdateArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoyaltyReports.
     * @param {UserRoyaltyReportDeleteManyArgs} args - Arguments to filter UserRoyaltyReports to delete.
     * @example
     * // Delete a few UserRoyaltyReports
     * const { count } = await prisma.userRoyaltyReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoyaltyReportDeleteManyArgs>(args?: SelectSubset<T, UserRoyaltyReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoyaltyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoyaltyReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoyaltyReports
     * const userRoyaltyReport = await prisma.userRoyaltyReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoyaltyReportUpdateManyArgs>(args: SelectSubset<T, UserRoyaltyReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoyaltyReports and returns the data updated in the database.
     * @param {UserRoyaltyReportUpdateManyAndReturnArgs} args - Arguments to update many UserRoyaltyReports.
     * @example
     * // Update many UserRoyaltyReports
     * const userRoyaltyReport = await prisma.userRoyaltyReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoyaltyReports and only return the `id`
     * const userRoyaltyReportWithIdOnly = await prisma.userRoyaltyReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoyaltyReportUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoyaltyReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRoyaltyReport.
     * @param {UserRoyaltyReportUpsertArgs} args - Arguments to update or create a UserRoyaltyReport.
     * @example
     * // Update or create a UserRoyaltyReport
     * const userRoyaltyReport = await prisma.userRoyaltyReport.upsert({
     *   create: {
     *     // ... data to create a UserRoyaltyReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoyaltyReport we want to update
     *   }
     * })
     */
    upsert<T extends UserRoyaltyReportUpsertArgs>(args: SelectSubset<T, UserRoyaltyReportUpsertArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoyaltyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoyaltyReportCountArgs} args - Arguments to filter UserRoyaltyReports to count.
     * @example
     * // Count the number of UserRoyaltyReports
     * const count = await prisma.userRoyaltyReport.count({
     *   where: {
     *     // ... the filter for the UserRoyaltyReports we want to count
     *   }
     * })
    **/
    count<T extends UserRoyaltyReportCountArgs>(
      args?: Subset<T, UserRoyaltyReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoyaltyReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoyaltyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoyaltyReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoyaltyReportAggregateArgs>(args: Subset<T, UserRoyaltyReportAggregateArgs>): Prisma.PrismaPromise<GetUserRoyaltyReportAggregateType<T>>

    /**
     * Group by UserRoyaltyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoyaltyReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoyaltyReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoyaltyReportGroupByArgs['orderBy'] }
        : { orderBy?: UserRoyaltyReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoyaltyReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoyaltyReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRoyaltyReport model
   */
  readonly fields: UserRoyaltyReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoyaltyReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoyaltyReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    s3File<T extends UserRoyaltyReport$s3FileArgs<ExtArgs> = {}>(args?: Subset<T, UserRoyaltyReport$s3FileArgs<ExtArgs>>): Prisma__S3FileClient<$Result.GetResult<Prisma.$S3FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    kontorReports<T extends UserRoyaltyReport$kontorReportsArgs<ExtArgs> = {}>(args?: Subset<T, UserRoyaltyReport$kontorReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    believeReports<T extends UserRoyaltyReport$believeReportsArgs<ExtArgs> = {}>(args?: Subset<T, UserRoyaltyReport$believeReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    baseReport<T extends UserRoyaltyReport$baseReportArgs<ExtArgs> = {}>(args?: Subset<T, UserRoyaltyReport$baseReportArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends UserRoyaltyReport$clientArgs<ExtArgs> = {}>(args?: Subset<T, UserRoyaltyReport$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends UserRoyaltyReport$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, UserRoyaltyReport$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRoyaltyReport model
   */
  interface UserRoyaltyReportFieldRefs {
    readonly id: FieldRef<"UserRoyaltyReport", 'Int'>
    readonly createdAt: FieldRef<"UserRoyaltyReport", 'DateTime'>
    readonly updatedAt: FieldRef<"UserRoyaltyReport", 'DateTime'>
    readonly currency: FieldRef<"UserRoyaltyReport", 'Currency'>
    readonly distributor: FieldRef<"UserRoyaltyReport", 'Distributor'>
    readonly reportingMonth: FieldRef<"UserRoyaltyReport", 'String'>
    readonly totalRoyalties: FieldRef<"UserRoyaltyReport", 'Float'>
    readonly debitState: FieldRef<"UserRoyaltyReport", 'DebitState'>
    readonly paidOn: FieldRef<"UserRoyaltyReport", 'DateTime'>
    readonly s3FileId: FieldRef<"UserRoyaltyReport", 'Int'>
    readonly baseReportId: FieldRef<"UserRoyaltyReport", 'Int'>
    readonly clientId: FieldRef<"UserRoyaltyReport", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserRoyaltyReport findUnique
   */
  export type UserRoyaltyReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which UserRoyaltyReport to fetch.
     */
    where: UserRoyaltyReportWhereUniqueInput
  }

  /**
   * UserRoyaltyReport findUniqueOrThrow
   */
  export type UserRoyaltyReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which UserRoyaltyReport to fetch.
     */
    where: UserRoyaltyReportWhereUniqueInput
  }

  /**
   * UserRoyaltyReport findFirst
   */
  export type UserRoyaltyReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which UserRoyaltyReport to fetch.
     */
    where?: UserRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoyaltyReports to fetch.
     */
    orderBy?: UserRoyaltyReportOrderByWithRelationInput | UserRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoyaltyReports.
     */
    cursor?: UserRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoyaltyReports.
     */
    distinct?: UserRoyaltyReportScalarFieldEnum | UserRoyaltyReportScalarFieldEnum[]
  }

  /**
   * UserRoyaltyReport findFirstOrThrow
   */
  export type UserRoyaltyReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which UserRoyaltyReport to fetch.
     */
    where?: UserRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoyaltyReports to fetch.
     */
    orderBy?: UserRoyaltyReportOrderByWithRelationInput | UserRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoyaltyReports.
     */
    cursor?: UserRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoyaltyReports.
     */
    distinct?: UserRoyaltyReportScalarFieldEnum | UserRoyaltyReportScalarFieldEnum[]
  }

  /**
   * UserRoyaltyReport findMany
   */
  export type UserRoyaltyReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which UserRoyaltyReports to fetch.
     */
    where?: UserRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoyaltyReports to fetch.
     */
    orderBy?: UserRoyaltyReportOrderByWithRelationInput | UserRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoyaltyReports.
     */
    cursor?: UserRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoyaltyReports.
     */
    skip?: number
    distinct?: UserRoyaltyReportScalarFieldEnum | UserRoyaltyReportScalarFieldEnum[]
  }

  /**
   * UserRoyaltyReport create
   */
  export type UserRoyaltyReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRoyaltyReport.
     */
    data: XOR<UserRoyaltyReportCreateInput, UserRoyaltyReportUncheckedCreateInput>
  }

  /**
   * UserRoyaltyReport createMany
   */
  export type UserRoyaltyReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoyaltyReports.
     */
    data: UserRoyaltyReportCreateManyInput | UserRoyaltyReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRoyaltyReport createManyAndReturn
   */
  export type UserRoyaltyReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoyaltyReports.
     */
    data: UserRoyaltyReportCreateManyInput | UserRoyaltyReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRoyaltyReport update
   */
  export type UserRoyaltyReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRoyaltyReport.
     */
    data: XOR<UserRoyaltyReportUpdateInput, UserRoyaltyReportUncheckedUpdateInput>
    /**
     * Choose, which UserRoyaltyReport to update.
     */
    where: UserRoyaltyReportWhereUniqueInput
  }

  /**
   * UserRoyaltyReport updateMany
   */
  export type UserRoyaltyReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoyaltyReports.
     */
    data: XOR<UserRoyaltyReportUpdateManyMutationInput, UserRoyaltyReportUncheckedUpdateManyInput>
    /**
     * Filter which UserRoyaltyReports to update
     */
    where?: UserRoyaltyReportWhereInput
    /**
     * Limit how many UserRoyaltyReports to update.
     */
    limit?: number
  }

  /**
   * UserRoyaltyReport updateManyAndReturn
   */
  export type UserRoyaltyReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * The data used to update UserRoyaltyReports.
     */
    data: XOR<UserRoyaltyReportUpdateManyMutationInput, UserRoyaltyReportUncheckedUpdateManyInput>
    /**
     * Filter which UserRoyaltyReports to update
     */
    where?: UserRoyaltyReportWhereInput
    /**
     * Limit how many UserRoyaltyReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRoyaltyReport upsert
   */
  export type UserRoyaltyReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRoyaltyReport to update in case it exists.
     */
    where: UserRoyaltyReportWhereUniqueInput
    /**
     * In case the UserRoyaltyReport found by the `where` argument doesn't exist, create a new UserRoyaltyReport with this data.
     */
    create: XOR<UserRoyaltyReportCreateInput, UserRoyaltyReportUncheckedCreateInput>
    /**
     * In case the UserRoyaltyReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoyaltyReportUpdateInput, UserRoyaltyReportUncheckedUpdateInput>
  }

  /**
   * UserRoyaltyReport delete
   */
  export type UserRoyaltyReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter which UserRoyaltyReport to delete.
     */
    where: UserRoyaltyReportWhereUniqueInput
  }

  /**
   * UserRoyaltyReport deleteMany
   */
  export type UserRoyaltyReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoyaltyReports to delete
     */
    where?: UserRoyaltyReportWhereInput
    /**
     * Limit how many UserRoyaltyReports to delete.
     */
    limit?: number
  }

  /**
   * UserRoyaltyReport.s3File
   */
  export type UserRoyaltyReport$s3FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the S3File
     */
    select?: S3FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the S3File
     */
    omit?: S3FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: S3FileInclude<ExtArgs> | null
    where?: S3FileWhereInput
  }

  /**
   * UserRoyaltyReport.kontorReports
   */
  export type UserRoyaltyReport$kontorReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    where?: KontorRoyaltyReportWhereInput
    orderBy?: KontorRoyaltyReportOrderByWithRelationInput | KontorRoyaltyReportOrderByWithRelationInput[]
    cursor?: KontorRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KontorRoyaltyReportScalarFieldEnum | KontorRoyaltyReportScalarFieldEnum[]
  }

  /**
   * UserRoyaltyReport.believeReports
   */
  export type UserRoyaltyReport$believeReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    where?: BelieveRoyaltyReportWhereInput
    orderBy?: BelieveRoyaltyReportOrderByWithRelationInput | BelieveRoyaltyReportOrderByWithRelationInput[]
    cursor?: BelieveRoyaltyReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BelieveRoyaltyReportScalarFieldEnum | BelieveRoyaltyReportScalarFieldEnum[]
  }

  /**
   * UserRoyaltyReport.baseReport
   */
  export type UserRoyaltyReport$baseReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    where?: BaseRoyaltyReportWhereInput
  }

  /**
   * UserRoyaltyReport.client
   */
  export type UserRoyaltyReport$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * UserRoyaltyReport.transactions
   */
  export type UserRoyaltyReport$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * UserRoyaltyReport without action
   */
  export type UserRoyaltyReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
  }


  /**
   * Model KontorRoyaltyReport
   */

  export type AggregateKontorRoyaltyReport = {
    _count: KontorRoyaltyReportCountAggregateOutputType | null
    _avg: KontorRoyaltyReportAvgAggregateOutputType | null
    _sum: KontorRoyaltyReportSumAggregateOutputType | null
    _min: KontorRoyaltyReportMinAggregateOutputType | null
    _max: KontorRoyaltyReportMaxAggregateOutputType | null
  }

  export type KontorRoyaltyReportAvgAggregateOutputType = {
    id: number | null
    labelId: number | null
    royalties: Decimal | null
    units: number | null
    cmg_clientRate: Decimal | null
    cmg_netRevenue: Decimal | null
    baseReportId: number | null
    userReportId: number | null
    importedReportId: number | null
  }

  export type KontorRoyaltyReportSumAggregateOutputType = {
    id: number | null
    labelId: number | null
    royalties: Decimal | null
    units: number | null
    cmg_clientRate: Decimal | null
    cmg_netRevenue: Decimal | null
    baseReportId: number | null
    userReportId: number | null
    importedReportId: number | null
  }

  export type KontorRoyaltyReportMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: $Enums.Currency | null
    labelId: number | null
    reportingMonth: string | null
    salesMonth: string | null
    store: string | null
    chType: string | null
    channelId: string | null
    country: string | null
    labelName: string | null
    productType: string | null
    productTitle: string | null
    productArtist: string | null
    ean: string | null
    isrc: string | null
    grid: string | null
    articleNo: string | null
    royalties: Decimal | null
    units: number | null
    cmg_clientRate: Decimal | null
    cmg_netRevenue: Decimal | null
    baseReportId: number | null
    userReportId: number | null
    importedReportId: number | null
  }

  export type KontorRoyaltyReportMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: $Enums.Currency | null
    labelId: number | null
    reportingMonth: string | null
    salesMonth: string | null
    store: string | null
    chType: string | null
    channelId: string | null
    country: string | null
    labelName: string | null
    productType: string | null
    productTitle: string | null
    productArtist: string | null
    ean: string | null
    isrc: string | null
    grid: string | null
    articleNo: string | null
    royalties: Decimal | null
    units: number | null
    cmg_clientRate: Decimal | null
    cmg_netRevenue: Decimal | null
    baseReportId: number | null
    userReportId: number | null
    importedReportId: number | null
  }

  export type KontorRoyaltyReportCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    currency: number
    labelId: number
    reportingMonth: number
    salesMonth: number
    store: number
    chType: number
    channelId: number
    country: number
    labelName: number
    productType: number
    productTitle: number
    productArtist: number
    ean: number
    isrc: number
    grid: number
    articleNo: number
    royalties: number
    units: number
    cmg_clientRate: number
    cmg_netRevenue: number
    baseReportId: number
    userReportId: number
    importedReportId: number
    _all: number
  }


  export type KontorRoyaltyReportAvgAggregateInputType = {
    id?: true
    labelId?: true
    royalties?: true
    units?: true
    cmg_clientRate?: true
    cmg_netRevenue?: true
    baseReportId?: true
    userReportId?: true
    importedReportId?: true
  }

  export type KontorRoyaltyReportSumAggregateInputType = {
    id?: true
    labelId?: true
    royalties?: true
    units?: true
    cmg_clientRate?: true
    cmg_netRevenue?: true
    baseReportId?: true
    userReportId?: true
    importedReportId?: true
  }

  export type KontorRoyaltyReportMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    labelId?: true
    reportingMonth?: true
    salesMonth?: true
    store?: true
    chType?: true
    channelId?: true
    country?: true
    labelName?: true
    productType?: true
    productTitle?: true
    productArtist?: true
    ean?: true
    isrc?: true
    grid?: true
    articleNo?: true
    royalties?: true
    units?: true
    cmg_clientRate?: true
    cmg_netRevenue?: true
    baseReportId?: true
    userReportId?: true
    importedReportId?: true
  }

  export type KontorRoyaltyReportMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    labelId?: true
    reportingMonth?: true
    salesMonth?: true
    store?: true
    chType?: true
    channelId?: true
    country?: true
    labelName?: true
    productType?: true
    productTitle?: true
    productArtist?: true
    ean?: true
    isrc?: true
    grid?: true
    articleNo?: true
    royalties?: true
    units?: true
    cmg_clientRate?: true
    cmg_netRevenue?: true
    baseReportId?: true
    userReportId?: true
    importedReportId?: true
  }

  export type KontorRoyaltyReportCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    labelId?: true
    reportingMonth?: true
    salesMonth?: true
    store?: true
    chType?: true
    channelId?: true
    country?: true
    labelName?: true
    productType?: true
    productTitle?: true
    productArtist?: true
    ean?: true
    isrc?: true
    grid?: true
    articleNo?: true
    royalties?: true
    units?: true
    cmg_clientRate?: true
    cmg_netRevenue?: true
    baseReportId?: true
    userReportId?: true
    importedReportId?: true
    _all?: true
  }

  export type KontorRoyaltyReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KontorRoyaltyReport to aggregate.
     */
    where?: KontorRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KontorRoyaltyReports to fetch.
     */
    orderBy?: KontorRoyaltyReportOrderByWithRelationInput | KontorRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KontorRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KontorRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KontorRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KontorRoyaltyReports
    **/
    _count?: true | KontorRoyaltyReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KontorRoyaltyReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KontorRoyaltyReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KontorRoyaltyReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KontorRoyaltyReportMaxAggregateInputType
  }

  export type GetKontorRoyaltyReportAggregateType<T extends KontorRoyaltyReportAggregateArgs> = {
        [P in keyof T & keyof AggregateKontorRoyaltyReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKontorRoyaltyReport[P]>
      : GetScalarType<T[P], AggregateKontorRoyaltyReport[P]>
  }




  export type KontorRoyaltyReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KontorRoyaltyReportWhereInput
    orderBy?: KontorRoyaltyReportOrderByWithAggregationInput | KontorRoyaltyReportOrderByWithAggregationInput[]
    by: KontorRoyaltyReportScalarFieldEnum[] | KontorRoyaltyReportScalarFieldEnum
    having?: KontorRoyaltyReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KontorRoyaltyReportCountAggregateInputType | true
    _avg?: KontorRoyaltyReportAvgAggregateInputType
    _sum?: KontorRoyaltyReportSumAggregateInputType
    _min?: KontorRoyaltyReportMinAggregateInputType
    _max?: KontorRoyaltyReportMaxAggregateInputType
  }

  export type KontorRoyaltyReportGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    currency: $Enums.Currency
    labelId: number | null
    reportingMonth: string
    salesMonth: string
    store: string
    chType: string | null
    channelId: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo: string | null
    royalties: Decimal
    units: number
    cmg_clientRate: Decimal | null
    cmg_netRevenue: Decimal | null
    baseReportId: number | null
    userReportId: number | null
    importedReportId: number | null
    _count: KontorRoyaltyReportCountAggregateOutputType | null
    _avg: KontorRoyaltyReportAvgAggregateOutputType | null
    _sum: KontorRoyaltyReportSumAggregateOutputType | null
    _min: KontorRoyaltyReportMinAggregateOutputType | null
    _max: KontorRoyaltyReportMaxAggregateOutputType | null
  }

  type GetKontorRoyaltyReportGroupByPayload<T extends KontorRoyaltyReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KontorRoyaltyReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KontorRoyaltyReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KontorRoyaltyReportGroupByOutputType[P]>
            : GetScalarType<T[P], KontorRoyaltyReportGroupByOutputType[P]>
        }
      >
    >


  export type KontorRoyaltyReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    labelId?: boolean
    reportingMonth?: boolean
    salesMonth?: boolean
    store?: boolean
    chType?: boolean
    channelId?: boolean
    country?: boolean
    labelName?: boolean
    productType?: boolean
    productTitle?: boolean
    productArtist?: boolean
    ean?: boolean
    isrc?: boolean
    grid?: boolean
    articleNo?: boolean
    royalties?: boolean
    units?: boolean
    cmg_clientRate?: boolean
    cmg_netRevenue?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    importedReportId?: boolean
    label?: boolean | KontorRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | KontorRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | KontorRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | KontorRoyaltyReport$importedReportArgs<ExtArgs>
  }, ExtArgs["result"]["kontorRoyaltyReport"]>

  export type KontorRoyaltyReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    labelId?: boolean
    reportingMonth?: boolean
    salesMonth?: boolean
    store?: boolean
    chType?: boolean
    channelId?: boolean
    country?: boolean
    labelName?: boolean
    productType?: boolean
    productTitle?: boolean
    productArtist?: boolean
    ean?: boolean
    isrc?: boolean
    grid?: boolean
    articleNo?: boolean
    royalties?: boolean
    units?: boolean
    cmg_clientRate?: boolean
    cmg_netRevenue?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    importedReportId?: boolean
    label?: boolean | KontorRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | KontorRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | KontorRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | KontorRoyaltyReport$importedReportArgs<ExtArgs>
  }, ExtArgs["result"]["kontorRoyaltyReport"]>

  export type KontorRoyaltyReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    labelId?: boolean
    reportingMonth?: boolean
    salesMonth?: boolean
    store?: boolean
    chType?: boolean
    channelId?: boolean
    country?: boolean
    labelName?: boolean
    productType?: boolean
    productTitle?: boolean
    productArtist?: boolean
    ean?: boolean
    isrc?: boolean
    grid?: boolean
    articleNo?: boolean
    royalties?: boolean
    units?: boolean
    cmg_clientRate?: boolean
    cmg_netRevenue?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    importedReportId?: boolean
    label?: boolean | KontorRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | KontorRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | KontorRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | KontorRoyaltyReport$importedReportArgs<ExtArgs>
  }, ExtArgs["result"]["kontorRoyaltyReport"]>

  export type KontorRoyaltyReportSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    labelId?: boolean
    reportingMonth?: boolean
    salesMonth?: boolean
    store?: boolean
    chType?: boolean
    channelId?: boolean
    country?: boolean
    labelName?: boolean
    productType?: boolean
    productTitle?: boolean
    productArtist?: boolean
    ean?: boolean
    isrc?: boolean
    grid?: boolean
    articleNo?: boolean
    royalties?: boolean
    units?: boolean
    cmg_clientRate?: boolean
    cmg_netRevenue?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    importedReportId?: boolean
  }

  export type KontorRoyaltyReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "currency" | "labelId" | "reportingMonth" | "salesMonth" | "store" | "chType" | "channelId" | "country" | "labelName" | "productType" | "productTitle" | "productArtist" | "ean" | "isrc" | "grid" | "articleNo" | "royalties" | "units" | "cmg_clientRate" | "cmg_netRevenue" | "baseReportId" | "userReportId" | "importedReportId", ExtArgs["result"]["kontorRoyaltyReport"]>
  export type KontorRoyaltyReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    label?: boolean | KontorRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | KontorRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | KontorRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | KontorRoyaltyReport$importedReportArgs<ExtArgs>
  }
  export type KontorRoyaltyReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    label?: boolean | KontorRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | KontorRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | KontorRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | KontorRoyaltyReport$importedReportArgs<ExtArgs>
  }
  export type KontorRoyaltyReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    label?: boolean | KontorRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | KontorRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | KontorRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | KontorRoyaltyReport$importedReportArgs<ExtArgs>
  }

  export type $KontorRoyaltyReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KontorRoyaltyReport"
    objects: {
      label: Prisma.$LabelPayload<ExtArgs> | null
      baseReport: Prisma.$BaseRoyaltyReportPayload<ExtArgs> | null
      userReport: Prisma.$UserRoyaltyReportPayload<ExtArgs> | null
      importedReport: Prisma.$ImportedRoyaltyReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      currency: $Enums.Currency
      labelId: number | null
      reportingMonth: string
      salesMonth: string
      store: string
      chType: string | null
      channelId: string | null
      country: string
      labelName: string
      productType: string
      productTitle: string
      productArtist: string
      ean: string
      isrc: string
      grid: string
      articleNo: string | null
      royalties: Prisma.Decimal
      units: number
      cmg_clientRate: Prisma.Decimal | null
      cmg_netRevenue: Prisma.Decimal | null
      baseReportId: number | null
      userReportId: number | null
      importedReportId: number | null
    }, ExtArgs["result"]["kontorRoyaltyReport"]>
    composites: {}
  }

  type KontorRoyaltyReportGetPayload<S extends boolean | null | undefined | KontorRoyaltyReportDefaultArgs> = $Result.GetResult<Prisma.$KontorRoyaltyReportPayload, S>

  type KontorRoyaltyReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KontorRoyaltyReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KontorRoyaltyReportCountAggregateInputType | true
    }

  export interface KontorRoyaltyReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KontorRoyaltyReport'], meta: { name: 'KontorRoyaltyReport' } }
    /**
     * Find zero or one KontorRoyaltyReport that matches the filter.
     * @param {KontorRoyaltyReportFindUniqueArgs} args - Arguments to find a KontorRoyaltyReport
     * @example
     * // Get one KontorRoyaltyReport
     * const kontorRoyaltyReport = await prisma.kontorRoyaltyReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KontorRoyaltyReportFindUniqueArgs>(args: SelectSubset<T, KontorRoyaltyReportFindUniqueArgs<ExtArgs>>): Prisma__KontorRoyaltyReportClient<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KontorRoyaltyReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KontorRoyaltyReportFindUniqueOrThrowArgs} args - Arguments to find a KontorRoyaltyReport
     * @example
     * // Get one KontorRoyaltyReport
     * const kontorRoyaltyReport = await prisma.kontorRoyaltyReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KontorRoyaltyReportFindUniqueOrThrowArgs>(args: SelectSubset<T, KontorRoyaltyReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KontorRoyaltyReportClient<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KontorRoyaltyReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorRoyaltyReportFindFirstArgs} args - Arguments to find a KontorRoyaltyReport
     * @example
     * // Get one KontorRoyaltyReport
     * const kontorRoyaltyReport = await prisma.kontorRoyaltyReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KontorRoyaltyReportFindFirstArgs>(args?: SelectSubset<T, KontorRoyaltyReportFindFirstArgs<ExtArgs>>): Prisma__KontorRoyaltyReportClient<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KontorRoyaltyReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorRoyaltyReportFindFirstOrThrowArgs} args - Arguments to find a KontorRoyaltyReport
     * @example
     * // Get one KontorRoyaltyReport
     * const kontorRoyaltyReport = await prisma.kontorRoyaltyReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KontorRoyaltyReportFindFirstOrThrowArgs>(args?: SelectSubset<T, KontorRoyaltyReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__KontorRoyaltyReportClient<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KontorRoyaltyReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorRoyaltyReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KontorRoyaltyReports
     * const kontorRoyaltyReports = await prisma.kontorRoyaltyReport.findMany()
     * 
     * // Get first 10 KontorRoyaltyReports
     * const kontorRoyaltyReports = await prisma.kontorRoyaltyReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kontorRoyaltyReportWithIdOnly = await prisma.kontorRoyaltyReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KontorRoyaltyReportFindManyArgs>(args?: SelectSubset<T, KontorRoyaltyReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KontorRoyaltyReport.
     * @param {KontorRoyaltyReportCreateArgs} args - Arguments to create a KontorRoyaltyReport.
     * @example
     * // Create one KontorRoyaltyReport
     * const KontorRoyaltyReport = await prisma.kontorRoyaltyReport.create({
     *   data: {
     *     // ... data to create a KontorRoyaltyReport
     *   }
     * })
     * 
     */
    create<T extends KontorRoyaltyReportCreateArgs>(args: SelectSubset<T, KontorRoyaltyReportCreateArgs<ExtArgs>>): Prisma__KontorRoyaltyReportClient<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KontorRoyaltyReports.
     * @param {KontorRoyaltyReportCreateManyArgs} args - Arguments to create many KontorRoyaltyReports.
     * @example
     * // Create many KontorRoyaltyReports
     * const kontorRoyaltyReport = await prisma.kontorRoyaltyReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KontorRoyaltyReportCreateManyArgs>(args?: SelectSubset<T, KontorRoyaltyReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KontorRoyaltyReports and returns the data saved in the database.
     * @param {KontorRoyaltyReportCreateManyAndReturnArgs} args - Arguments to create many KontorRoyaltyReports.
     * @example
     * // Create many KontorRoyaltyReports
     * const kontorRoyaltyReport = await prisma.kontorRoyaltyReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KontorRoyaltyReports and only return the `id`
     * const kontorRoyaltyReportWithIdOnly = await prisma.kontorRoyaltyReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KontorRoyaltyReportCreateManyAndReturnArgs>(args?: SelectSubset<T, KontorRoyaltyReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KontorRoyaltyReport.
     * @param {KontorRoyaltyReportDeleteArgs} args - Arguments to delete one KontorRoyaltyReport.
     * @example
     * // Delete one KontorRoyaltyReport
     * const KontorRoyaltyReport = await prisma.kontorRoyaltyReport.delete({
     *   where: {
     *     // ... filter to delete one KontorRoyaltyReport
     *   }
     * })
     * 
     */
    delete<T extends KontorRoyaltyReportDeleteArgs>(args: SelectSubset<T, KontorRoyaltyReportDeleteArgs<ExtArgs>>): Prisma__KontorRoyaltyReportClient<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KontorRoyaltyReport.
     * @param {KontorRoyaltyReportUpdateArgs} args - Arguments to update one KontorRoyaltyReport.
     * @example
     * // Update one KontorRoyaltyReport
     * const kontorRoyaltyReport = await prisma.kontorRoyaltyReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KontorRoyaltyReportUpdateArgs>(args: SelectSubset<T, KontorRoyaltyReportUpdateArgs<ExtArgs>>): Prisma__KontorRoyaltyReportClient<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KontorRoyaltyReports.
     * @param {KontorRoyaltyReportDeleteManyArgs} args - Arguments to filter KontorRoyaltyReports to delete.
     * @example
     * // Delete a few KontorRoyaltyReports
     * const { count } = await prisma.kontorRoyaltyReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KontorRoyaltyReportDeleteManyArgs>(args?: SelectSubset<T, KontorRoyaltyReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KontorRoyaltyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorRoyaltyReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KontorRoyaltyReports
     * const kontorRoyaltyReport = await prisma.kontorRoyaltyReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KontorRoyaltyReportUpdateManyArgs>(args: SelectSubset<T, KontorRoyaltyReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KontorRoyaltyReports and returns the data updated in the database.
     * @param {KontorRoyaltyReportUpdateManyAndReturnArgs} args - Arguments to update many KontorRoyaltyReports.
     * @example
     * // Update many KontorRoyaltyReports
     * const kontorRoyaltyReport = await prisma.kontorRoyaltyReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KontorRoyaltyReports and only return the `id`
     * const kontorRoyaltyReportWithIdOnly = await prisma.kontorRoyaltyReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KontorRoyaltyReportUpdateManyAndReturnArgs>(args: SelectSubset<T, KontorRoyaltyReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KontorRoyaltyReport.
     * @param {KontorRoyaltyReportUpsertArgs} args - Arguments to update or create a KontorRoyaltyReport.
     * @example
     * // Update or create a KontorRoyaltyReport
     * const kontorRoyaltyReport = await prisma.kontorRoyaltyReport.upsert({
     *   create: {
     *     // ... data to create a KontorRoyaltyReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KontorRoyaltyReport we want to update
     *   }
     * })
     */
    upsert<T extends KontorRoyaltyReportUpsertArgs>(args: SelectSubset<T, KontorRoyaltyReportUpsertArgs<ExtArgs>>): Prisma__KontorRoyaltyReportClient<$Result.GetResult<Prisma.$KontorRoyaltyReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KontorRoyaltyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorRoyaltyReportCountArgs} args - Arguments to filter KontorRoyaltyReports to count.
     * @example
     * // Count the number of KontorRoyaltyReports
     * const count = await prisma.kontorRoyaltyReport.count({
     *   where: {
     *     // ... the filter for the KontorRoyaltyReports we want to count
     *   }
     * })
    **/
    count<T extends KontorRoyaltyReportCountArgs>(
      args?: Subset<T, KontorRoyaltyReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KontorRoyaltyReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KontorRoyaltyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorRoyaltyReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KontorRoyaltyReportAggregateArgs>(args: Subset<T, KontorRoyaltyReportAggregateArgs>): Prisma.PrismaPromise<GetKontorRoyaltyReportAggregateType<T>>

    /**
     * Group by KontorRoyaltyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KontorRoyaltyReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KontorRoyaltyReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KontorRoyaltyReportGroupByArgs['orderBy'] }
        : { orderBy?: KontorRoyaltyReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KontorRoyaltyReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKontorRoyaltyReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KontorRoyaltyReport model
   */
  readonly fields: KontorRoyaltyReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KontorRoyaltyReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KontorRoyaltyReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    label<T extends KontorRoyaltyReport$labelArgs<ExtArgs> = {}>(args?: Subset<T, KontorRoyaltyReport$labelArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    baseReport<T extends KontorRoyaltyReport$baseReportArgs<ExtArgs> = {}>(args?: Subset<T, KontorRoyaltyReport$baseReportArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userReport<T extends KontorRoyaltyReport$userReportArgs<ExtArgs> = {}>(args?: Subset<T, KontorRoyaltyReport$userReportArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    importedReport<T extends KontorRoyaltyReport$importedReportArgs<ExtArgs> = {}>(args?: Subset<T, KontorRoyaltyReport$importedReportArgs<ExtArgs>>): Prisma__ImportedRoyaltyReportClient<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KontorRoyaltyReport model
   */
  interface KontorRoyaltyReportFieldRefs {
    readonly id: FieldRef<"KontorRoyaltyReport", 'Int'>
    readonly createdAt: FieldRef<"KontorRoyaltyReport", 'DateTime'>
    readonly updatedAt: FieldRef<"KontorRoyaltyReport", 'DateTime'>
    readonly currency: FieldRef<"KontorRoyaltyReport", 'Currency'>
    readonly labelId: FieldRef<"KontorRoyaltyReport", 'Int'>
    readonly reportingMonth: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly salesMonth: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly store: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly chType: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly channelId: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly country: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly labelName: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly productType: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly productTitle: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly productArtist: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly ean: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly isrc: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly grid: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly articleNo: FieldRef<"KontorRoyaltyReport", 'String'>
    readonly royalties: FieldRef<"KontorRoyaltyReport", 'Decimal'>
    readonly units: FieldRef<"KontorRoyaltyReport", 'Int'>
    readonly cmg_clientRate: FieldRef<"KontorRoyaltyReport", 'Decimal'>
    readonly cmg_netRevenue: FieldRef<"KontorRoyaltyReport", 'Decimal'>
    readonly baseReportId: FieldRef<"KontorRoyaltyReport", 'Int'>
    readonly userReportId: FieldRef<"KontorRoyaltyReport", 'Int'>
    readonly importedReportId: FieldRef<"KontorRoyaltyReport", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * KontorRoyaltyReport findUnique
   */
  export type KontorRoyaltyReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which KontorRoyaltyReport to fetch.
     */
    where: KontorRoyaltyReportWhereUniqueInput
  }

  /**
   * KontorRoyaltyReport findUniqueOrThrow
   */
  export type KontorRoyaltyReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which KontorRoyaltyReport to fetch.
     */
    where: KontorRoyaltyReportWhereUniqueInput
  }

  /**
   * KontorRoyaltyReport findFirst
   */
  export type KontorRoyaltyReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which KontorRoyaltyReport to fetch.
     */
    where?: KontorRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KontorRoyaltyReports to fetch.
     */
    orderBy?: KontorRoyaltyReportOrderByWithRelationInput | KontorRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KontorRoyaltyReports.
     */
    cursor?: KontorRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KontorRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KontorRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KontorRoyaltyReports.
     */
    distinct?: KontorRoyaltyReportScalarFieldEnum | KontorRoyaltyReportScalarFieldEnum[]
  }

  /**
   * KontorRoyaltyReport findFirstOrThrow
   */
  export type KontorRoyaltyReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which KontorRoyaltyReport to fetch.
     */
    where?: KontorRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KontorRoyaltyReports to fetch.
     */
    orderBy?: KontorRoyaltyReportOrderByWithRelationInput | KontorRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KontorRoyaltyReports.
     */
    cursor?: KontorRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KontorRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KontorRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KontorRoyaltyReports.
     */
    distinct?: KontorRoyaltyReportScalarFieldEnum | KontorRoyaltyReportScalarFieldEnum[]
  }

  /**
   * KontorRoyaltyReport findMany
   */
  export type KontorRoyaltyReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which KontorRoyaltyReports to fetch.
     */
    where?: KontorRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KontorRoyaltyReports to fetch.
     */
    orderBy?: KontorRoyaltyReportOrderByWithRelationInput | KontorRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KontorRoyaltyReports.
     */
    cursor?: KontorRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KontorRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KontorRoyaltyReports.
     */
    skip?: number
    distinct?: KontorRoyaltyReportScalarFieldEnum | KontorRoyaltyReportScalarFieldEnum[]
  }

  /**
   * KontorRoyaltyReport create
   */
  export type KontorRoyaltyReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    /**
     * The data needed to create a KontorRoyaltyReport.
     */
    data: XOR<KontorRoyaltyReportCreateInput, KontorRoyaltyReportUncheckedCreateInput>
  }

  /**
   * KontorRoyaltyReport createMany
   */
  export type KontorRoyaltyReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KontorRoyaltyReports.
     */
    data: KontorRoyaltyReportCreateManyInput | KontorRoyaltyReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KontorRoyaltyReport createManyAndReturn
   */
  export type KontorRoyaltyReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * The data used to create many KontorRoyaltyReports.
     */
    data: KontorRoyaltyReportCreateManyInput | KontorRoyaltyReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KontorRoyaltyReport update
   */
  export type KontorRoyaltyReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    /**
     * The data needed to update a KontorRoyaltyReport.
     */
    data: XOR<KontorRoyaltyReportUpdateInput, KontorRoyaltyReportUncheckedUpdateInput>
    /**
     * Choose, which KontorRoyaltyReport to update.
     */
    where: KontorRoyaltyReportWhereUniqueInput
  }

  /**
   * KontorRoyaltyReport updateMany
   */
  export type KontorRoyaltyReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KontorRoyaltyReports.
     */
    data: XOR<KontorRoyaltyReportUpdateManyMutationInput, KontorRoyaltyReportUncheckedUpdateManyInput>
    /**
     * Filter which KontorRoyaltyReports to update
     */
    where?: KontorRoyaltyReportWhereInput
    /**
     * Limit how many KontorRoyaltyReports to update.
     */
    limit?: number
  }

  /**
   * KontorRoyaltyReport updateManyAndReturn
   */
  export type KontorRoyaltyReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * The data used to update KontorRoyaltyReports.
     */
    data: XOR<KontorRoyaltyReportUpdateManyMutationInput, KontorRoyaltyReportUncheckedUpdateManyInput>
    /**
     * Filter which KontorRoyaltyReports to update
     */
    where?: KontorRoyaltyReportWhereInput
    /**
     * Limit how many KontorRoyaltyReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KontorRoyaltyReport upsert
   */
  export type KontorRoyaltyReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    /**
     * The filter to search for the KontorRoyaltyReport to update in case it exists.
     */
    where: KontorRoyaltyReportWhereUniqueInput
    /**
     * In case the KontorRoyaltyReport found by the `where` argument doesn't exist, create a new KontorRoyaltyReport with this data.
     */
    create: XOR<KontorRoyaltyReportCreateInput, KontorRoyaltyReportUncheckedCreateInput>
    /**
     * In case the KontorRoyaltyReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KontorRoyaltyReportUpdateInput, KontorRoyaltyReportUncheckedUpdateInput>
  }

  /**
   * KontorRoyaltyReport delete
   */
  export type KontorRoyaltyReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter which KontorRoyaltyReport to delete.
     */
    where: KontorRoyaltyReportWhereUniqueInput
  }

  /**
   * KontorRoyaltyReport deleteMany
   */
  export type KontorRoyaltyReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KontorRoyaltyReports to delete
     */
    where?: KontorRoyaltyReportWhereInput
    /**
     * Limit how many KontorRoyaltyReports to delete.
     */
    limit?: number
  }

  /**
   * KontorRoyaltyReport.label
   */
  export type KontorRoyaltyReport$labelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    where?: LabelWhereInput
  }

  /**
   * KontorRoyaltyReport.baseReport
   */
  export type KontorRoyaltyReport$baseReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    where?: BaseRoyaltyReportWhereInput
  }

  /**
   * KontorRoyaltyReport.userReport
   */
  export type KontorRoyaltyReport$userReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    where?: UserRoyaltyReportWhereInput
  }

  /**
   * KontorRoyaltyReport.importedReport
   */
  export type KontorRoyaltyReport$importedReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    where?: ImportedRoyaltyReportWhereInput
  }

  /**
   * KontorRoyaltyReport without action
   */
  export type KontorRoyaltyReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KontorRoyaltyReport
     */
    select?: KontorRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KontorRoyaltyReport
     */
    omit?: KontorRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KontorRoyaltyReportInclude<ExtArgs> | null
  }


  /**
   * Model BelieveRoyaltyReport
   */

  export type AggregateBelieveRoyaltyReport = {
    _count: BelieveRoyaltyReportCountAggregateOutputType | null
    _avg: BelieveRoyaltyReportAvgAggregateOutputType | null
    _sum: BelieveRoyaltyReportSumAggregateOutputType | null
    _min: BelieveRoyaltyReportMinAggregateOutputType | null
    _max: BelieveRoyaltyReportMaxAggregateOutputType | null
  }

  export type BelieveRoyaltyReportAvgAggregateOutputType = {
    id: number | null
    labelId: number | null
    unitPrice: Decimal | null
    mechanicalFee: Decimal | null
    grossRevenue: Decimal | null
    clientShareRate: Decimal | null
    netRevenue: Decimal | null
    cmg_clientRate: Decimal | null
    cmg_netRevenue: Decimal | null
    baseReportId: number | null
    userReportId: number | null
    importedReportId: number | null
  }

  export type BelieveRoyaltyReportSumAggregateOutputType = {
    id: number | null
    labelId: number | null
    unitPrice: Decimal | null
    mechanicalFee: Decimal | null
    grossRevenue: Decimal | null
    clientShareRate: Decimal | null
    netRevenue: Decimal | null
    cmg_clientRate: Decimal | null
    cmg_netRevenue: Decimal | null
    baseReportId: number | null
    userReportId: number | null
    importedReportId: number | null
  }

  export type BelieveRoyaltyReportMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: $Enums.Currency | null
    labelId: number | null
    reportingMonth: string | null
    salesMonth: string | null
    platform: string | null
    countryRegion: string | null
    labelName: string | null
    artistName: string | null
    releaseTitle: string | null
    trackTitle: string | null
    upc: string | null
    isrc: string | null
    catalogNb: string | null
    streamingSubscriptionType: string | null
    releaseType: string | null
    salesType: string | null
    quantity: string | null
    clientPaymentCurrency: string | null
    unitPrice: Decimal | null
    mechanicalFee: Decimal | null
    grossRevenue: Decimal | null
    clientShareRate: Decimal | null
    netRevenue: Decimal | null
    cmg_clientRate: Decimal | null
    cmg_netRevenue: Decimal | null
    baseReportId: number | null
    userReportId: number | null
    importedReportId: number | null
  }

  export type BelieveRoyaltyReportMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: $Enums.Currency | null
    labelId: number | null
    reportingMonth: string | null
    salesMonth: string | null
    platform: string | null
    countryRegion: string | null
    labelName: string | null
    artistName: string | null
    releaseTitle: string | null
    trackTitle: string | null
    upc: string | null
    isrc: string | null
    catalogNb: string | null
    streamingSubscriptionType: string | null
    releaseType: string | null
    salesType: string | null
    quantity: string | null
    clientPaymentCurrency: string | null
    unitPrice: Decimal | null
    mechanicalFee: Decimal | null
    grossRevenue: Decimal | null
    clientShareRate: Decimal | null
    netRevenue: Decimal | null
    cmg_clientRate: Decimal | null
    cmg_netRevenue: Decimal | null
    baseReportId: number | null
    userReportId: number | null
    importedReportId: number | null
  }

  export type BelieveRoyaltyReportCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    currency: number
    labelId: number
    reportingMonth: number
    salesMonth: number
    platform: number
    countryRegion: number
    labelName: number
    artistName: number
    releaseTitle: number
    trackTitle: number
    upc: number
    isrc: number
    catalogNb: number
    streamingSubscriptionType: number
    releaseType: number
    salesType: number
    quantity: number
    clientPaymentCurrency: number
    unitPrice: number
    mechanicalFee: number
    grossRevenue: number
    clientShareRate: number
    netRevenue: number
    cmg_clientRate: number
    cmg_netRevenue: number
    baseReportId: number
    userReportId: number
    importedReportId: number
    _all: number
  }


  export type BelieveRoyaltyReportAvgAggregateInputType = {
    id?: true
    labelId?: true
    unitPrice?: true
    mechanicalFee?: true
    grossRevenue?: true
    clientShareRate?: true
    netRevenue?: true
    cmg_clientRate?: true
    cmg_netRevenue?: true
    baseReportId?: true
    userReportId?: true
    importedReportId?: true
  }

  export type BelieveRoyaltyReportSumAggregateInputType = {
    id?: true
    labelId?: true
    unitPrice?: true
    mechanicalFee?: true
    grossRevenue?: true
    clientShareRate?: true
    netRevenue?: true
    cmg_clientRate?: true
    cmg_netRevenue?: true
    baseReportId?: true
    userReportId?: true
    importedReportId?: true
  }

  export type BelieveRoyaltyReportMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    labelId?: true
    reportingMonth?: true
    salesMonth?: true
    platform?: true
    countryRegion?: true
    labelName?: true
    artistName?: true
    releaseTitle?: true
    trackTitle?: true
    upc?: true
    isrc?: true
    catalogNb?: true
    streamingSubscriptionType?: true
    releaseType?: true
    salesType?: true
    quantity?: true
    clientPaymentCurrency?: true
    unitPrice?: true
    mechanicalFee?: true
    grossRevenue?: true
    clientShareRate?: true
    netRevenue?: true
    cmg_clientRate?: true
    cmg_netRevenue?: true
    baseReportId?: true
    userReportId?: true
    importedReportId?: true
  }

  export type BelieveRoyaltyReportMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    labelId?: true
    reportingMonth?: true
    salesMonth?: true
    platform?: true
    countryRegion?: true
    labelName?: true
    artistName?: true
    releaseTitle?: true
    trackTitle?: true
    upc?: true
    isrc?: true
    catalogNb?: true
    streamingSubscriptionType?: true
    releaseType?: true
    salesType?: true
    quantity?: true
    clientPaymentCurrency?: true
    unitPrice?: true
    mechanicalFee?: true
    grossRevenue?: true
    clientShareRate?: true
    netRevenue?: true
    cmg_clientRate?: true
    cmg_netRevenue?: true
    baseReportId?: true
    userReportId?: true
    importedReportId?: true
  }

  export type BelieveRoyaltyReportCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    labelId?: true
    reportingMonth?: true
    salesMonth?: true
    platform?: true
    countryRegion?: true
    labelName?: true
    artistName?: true
    releaseTitle?: true
    trackTitle?: true
    upc?: true
    isrc?: true
    catalogNb?: true
    streamingSubscriptionType?: true
    releaseType?: true
    salesType?: true
    quantity?: true
    clientPaymentCurrency?: true
    unitPrice?: true
    mechanicalFee?: true
    grossRevenue?: true
    clientShareRate?: true
    netRevenue?: true
    cmg_clientRate?: true
    cmg_netRevenue?: true
    baseReportId?: true
    userReportId?: true
    importedReportId?: true
    _all?: true
  }

  export type BelieveRoyaltyReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BelieveRoyaltyReport to aggregate.
     */
    where?: BelieveRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BelieveRoyaltyReports to fetch.
     */
    orderBy?: BelieveRoyaltyReportOrderByWithRelationInput | BelieveRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BelieveRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BelieveRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BelieveRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BelieveRoyaltyReports
    **/
    _count?: true | BelieveRoyaltyReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BelieveRoyaltyReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BelieveRoyaltyReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BelieveRoyaltyReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BelieveRoyaltyReportMaxAggregateInputType
  }

  export type GetBelieveRoyaltyReportAggregateType<T extends BelieveRoyaltyReportAggregateArgs> = {
        [P in keyof T & keyof AggregateBelieveRoyaltyReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBelieveRoyaltyReport[P]>
      : GetScalarType<T[P], AggregateBelieveRoyaltyReport[P]>
  }




  export type BelieveRoyaltyReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BelieveRoyaltyReportWhereInput
    orderBy?: BelieveRoyaltyReportOrderByWithAggregationInput | BelieveRoyaltyReportOrderByWithAggregationInput[]
    by: BelieveRoyaltyReportScalarFieldEnum[] | BelieveRoyaltyReportScalarFieldEnum
    having?: BelieveRoyaltyReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BelieveRoyaltyReportCountAggregateInputType | true
    _avg?: BelieveRoyaltyReportAvgAggregateInputType
    _sum?: BelieveRoyaltyReportSumAggregateInputType
    _min?: BelieveRoyaltyReportMinAggregateInputType
    _max?: BelieveRoyaltyReportMaxAggregateInputType
  }

  export type BelieveRoyaltyReportGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    currency: $Enums.Currency
    labelId: number | null
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb: string | null
    streamingSubscriptionType: string | null
    releaseType: string | null
    salesType: string | null
    quantity: string
    clientPaymentCurrency: string | null
    unitPrice: Decimal
    mechanicalFee: Decimal | null
    grossRevenue: Decimal
    clientShareRate: Decimal
    netRevenue: Decimal
    cmg_clientRate: Decimal | null
    cmg_netRevenue: Decimal | null
    baseReportId: number | null
    userReportId: number | null
    importedReportId: number | null
    _count: BelieveRoyaltyReportCountAggregateOutputType | null
    _avg: BelieveRoyaltyReportAvgAggregateOutputType | null
    _sum: BelieveRoyaltyReportSumAggregateOutputType | null
    _min: BelieveRoyaltyReportMinAggregateOutputType | null
    _max: BelieveRoyaltyReportMaxAggregateOutputType | null
  }

  type GetBelieveRoyaltyReportGroupByPayload<T extends BelieveRoyaltyReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BelieveRoyaltyReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BelieveRoyaltyReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BelieveRoyaltyReportGroupByOutputType[P]>
            : GetScalarType<T[P], BelieveRoyaltyReportGroupByOutputType[P]>
        }
      >
    >


  export type BelieveRoyaltyReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    labelId?: boolean
    reportingMonth?: boolean
    salesMonth?: boolean
    platform?: boolean
    countryRegion?: boolean
    labelName?: boolean
    artistName?: boolean
    releaseTitle?: boolean
    trackTitle?: boolean
    upc?: boolean
    isrc?: boolean
    catalogNb?: boolean
    streamingSubscriptionType?: boolean
    releaseType?: boolean
    salesType?: boolean
    quantity?: boolean
    clientPaymentCurrency?: boolean
    unitPrice?: boolean
    mechanicalFee?: boolean
    grossRevenue?: boolean
    clientShareRate?: boolean
    netRevenue?: boolean
    cmg_clientRate?: boolean
    cmg_netRevenue?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    importedReportId?: boolean
    label?: boolean | BelieveRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | BelieveRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | BelieveRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | BelieveRoyaltyReport$importedReportArgs<ExtArgs>
  }, ExtArgs["result"]["believeRoyaltyReport"]>

  export type BelieveRoyaltyReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    labelId?: boolean
    reportingMonth?: boolean
    salesMonth?: boolean
    platform?: boolean
    countryRegion?: boolean
    labelName?: boolean
    artistName?: boolean
    releaseTitle?: boolean
    trackTitle?: boolean
    upc?: boolean
    isrc?: boolean
    catalogNb?: boolean
    streamingSubscriptionType?: boolean
    releaseType?: boolean
    salesType?: boolean
    quantity?: boolean
    clientPaymentCurrency?: boolean
    unitPrice?: boolean
    mechanicalFee?: boolean
    grossRevenue?: boolean
    clientShareRate?: boolean
    netRevenue?: boolean
    cmg_clientRate?: boolean
    cmg_netRevenue?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    importedReportId?: boolean
    label?: boolean | BelieveRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | BelieveRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | BelieveRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | BelieveRoyaltyReport$importedReportArgs<ExtArgs>
  }, ExtArgs["result"]["believeRoyaltyReport"]>

  export type BelieveRoyaltyReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    labelId?: boolean
    reportingMonth?: boolean
    salesMonth?: boolean
    platform?: boolean
    countryRegion?: boolean
    labelName?: boolean
    artistName?: boolean
    releaseTitle?: boolean
    trackTitle?: boolean
    upc?: boolean
    isrc?: boolean
    catalogNb?: boolean
    streamingSubscriptionType?: boolean
    releaseType?: boolean
    salesType?: boolean
    quantity?: boolean
    clientPaymentCurrency?: boolean
    unitPrice?: boolean
    mechanicalFee?: boolean
    grossRevenue?: boolean
    clientShareRate?: boolean
    netRevenue?: boolean
    cmg_clientRate?: boolean
    cmg_netRevenue?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    importedReportId?: boolean
    label?: boolean | BelieveRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | BelieveRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | BelieveRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | BelieveRoyaltyReport$importedReportArgs<ExtArgs>
  }, ExtArgs["result"]["believeRoyaltyReport"]>

  export type BelieveRoyaltyReportSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
    labelId?: boolean
    reportingMonth?: boolean
    salesMonth?: boolean
    platform?: boolean
    countryRegion?: boolean
    labelName?: boolean
    artistName?: boolean
    releaseTitle?: boolean
    trackTitle?: boolean
    upc?: boolean
    isrc?: boolean
    catalogNb?: boolean
    streamingSubscriptionType?: boolean
    releaseType?: boolean
    salesType?: boolean
    quantity?: boolean
    clientPaymentCurrency?: boolean
    unitPrice?: boolean
    mechanicalFee?: boolean
    grossRevenue?: boolean
    clientShareRate?: boolean
    netRevenue?: boolean
    cmg_clientRate?: boolean
    cmg_netRevenue?: boolean
    baseReportId?: boolean
    userReportId?: boolean
    importedReportId?: boolean
  }

  export type BelieveRoyaltyReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "currency" | "labelId" | "reportingMonth" | "salesMonth" | "platform" | "countryRegion" | "labelName" | "artistName" | "releaseTitle" | "trackTitle" | "upc" | "isrc" | "catalogNb" | "streamingSubscriptionType" | "releaseType" | "salesType" | "quantity" | "clientPaymentCurrency" | "unitPrice" | "mechanicalFee" | "grossRevenue" | "clientShareRate" | "netRevenue" | "cmg_clientRate" | "cmg_netRevenue" | "baseReportId" | "userReportId" | "importedReportId", ExtArgs["result"]["believeRoyaltyReport"]>
  export type BelieveRoyaltyReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    label?: boolean | BelieveRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | BelieveRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | BelieveRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | BelieveRoyaltyReport$importedReportArgs<ExtArgs>
  }
  export type BelieveRoyaltyReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    label?: boolean | BelieveRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | BelieveRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | BelieveRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | BelieveRoyaltyReport$importedReportArgs<ExtArgs>
  }
  export type BelieveRoyaltyReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    label?: boolean | BelieveRoyaltyReport$labelArgs<ExtArgs>
    baseReport?: boolean | BelieveRoyaltyReport$baseReportArgs<ExtArgs>
    userReport?: boolean | BelieveRoyaltyReport$userReportArgs<ExtArgs>
    importedReport?: boolean | BelieveRoyaltyReport$importedReportArgs<ExtArgs>
  }

  export type $BelieveRoyaltyReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BelieveRoyaltyReport"
    objects: {
      label: Prisma.$LabelPayload<ExtArgs> | null
      baseReport: Prisma.$BaseRoyaltyReportPayload<ExtArgs> | null
      userReport: Prisma.$UserRoyaltyReportPayload<ExtArgs> | null
      importedReport: Prisma.$ImportedRoyaltyReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      currency: $Enums.Currency
      labelId: number | null
      reportingMonth: string
      salesMonth: string
      platform: string
      countryRegion: string
      labelName: string
      artistName: string
      releaseTitle: string
      trackTitle: string
      upc: string
      isrc: string
      catalogNb: string | null
      streamingSubscriptionType: string | null
      releaseType: string | null
      salesType: string | null
      quantity: string
      clientPaymentCurrency: string | null
      unitPrice: Prisma.Decimal
      mechanicalFee: Prisma.Decimal | null
      grossRevenue: Prisma.Decimal
      clientShareRate: Prisma.Decimal
      netRevenue: Prisma.Decimal
      cmg_clientRate: Prisma.Decimal | null
      cmg_netRevenue: Prisma.Decimal | null
      baseReportId: number | null
      userReportId: number | null
      importedReportId: number | null
    }, ExtArgs["result"]["believeRoyaltyReport"]>
    composites: {}
  }

  type BelieveRoyaltyReportGetPayload<S extends boolean | null | undefined | BelieveRoyaltyReportDefaultArgs> = $Result.GetResult<Prisma.$BelieveRoyaltyReportPayload, S>

  type BelieveRoyaltyReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BelieveRoyaltyReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BelieveRoyaltyReportCountAggregateInputType | true
    }

  export interface BelieveRoyaltyReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BelieveRoyaltyReport'], meta: { name: 'BelieveRoyaltyReport' } }
    /**
     * Find zero or one BelieveRoyaltyReport that matches the filter.
     * @param {BelieveRoyaltyReportFindUniqueArgs} args - Arguments to find a BelieveRoyaltyReport
     * @example
     * // Get one BelieveRoyaltyReport
     * const believeRoyaltyReport = await prisma.believeRoyaltyReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BelieveRoyaltyReportFindUniqueArgs>(args: SelectSubset<T, BelieveRoyaltyReportFindUniqueArgs<ExtArgs>>): Prisma__BelieveRoyaltyReportClient<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BelieveRoyaltyReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BelieveRoyaltyReportFindUniqueOrThrowArgs} args - Arguments to find a BelieveRoyaltyReport
     * @example
     * // Get one BelieveRoyaltyReport
     * const believeRoyaltyReport = await prisma.believeRoyaltyReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BelieveRoyaltyReportFindUniqueOrThrowArgs>(args: SelectSubset<T, BelieveRoyaltyReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BelieveRoyaltyReportClient<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BelieveRoyaltyReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BelieveRoyaltyReportFindFirstArgs} args - Arguments to find a BelieveRoyaltyReport
     * @example
     * // Get one BelieveRoyaltyReport
     * const believeRoyaltyReport = await prisma.believeRoyaltyReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BelieveRoyaltyReportFindFirstArgs>(args?: SelectSubset<T, BelieveRoyaltyReportFindFirstArgs<ExtArgs>>): Prisma__BelieveRoyaltyReportClient<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BelieveRoyaltyReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BelieveRoyaltyReportFindFirstOrThrowArgs} args - Arguments to find a BelieveRoyaltyReport
     * @example
     * // Get one BelieveRoyaltyReport
     * const believeRoyaltyReport = await prisma.believeRoyaltyReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BelieveRoyaltyReportFindFirstOrThrowArgs>(args?: SelectSubset<T, BelieveRoyaltyReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__BelieveRoyaltyReportClient<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BelieveRoyaltyReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BelieveRoyaltyReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BelieveRoyaltyReports
     * const believeRoyaltyReports = await prisma.believeRoyaltyReport.findMany()
     * 
     * // Get first 10 BelieveRoyaltyReports
     * const believeRoyaltyReports = await prisma.believeRoyaltyReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const believeRoyaltyReportWithIdOnly = await prisma.believeRoyaltyReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BelieveRoyaltyReportFindManyArgs>(args?: SelectSubset<T, BelieveRoyaltyReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BelieveRoyaltyReport.
     * @param {BelieveRoyaltyReportCreateArgs} args - Arguments to create a BelieveRoyaltyReport.
     * @example
     * // Create one BelieveRoyaltyReport
     * const BelieveRoyaltyReport = await prisma.believeRoyaltyReport.create({
     *   data: {
     *     // ... data to create a BelieveRoyaltyReport
     *   }
     * })
     * 
     */
    create<T extends BelieveRoyaltyReportCreateArgs>(args: SelectSubset<T, BelieveRoyaltyReportCreateArgs<ExtArgs>>): Prisma__BelieveRoyaltyReportClient<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BelieveRoyaltyReports.
     * @param {BelieveRoyaltyReportCreateManyArgs} args - Arguments to create many BelieveRoyaltyReports.
     * @example
     * // Create many BelieveRoyaltyReports
     * const believeRoyaltyReport = await prisma.believeRoyaltyReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BelieveRoyaltyReportCreateManyArgs>(args?: SelectSubset<T, BelieveRoyaltyReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BelieveRoyaltyReports and returns the data saved in the database.
     * @param {BelieveRoyaltyReportCreateManyAndReturnArgs} args - Arguments to create many BelieveRoyaltyReports.
     * @example
     * // Create many BelieveRoyaltyReports
     * const believeRoyaltyReport = await prisma.believeRoyaltyReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BelieveRoyaltyReports and only return the `id`
     * const believeRoyaltyReportWithIdOnly = await prisma.believeRoyaltyReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BelieveRoyaltyReportCreateManyAndReturnArgs>(args?: SelectSubset<T, BelieveRoyaltyReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BelieveRoyaltyReport.
     * @param {BelieveRoyaltyReportDeleteArgs} args - Arguments to delete one BelieveRoyaltyReport.
     * @example
     * // Delete one BelieveRoyaltyReport
     * const BelieveRoyaltyReport = await prisma.believeRoyaltyReport.delete({
     *   where: {
     *     // ... filter to delete one BelieveRoyaltyReport
     *   }
     * })
     * 
     */
    delete<T extends BelieveRoyaltyReportDeleteArgs>(args: SelectSubset<T, BelieveRoyaltyReportDeleteArgs<ExtArgs>>): Prisma__BelieveRoyaltyReportClient<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BelieveRoyaltyReport.
     * @param {BelieveRoyaltyReportUpdateArgs} args - Arguments to update one BelieveRoyaltyReport.
     * @example
     * // Update one BelieveRoyaltyReport
     * const believeRoyaltyReport = await prisma.believeRoyaltyReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BelieveRoyaltyReportUpdateArgs>(args: SelectSubset<T, BelieveRoyaltyReportUpdateArgs<ExtArgs>>): Prisma__BelieveRoyaltyReportClient<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BelieveRoyaltyReports.
     * @param {BelieveRoyaltyReportDeleteManyArgs} args - Arguments to filter BelieveRoyaltyReports to delete.
     * @example
     * // Delete a few BelieveRoyaltyReports
     * const { count } = await prisma.believeRoyaltyReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BelieveRoyaltyReportDeleteManyArgs>(args?: SelectSubset<T, BelieveRoyaltyReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BelieveRoyaltyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BelieveRoyaltyReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BelieveRoyaltyReports
     * const believeRoyaltyReport = await prisma.believeRoyaltyReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BelieveRoyaltyReportUpdateManyArgs>(args: SelectSubset<T, BelieveRoyaltyReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BelieveRoyaltyReports and returns the data updated in the database.
     * @param {BelieveRoyaltyReportUpdateManyAndReturnArgs} args - Arguments to update many BelieveRoyaltyReports.
     * @example
     * // Update many BelieveRoyaltyReports
     * const believeRoyaltyReport = await prisma.believeRoyaltyReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BelieveRoyaltyReports and only return the `id`
     * const believeRoyaltyReportWithIdOnly = await prisma.believeRoyaltyReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BelieveRoyaltyReportUpdateManyAndReturnArgs>(args: SelectSubset<T, BelieveRoyaltyReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BelieveRoyaltyReport.
     * @param {BelieveRoyaltyReportUpsertArgs} args - Arguments to update or create a BelieveRoyaltyReport.
     * @example
     * // Update or create a BelieveRoyaltyReport
     * const believeRoyaltyReport = await prisma.believeRoyaltyReport.upsert({
     *   create: {
     *     // ... data to create a BelieveRoyaltyReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BelieveRoyaltyReport we want to update
     *   }
     * })
     */
    upsert<T extends BelieveRoyaltyReportUpsertArgs>(args: SelectSubset<T, BelieveRoyaltyReportUpsertArgs<ExtArgs>>): Prisma__BelieveRoyaltyReportClient<$Result.GetResult<Prisma.$BelieveRoyaltyReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BelieveRoyaltyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BelieveRoyaltyReportCountArgs} args - Arguments to filter BelieveRoyaltyReports to count.
     * @example
     * // Count the number of BelieveRoyaltyReports
     * const count = await prisma.believeRoyaltyReport.count({
     *   where: {
     *     // ... the filter for the BelieveRoyaltyReports we want to count
     *   }
     * })
    **/
    count<T extends BelieveRoyaltyReportCountArgs>(
      args?: Subset<T, BelieveRoyaltyReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BelieveRoyaltyReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BelieveRoyaltyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BelieveRoyaltyReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BelieveRoyaltyReportAggregateArgs>(args: Subset<T, BelieveRoyaltyReportAggregateArgs>): Prisma.PrismaPromise<GetBelieveRoyaltyReportAggregateType<T>>

    /**
     * Group by BelieveRoyaltyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BelieveRoyaltyReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BelieveRoyaltyReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BelieveRoyaltyReportGroupByArgs['orderBy'] }
        : { orderBy?: BelieveRoyaltyReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BelieveRoyaltyReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBelieveRoyaltyReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BelieveRoyaltyReport model
   */
  readonly fields: BelieveRoyaltyReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BelieveRoyaltyReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BelieveRoyaltyReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    label<T extends BelieveRoyaltyReport$labelArgs<ExtArgs> = {}>(args?: Subset<T, BelieveRoyaltyReport$labelArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    baseReport<T extends BelieveRoyaltyReport$baseReportArgs<ExtArgs> = {}>(args?: Subset<T, BelieveRoyaltyReport$baseReportArgs<ExtArgs>>): Prisma__BaseRoyaltyReportClient<$Result.GetResult<Prisma.$BaseRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userReport<T extends BelieveRoyaltyReport$userReportArgs<ExtArgs> = {}>(args?: Subset<T, BelieveRoyaltyReport$userReportArgs<ExtArgs>>): Prisma__UserRoyaltyReportClient<$Result.GetResult<Prisma.$UserRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    importedReport<T extends BelieveRoyaltyReport$importedReportArgs<ExtArgs> = {}>(args?: Subset<T, BelieveRoyaltyReport$importedReportArgs<ExtArgs>>): Prisma__ImportedRoyaltyReportClient<$Result.GetResult<Prisma.$ImportedRoyaltyReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BelieveRoyaltyReport model
   */
  interface BelieveRoyaltyReportFieldRefs {
    readonly id: FieldRef<"BelieveRoyaltyReport", 'Int'>
    readonly createdAt: FieldRef<"BelieveRoyaltyReport", 'DateTime'>
    readonly updatedAt: FieldRef<"BelieveRoyaltyReport", 'DateTime'>
    readonly currency: FieldRef<"BelieveRoyaltyReport", 'Currency'>
    readonly labelId: FieldRef<"BelieveRoyaltyReport", 'Int'>
    readonly reportingMonth: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly salesMonth: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly platform: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly countryRegion: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly labelName: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly artistName: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly releaseTitle: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly trackTitle: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly upc: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly isrc: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly catalogNb: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly streamingSubscriptionType: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly releaseType: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly salesType: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly quantity: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly clientPaymentCurrency: FieldRef<"BelieveRoyaltyReport", 'String'>
    readonly unitPrice: FieldRef<"BelieveRoyaltyReport", 'Decimal'>
    readonly mechanicalFee: FieldRef<"BelieveRoyaltyReport", 'Decimal'>
    readonly grossRevenue: FieldRef<"BelieveRoyaltyReport", 'Decimal'>
    readonly clientShareRate: FieldRef<"BelieveRoyaltyReport", 'Decimal'>
    readonly netRevenue: FieldRef<"BelieveRoyaltyReport", 'Decimal'>
    readonly cmg_clientRate: FieldRef<"BelieveRoyaltyReport", 'Decimal'>
    readonly cmg_netRevenue: FieldRef<"BelieveRoyaltyReport", 'Decimal'>
    readonly baseReportId: FieldRef<"BelieveRoyaltyReport", 'Int'>
    readonly userReportId: FieldRef<"BelieveRoyaltyReport", 'Int'>
    readonly importedReportId: FieldRef<"BelieveRoyaltyReport", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BelieveRoyaltyReport findUnique
   */
  export type BelieveRoyaltyReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which BelieveRoyaltyReport to fetch.
     */
    where: BelieveRoyaltyReportWhereUniqueInput
  }

  /**
   * BelieveRoyaltyReport findUniqueOrThrow
   */
  export type BelieveRoyaltyReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which BelieveRoyaltyReport to fetch.
     */
    where: BelieveRoyaltyReportWhereUniqueInput
  }

  /**
   * BelieveRoyaltyReport findFirst
   */
  export type BelieveRoyaltyReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which BelieveRoyaltyReport to fetch.
     */
    where?: BelieveRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BelieveRoyaltyReports to fetch.
     */
    orderBy?: BelieveRoyaltyReportOrderByWithRelationInput | BelieveRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BelieveRoyaltyReports.
     */
    cursor?: BelieveRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BelieveRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BelieveRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BelieveRoyaltyReports.
     */
    distinct?: BelieveRoyaltyReportScalarFieldEnum | BelieveRoyaltyReportScalarFieldEnum[]
  }

  /**
   * BelieveRoyaltyReport findFirstOrThrow
   */
  export type BelieveRoyaltyReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which BelieveRoyaltyReport to fetch.
     */
    where?: BelieveRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BelieveRoyaltyReports to fetch.
     */
    orderBy?: BelieveRoyaltyReportOrderByWithRelationInput | BelieveRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BelieveRoyaltyReports.
     */
    cursor?: BelieveRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BelieveRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BelieveRoyaltyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BelieveRoyaltyReports.
     */
    distinct?: BelieveRoyaltyReportScalarFieldEnum | BelieveRoyaltyReportScalarFieldEnum[]
  }

  /**
   * BelieveRoyaltyReport findMany
   */
  export type BelieveRoyaltyReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter, which BelieveRoyaltyReports to fetch.
     */
    where?: BelieveRoyaltyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BelieveRoyaltyReports to fetch.
     */
    orderBy?: BelieveRoyaltyReportOrderByWithRelationInput | BelieveRoyaltyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BelieveRoyaltyReports.
     */
    cursor?: BelieveRoyaltyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BelieveRoyaltyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BelieveRoyaltyReports.
     */
    skip?: number
    distinct?: BelieveRoyaltyReportScalarFieldEnum | BelieveRoyaltyReportScalarFieldEnum[]
  }

  /**
   * BelieveRoyaltyReport create
   */
  export type BelieveRoyaltyReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    /**
     * The data needed to create a BelieveRoyaltyReport.
     */
    data: XOR<BelieveRoyaltyReportCreateInput, BelieveRoyaltyReportUncheckedCreateInput>
  }

  /**
   * BelieveRoyaltyReport createMany
   */
  export type BelieveRoyaltyReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BelieveRoyaltyReports.
     */
    data: BelieveRoyaltyReportCreateManyInput | BelieveRoyaltyReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BelieveRoyaltyReport createManyAndReturn
   */
  export type BelieveRoyaltyReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * The data used to create many BelieveRoyaltyReports.
     */
    data: BelieveRoyaltyReportCreateManyInput | BelieveRoyaltyReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BelieveRoyaltyReport update
   */
  export type BelieveRoyaltyReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    /**
     * The data needed to update a BelieveRoyaltyReport.
     */
    data: XOR<BelieveRoyaltyReportUpdateInput, BelieveRoyaltyReportUncheckedUpdateInput>
    /**
     * Choose, which BelieveRoyaltyReport to update.
     */
    where: BelieveRoyaltyReportWhereUniqueInput
  }

  /**
   * BelieveRoyaltyReport updateMany
   */
  export type BelieveRoyaltyReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BelieveRoyaltyReports.
     */
    data: XOR<BelieveRoyaltyReportUpdateManyMutationInput, BelieveRoyaltyReportUncheckedUpdateManyInput>
    /**
     * Filter which BelieveRoyaltyReports to update
     */
    where?: BelieveRoyaltyReportWhereInput
    /**
     * Limit how many BelieveRoyaltyReports to update.
     */
    limit?: number
  }

  /**
   * BelieveRoyaltyReport updateManyAndReturn
   */
  export type BelieveRoyaltyReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * The data used to update BelieveRoyaltyReports.
     */
    data: XOR<BelieveRoyaltyReportUpdateManyMutationInput, BelieveRoyaltyReportUncheckedUpdateManyInput>
    /**
     * Filter which BelieveRoyaltyReports to update
     */
    where?: BelieveRoyaltyReportWhereInput
    /**
     * Limit how many BelieveRoyaltyReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BelieveRoyaltyReport upsert
   */
  export type BelieveRoyaltyReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    /**
     * The filter to search for the BelieveRoyaltyReport to update in case it exists.
     */
    where: BelieveRoyaltyReportWhereUniqueInput
    /**
     * In case the BelieveRoyaltyReport found by the `where` argument doesn't exist, create a new BelieveRoyaltyReport with this data.
     */
    create: XOR<BelieveRoyaltyReportCreateInput, BelieveRoyaltyReportUncheckedCreateInput>
    /**
     * In case the BelieveRoyaltyReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BelieveRoyaltyReportUpdateInput, BelieveRoyaltyReportUncheckedUpdateInput>
  }

  /**
   * BelieveRoyaltyReport delete
   */
  export type BelieveRoyaltyReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
    /**
     * Filter which BelieveRoyaltyReport to delete.
     */
    where: BelieveRoyaltyReportWhereUniqueInput
  }

  /**
   * BelieveRoyaltyReport deleteMany
   */
  export type BelieveRoyaltyReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BelieveRoyaltyReports to delete
     */
    where?: BelieveRoyaltyReportWhereInput
    /**
     * Limit how many BelieveRoyaltyReports to delete.
     */
    limit?: number
  }

  /**
   * BelieveRoyaltyReport.label
   */
  export type BelieveRoyaltyReport$labelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    where?: LabelWhereInput
  }

  /**
   * BelieveRoyaltyReport.baseReport
   */
  export type BelieveRoyaltyReport$baseReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseRoyaltyReport
     */
    select?: BaseRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseRoyaltyReport
     */
    omit?: BaseRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaseRoyaltyReportInclude<ExtArgs> | null
    where?: BaseRoyaltyReportWhereInput
  }

  /**
   * BelieveRoyaltyReport.userReport
   */
  export type BelieveRoyaltyReport$userReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoyaltyReport
     */
    select?: UserRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRoyaltyReport
     */
    omit?: UserRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoyaltyReportInclude<ExtArgs> | null
    where?: UserRoyaltyReportWhereInput
  }

  /**
   * BelieveRoyaltyReport.importedReport
   */
  export type BelieveRoyaltyReport$importedReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportedRoyaltyReport
     */
    select?: ImportedRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportedRoyaltyReport
     */
    omit?: ImportedRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportedRoyaltyReportInclude<ExtArgs> | null
    where?: ImportedRoyaltyReportWhereInput
  }

  /**
   * BelieveRoyaltyReport without action
   */
  export type BelieveRoyaltyReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BelieveRoyaltyReport
     */
    select?: BelieveRoyaltyReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BelieveRoyaltyReport
     */
    omit?: BelieveRoyaltyReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BelieveRoyaltyReportInclude<ExtArgs> | null
  }


  /**
   * Model UnlinkedReport
   */

  export type AggregateUnlinkedReport = {
    _count: UnlinkedReportCountAggregateOutputType | null
    _avg: UnlinkedReportAvgAggregateOutputType | null
    _sum: UnlinkedReportSumAggregateOutputType | null
    _min: UnlinkedReportMinAggregateOutputType | null
    _max: UnlinkedReportMaxAggregateOutputType | null
  }

  export type UnlinkedReportAvgAggregateOutputType = {
    id: number | null
    count: number | null
  }

  export type UnlinkedReportSumAggregateOutputType = {
    id: number | null
    count: number | null
  }

  export type UnlinkedReportMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    distributor: $Enums.Distributor | null
    reportingMonth: string | null
    labelName: string | null
    count: number | null
  }

  export type UnlinkedReportMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    distributor: $Enums.Distributor | null
    reportingMonth: string | null
    labelName: string | null
    count: number | null
  }

  export type UnlinkedReportCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    distributor: number
    reportingMonth: number
    labelName: number
    count: number
    _all: number
  }


  export type UnlinkedReportAvgAggregateInputType = {
    id?: true
    count?: true
  }

  export type UnlinkedReportSumAggregateInputType = {
    id?: true
    count?: true
  }

  export type UnlinkedReportMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributor?: true
    reportingMonth?: true
    labelName?: true
    count?: true
  }

  export type UnlinkedReportMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributor?: true
    reportingMonth?: true
    labelName?: true
    count?: true
  }

  export type UnlinkedReportCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributor?: true
    reportingMonth?: true
    labelName?: true
    count?: true
    _all?: true
  }

  export type UnlinkedReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnlinkedReport to aggregate.
     */
    where?: UnlinkedReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnlinkedReports to fetch.
     */
    orderBy?: UnlinkedReportOrderByWithRelationInput | UnlinkedReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnlinkedReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnlinkedReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnlinkedReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnlinkedReports
    **/
    _count?: true | UnlinkedReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnlinkedReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnlinkedReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnlinkedReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnlinkedReportMaxAggregateInputType
  }

  export type GetUnlinkedReportAggregateType<T extends UnlinkedReportAggregateArgs> = {
        [P in keyof T & keyof AggregateUnlinkedReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnlinkedReport[P]>
      : GetScalarType<T[P], AggregateUnlinkedReport[P]>
  }




  export type UnlinkedReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnlinkedReportWhereInput
    orderBy?: UnlinkedReportOrderByWithAggregationInput | UnlinkedReportOrderByWithAggregationInput[]
    by: UnlinkedReportScalarFieldEnum[] | UnlinkedReportScalarFieldEnum
    having?: UnlinkedReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnlinkedReportCountAggregateInputType | true
    _avg?: UnlinkedReportAvgAggregateInputType
    _sum?: UnlinkedReportSumAggregateInputType
    _min?: UnlinkedReportMinAggregateInputType
    _max?: UnlinkedReportMaxAggregateInputType
  }

  export type UnlinkedReportGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    distributor: $Enums.Distributor
    reportingMonth: string
    labelName: string
    count: number
    _count: UnlinkedReportCountAggregateOutputType | null
    _avg: UnlinkedReportAvgAggregateOutputType | null
    _sum: UnlinkedReportSumAggregateOutputType | null
    _min: UnlinkedReportMinAggregateOutputType | null
    _max: UnlinkedReportMaxAggregateOutputType | null
  }

  type GetUnlinkedReportGroupByPayload<T extends UnlinkedReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnlinkedReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnlinkedReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnlinkedReportGroupByOutputType[P]>
            : GetScalarType<T[P], UnlinkedReportGroupByOutputType[P]>
        }
      >
    >


  export type UnlinkedReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    labelName?: boolean
    count?: boolean
    UnlinkedReportDetail?: boolean | UnlinkedReport$UnlinkedReportDetailArgs<ExtArgs>
    _count?: boolean | UnlinkedReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unlinkedReport"]>

  export type UnlinkedReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    labelName?: boolean
    count?: boolean
  }, ExtArgs["result"]["unlinkedReport"]>

  export type UnlinkedReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    labelName?: boolean
    count?: boolean
  }, ExtArgs["result"]["unlinkedReport"]>

  export type UnlinkedReportSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    labelName?: boolean
    count?: boolean
  }

  export type UnlinkedReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "distributor" | "reportingMonth" | "labelName" | "count", ExtArgs["result"]["unlinkedReport"]>
  export type UnlinkedReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UnlinkedReportDetail?: boolean | UnlinkedReport$UnlinkedReportDetailArgs<ExtArgs>
    _count?: boolean | UnlinkedReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnlinkedReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnlinkedReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnlinkedReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnlinkedReport"
    objects: {
      UnlinkedReportDetail: Prisma.$UnlinkedReportDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      distributor: $Enums.Distributor
      reportingMonth: string
      labelName: string
      count: number
    }, ExtArgs["result"]["unlinkedReport"]>
    composites: {}
  }

  type UnlinkedReportGetPayload<S extends boolean | null | undefined | UnlinkedReportDefaultArgs> = $Result.GetResult<Prisma.$UnlinkedReportPayload, S>

  type UnlinkedReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnlinkedReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnlinkedReportCountAggregateInputType | true
    }

  export interface UnlinkedReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnlinkedReport'], meta: { name: 'UnlinkedReport' } }
    /**
     * Find zero or one UnlinkedReport that matches the filter.
     * @param {UnlinkedReportFindUniqueArgs} args - Arguments to find a UnlinkedReport
     * @example
     * // Get one UnlinkedReport
     * const unlinkedReport = await prisma.unlinkedReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnlinkedReportFindUniqueArgs>(args: SelectSubset<T, UnlinkedReportFindUniqueArgs<ExtArgs>>): Prisma__UnlinkedReportClient<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnlinkedReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnlinkedReportFindUniqueOrThrowArgs} args - Arguments to find a UnlinkedReport
     * @example
     * // Get one UnlinkedReport
     * const unlinkedReport = await prisma.unlinkedReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnlinkedReportFindUniqueOrThrowArgs>(args: SelectSubset<T, UnlinkedReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnlinkedReportClient<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnlinkedReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportFindFirstArgs} args - Arguments to find a UnlinkedReport
     * @example
     * // Get one UnlinkedReport
     * const unlinkedReport = await prisma.unlinkedReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnlinkedReportFindFirstArgs>(args?: SelectSubset<T, UnlinkedReportFindFirstArgs<ExtArgs>>): Prisma__UnlinkedReportClient<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnlinkedReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportFindFirstOrThrowArgs} args - Arguments to find a UnlinkedReport
     * @example
     * // Get one UnlinkedReport
     * const unlinkedReport = await prisma.unlinkedReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnlinkedReportFindFirstOrThrowArgs>(args?: SelectSubset<T, UnlinkedReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnlinkedReportClient<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnlinkedReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnlinkedReports
     * const unlinkedReports = await prisma.unlinkedReport.findMany()
     * 
     * // Get first 10 UnlinkedReports
     * const unlinkedReports = await prisma.unlinkedReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unlinkedReportWithIdOnly = await prisma.unlinkedReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnlinkedReportFindManyArgs>(args?: SelectSubset<T, UnlinkedReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnlinkedReport.
     * @param {UnlinkedReportCreateArgs} args - Arguments to create a UnlinkedReport.
     * @example
     * // Create one UnlinkedReport
     * const UnlinkedReport = await prisma.unlinkedReport.create({
     *   data: {
     *     // ... data to create a UnlinkedReport
     *   }
     * })
     * 
     */
    create<T extends UnlinkedReportCreateArgs>(args: SelectSubset<T, UnlinkedReportCreateArgs<ExtArgs>>): Prisma__UnlinkedReportClient<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnlinkedReports.
     * @param {UnlinkedReportCreateManyArgs} args - Arguments to create many UnlinkedReports.
     * @example
     * // Create many UnlinkedReports
     * const unlinkedReport = await prisma.unlinkedReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnlinkedReportCreateManyArgs>(args?: SelectSubset<T, UnlinkedReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnlinkedReports and returns the data saved in the database.
     * @param {UnlinkedReportCreateManyAndReturnArgs} args - Arguments to create many UnlinkedReports.
     * @example
     * // Create many UnlinkedReports
     * const unlinkedReport = await prisma.unlinkedReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnlinkedReports and only return the `id`
     * const unlinkedReportWithIdOnly = await prisma.unlinkedReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnlinkedReportCreateManyAndReturnArgs>(args?: SelectSubset<T, UnlinkedReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnlinkedReport.
     * @param {UnlinkedReportDeleteArgs} args - Arguments to delete one UnlinkedReport.
     * @example
     * // Delete one UnlinkedReport
     * const UnlinkedReport = await prisma.unlinkedReport.delete({
     *   where: {
     *     // ... filter to delete one UnlinkedReport
     *   }
     * })
     * 
     */
    delete<T extends UnlinkedReportDeleteArgs>(args: SelectSubset<T, UnlinkedReportDeleteArgs<ExtArgs>>): Prisma__UnlinkedReportClient<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnlinkedReport.
     * @param {UnlinkedReportUpdateArgs} args - Arguments to update one UnlinkedReport.
     * @example
     * // Update one UnlinkedReport
     * const unlinkedReport = await prisma.unlinkedReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnlinkedReportUpdateArgs>(args: SelectSubset<T, UnlinkedReportUpdateArgs<ExtArgs>>): Prisma__UnlinkedReportClient<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnlinkedReports.
     * @param {UnlinkedReportDeleteManyArgs} args - Arguments to filter UnlinkedReports to delete.
     * @example
     * // Delete a few UnlinkedReports
     * const { count } = await prisma.unlinkedReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnlinkedReportDeleteManyArgs>(args?: SelectSubset<T, UnlinkedReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnlinkedReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnlinkedReports
     * const unlinkedReport = await prisma.unlinkedReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnlinkedReportUpdateManyArgs>(args: SelectSubset<T, UnlinkedReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnlinkedReports and returns the data updated in the database.
     * @param {UnlinkedReportUpdateManyAndReturnArgs} args - Arguments to update many UnlinkedReports.
     * @example
     * // Update many UnlinkedReports
     * const unlinkedReport = await prisma.unlinkedReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnlinkedReports and only return the `id`
     * const unlinkedReportWithIdOnly = await prisma.unlinkedReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnlinkedReportUpdateManyAndReturnArgs>(args: SelectSubset<T, UnlinkedReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnlinkedReport.
     * @param {UnlinkedReportUpsertArgs} args - Arguments to update or create a UnlinkedReport.
     * @example
     * // Update or create a UnlinkedReport
     * const unlinkedReport = await prisma.unlinkedReport.upsert({
     *   create: {
     *     // ... data to create a UnlinkedReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnlinkedReport we want to update
     *   }
     * })
     */
    upsert<T extends UnlinkedReportUpsertArgs>(args: SelectSubset<T, UnlinkedReportUpsertArgs<ExtArgs>>): Prisma__UnlinkedReportClient<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnlinkedReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportCountArgs} args - Arguments to filter UnlinkedReports to count.
     * @example
     * // Count the number of UnlinkedReports
     * const count = await prisma.unlinkedReport.count({
     *   where: {
     *     // ... the filter for the UnlinkedReports we want to count
     *   }
     * })
    **/
    count<T extends UnlinkedReportCountArgs>(
      args?: Subset<T, UnlinkedReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnlinkedReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnlinkedReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnlinkedReportAggregateArgs>(args: Subset<T, UnlinkedReportAggregateArgs>): Prisma.PrismaPromise<GetUnlinkedReportAggregateType<T>>

    /**
     * Group by UnlinkedReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnlinkedReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnlinkedReportGroupByArgs['orderBy'] }
        : { orderBy?: UnlinkedReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnlinkedReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnlinkedReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnlinkedReport model
   */
  readonly fields: UnlinkedReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnlinkedReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnlinkedReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UnlinkedReportDetail<T extends UnlinkedReport$UnlinkedReportDetailArgs<ExtArgs> = {}>(args?: Subset<T, UnlinkedReport$UnlinkedReportDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnlinkedReport model
   */
  interface UnlinkedReportFieldRefs {
    readonly id: FieldRef<"UnlinkedReport", 'Int'>
    readonly createdAt: FieldRef<"UnlinkedReport", 'DateTime'>
    readonly updatedAt: FieldRef<"UnlinkedReport", 'DateTime'>
    readonly distributor: FieldRef<"UnlinkedReport", 'Distributor'>
    readonly reportingMonth: FieldRef<"UnlinkedReport", 'String'>
    readonly labelName: FieldRef<"UnlinkedReport", 'String'>
    readonly count: FieldRef<"UnlinkedReport", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UnlinkedReport findUnique
   */
  export type UnlinkedReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportInclude<ExtArgs> | null
    /**
     * Filter, which UnlinkedReport to fetch.
     */
    where: UnlinkedReportWhereUniqueInput
  }

  /**
   * UnlinkedReport findUniqueOrThrow
   */
  export type UnlinkedReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportInclude<ExtArgs> | null
    /**
     * Filter, which UnlinkedReport to fetch.
     */
    where: UnlinkedReportWhereUniqueInput
  }

  /**
   * UnlinkedReport findFirst
   */
  export type UnlinkedReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportInclude<ExtArgs> | null
    /**
     * Filter, which UnlinkedReport to fetch.
     */
    where?: UnlinkedReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnlinkedReports to fetch.
     */
    orderBy?: UnlinkedReportOrderByWithRelationInput | UnlinkedReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnlinkedReports.
     */
    cursor?: UnlinkedReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnlinkedReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnlinkedReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnlinkedReports.
     */
    distinct?: UnlinkedReportScalarFieldEnum | UnlinkedReportScalarFieldEnum[]
  }

  /**
   * UnlinkedReport findFirstOrThrow
   */
  export type UnlinkedReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportInclude<ExtArgs> | null
    /**
     * Filter, which UnlinkedReport to fetch.
     */
    where?: UnlinkedReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnlinkedReports to fetch.
     */
    orderBy?: UnlinkedReportOrderByWithRelationInput | UnlinkedReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnlinkedReports.
     */
    cursor?: UnlinkedReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnlinkedReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnlinkedReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnlinkedReports.
     */
    distinct?: UnlinkedReportScalarFieldEnum | UnlinkedReportScalarFieldEnum[]
  }

  /**
   * UnlinkedReport findMany
   */
  export type UnlinkedReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportInclude<ExtArgs> | null
    /**
     * Filter, which UnlinkedReports to fetch.
     */
    where?: UnlinkedReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnlinkedReports to fetch.
     */
    orderBy?: UnlinkedReportOrderByWithRelationInput | UnlinkedReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnlinkedReports.
     */
    cursor?: UnlinkedReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnlinkedReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnlinkedReports.
     */
    skip?: number
    distinct?: UnlinkedReportScalarFieldEnum | UnlinkedReportScalarFieldEnum[]
  }

  /**
   * UnlinkedReport create
   */
  export type UnlinkedReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportInclude<ExtArgs> | null
    /**
     * The data needed to create a UnlinkedReport.
     */
    data: XOR<UnlinkedReportCreateInput, UnlinkedReportUncheckedCreateInput>
  }

  /**
   * UnlinkedReport createMany
   */
  export type UnlinkedReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnlinkedReports.
     */
    data: UnlinkedReportCreateManyInput | UnlinkedReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnlinkedReport createManyAndReturn
   */
  export type UnlinkedReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * The data used to create many UnlinkedReports.
     */
    data: UnlinkedReportCreateManyInput | UnlinkedReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnlinkedReport update
   */
  export type UnlinkedReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportInclude<ExtArgs> | null
    /**
     * The data needed to update a UnlinkedReport.
     */
    data: XOR<UnlinkedReportUpdateInput, UnlinkedReportUncheckedUpdateInput>
    /**
     * Choose, which UnlinkedReport to update.
     */
    where: UnlinkedReportWhereUniqueInput
  }

  /**
   * UnlinkedReport updateMany
   */
  export type UnlinkedReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnlinkedReports.
     */
    data: XOR<UnlinkedReportUpdateManyMutationInput, UnlinkedReportUncheckedUpdateManyInput>
    /**
     * Filter which UnlinkedReports to update
     */
    where?: UnlinkedReportWhereInput
    /**
     * Limit how many UnlinkedReports to update.
     */
    limit?: number
  }

  /**
   * UnlinkedReport updateManyAndReturn
   */
  export type UnlinkedReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * The data used to update UnlinkedReports.
     */
    data: XOR<UnlinkedReportUpdateManyMutationInput, UnlinkedReportUncheckedUpdateManyInput>
    /**
     * Filter which UnlinkedReports to update
     */
    where?: UnlinkedReportWhereInput
    /**
     * Limit how many UnlinkedReports to update.
     */
    limit?: number
  }

  /**
   * UnlinkedReport upsert
   */
  export type UnlinkedReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportInclude<ExtArgs> | null
    /**
     * The filter to search for the UnlinkedReport to update in case it exists.
     */
    where: UnlinkedReportWhereUniqueInput
    /**
     * In case the UnlinkedReport found by the `where` argument doesn't exist, create a new UnlinkedReport with this data.
     */
    create: XOR<UnlinkedReportCreateInput, UnlinkedReportUncheckedCreateInput>
    /**
     * In case the UnlinkedReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnlinkedReportUpdateInput, UnlinkedReportUncheckedUpdateInput>
  }

  /**
   * UnlinkedReport delete
   */
  export type UnlinkedReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportInclude<ExtArgs> | null
    /**
     * Filter which UnlinkedReport to delete.
     */
    where: UnlinkedReportWhereUniqueInput
  }

  /**
   * UnlinkedReport deleteMany
   */
  export type UnlinkedReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnlinkedReports to delete
     */
    where?: UnlinkedReportWhereInput
    /**
     * Limit how many UnlinkedReports to delete.
     */
    limit?: number
  }

  /**
   * UnlinkedReport.UnlinkedReportDetail
   */
  export type UnlinkedReport$UnlinkedReportDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
    where?: UnlinkedReportDetailWhereInput
    orderBy?: UnlinkedReportDetailOrderByWithRelationInput | UnlinkedReportDetailOrderByWithRelationInput[]
    cursor?: UnlinkedReportDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnlinkedReportDetailScalarFieldEnum | UnlinkedReportDetailScalarFieldEnum[]
  }

  /**
   * UnlinkedReport without action
   */
  export type UnlinkedReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReport
     */
    select?: UnlinkedReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReport
     */
    omit?: UnlinkedReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportInclude<ExtArgs> | null
  }


  /**
   * Model UnlinkedReportDetail
   */

  export type AggregateUnlinkedReportDetail = {
    _count: UnlinkedReportDetailCountAggregateOutputType | null
    _avg: UnlinkedReportDetailAvgAggregateOutputType | null
    _sum: UnlinkedReportDetailSumAggregateOutputType | null
    _min: UnlinkedReportDetailMinAggregateOutputType | null
    _max: UnlinkedReportDetailMaxAggregateOutputType | null
  }

  export type UnlinkedReportDetailAvgAggregateOutputType = {
    id: number | null
    unlinkedReportId: number | null
  }

  export type UnlinkedReportDetailSumAggregateOutputType = {
    id: number | null
    unlinkedReportId: number | null
  }

  export type UnlinkedReportDetailMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    unlinkedReportId: number | null
  }

  export type UnlinkedReportDetailMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    unlinkedReportId: number | null
  }

  export type UnlinkedReportDetailCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    unlinkedReportId: number
    data: number
    _all: number
  }


  export type UnlinkedReportDetailAvgAggregateInputType = {
    id?: true
    unlinkedReportId?: true
  }

  export type UnlinkedReportDetailSumAggregateInputType = {
    id?: true
    unlinkedReportId?: true
  }

  export type UnlinkedReportDetailMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    unlinkedReportId?: true
  }

  export type UnlinkedReportDetailMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    unlinkedReportId?: true
  }

  export type UnlinkedReportDetailCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    unlinkedReportId?: true
    data?: true
    _all?: true
  }

  export type UnlinkedReportDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnlinkedReportDetail to aggregate.
     */
    where?: UnlinkedReportDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnlinkedReportDetails to fetch.
     */
    orderBy?: UnlinkedReportDetailOrderByWithRelationInput | UnlinkedReportDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnlinkedReportDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnlinkedReportDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnlinkedReportDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnlinkedReportDetails
    **/
    _count?: true | UnlinkedReportDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnlinkedReportDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnlinkedReportDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnlinkedReportDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnlinkedReportDetailMaxAggregateInputType
  }

  export type GetUnlinkedReportDetailAggregateType<T extends UnlinkedReportDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateUnlinkedReportDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnlinkedReportDetail[P]>
      : GetScalarType<T[P], AggregateUnlinkedReportDetail[P]>
  }




  export type UnlinkedReportDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnlinkedReportDetailWhereInput
    orderBy?: UnlinkedReportDetailOrderByWithAggregationInput | UnlinkedReportDetailOrderByWithAggregationInput[]
    by: UnlinkedReportDetailScalarFieldEnum[] | UnlinkedReportDetailScalarFieldEnum
    having?: UnlinkedReportDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnlinkedReportDetailCountAggregateInputType | true
    _avg?: UnlinkedReportDetailAvgAggregateInputType
    _sum?: UnlinkedReportDetailSumAggregateInputType
    _min?: UnlinkedReportDetailMinAggregateInputType
    _max?: UnlinkedReportDetailMaxAggregateInputType
  }

  export type UnlinkedReportDetailGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    unlinkedReportId: number
    data: JsonValue
    _count: UnlinkedReportDetailCountAggregateOutputType | null
    _avg: UnlinkedReportDetailAvgAggregateOutputType | null
    _sum: UnlinkedReportDetailSumAggregateOutputType | null
    _min: UnlinkedReportDetailMinAggregateOutputType | null
    _max: UnlinkedReportDetailMaxAggregateOutputType | null
  }

  type GetUnlinkedReportDetailGroupByPayload<T extends UnlinkedReportDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnlinkedReportDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnlinkedReportDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnlinkedReportDetailGroupByOutputType[P]>
            : GetScalarType<T[P], UnlinkedReportDetailGroupByOutputType[P]>
        }
      >
    >


  export type UnlinkedReportDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unlinkedReportId?: boolean
    data?: boolean
    unlinkedReport?: boolean | UnlinkedReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unlinkedReportDetail"]>

  export type UnlinkedReportDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unlinkedReportId?: boolean
    data?: boolean
    unlinkedReport?: boolean | UnlinkedReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unlinkedReportDetail"]>

  export type UnlinkedReportDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unlinkedReportId?: boolean
    data?: boolean
    unlinkedReport?: boolean | UnlinkedReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unlinkedReportDetail"]>

  export type UnlinkedReportDetailSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unlinkedReportId?: boolean
    data?: boolean
  }

  export type UnlinkedReportDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "unlinkedReportId" | "data", ExtArgs["result"]["unlinkedReportDetail"]>
  export type UnlinkedReportDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unlinkedReport?: boolean | UnlinkedReportDefaultArgs<ExtArgs>
  }
  export type UnlinkedReportDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unlinkedReport?: boolean | UnlinkedReportDefaultArgs<ExtArgs>
  }
  export type UnlinkedReportDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unlinkedReport?: boolean | UnlinkedReportDefaultArgs<ExtArgs>
  }

  export type $UnlinkedReportDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnlinkedReportDetail"
    objects: {
      unlinkedReport: Prisma.$UnlinkedReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      unlinkedReportId: number
      data: Prisma.JsonValue
    }, ExtArgs["result"]["unlinkedReportDetail"]>
    composites: {}
  }

  type UnlinkedReportDetailGetPayload<S extends boolean | null | undefined | UnlinkedReportDetailDefaultArgs> = $Result.GetResult<Prisma.$UnlinkedReportDetailPayload, S>

  type UnlinkedReportDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnlinkedReportDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnlinkedReportDetailCountAggregateInputType | true
    }

  export interface UnlinkedReportDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnlinkedReportDetail'], meta: { name: 'UnlinkedReportDetail' } }
    /**
     * Find zero or one UnlinkedReportDetail that matches the filter.
     * @param {UnlinkedReportDetailFindUniqueArgs} args - Arguments to find a UnlinkedReportDetail
     * @example
     * // Get one UnlinkedReportDetail
     * const unlinkedReportDetail = await prisma.unlinkedReportDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnlinkedReportDetailFindUniqueArgs>(args: SelectSubset<T, UnlinkedReportDetailFindUniqueArgs<ExtArgs>>): Prisma__UnlinkedReportDetailClient<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnlinkedReportDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnlinkedReportDetailFindUniqueOrThrowArgs} args - Arguments to find a UnlinkedReportDetail
     * @example
     * // Get one UnlinkedReportDetail
     * const unlinkedReportDetail = await prisma.unlinkedReportDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnlinkedReportDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, UnlinkedReportDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnlinkedReportDetailClient<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnlinkedReportDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportDetailFindFirstArgs} args - Arguments to find a UnlinkedReportDetail
     * @example
     * // Get one UnlinkedReportDetail
     * const unlinkedReportDetail = await prisma.unlinkedReportDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnlinkedReportDetailFindFirstArgs>(args?: SelectSubset<T, UnlinkedReportDetailFindFirstArgs<ExtArgs>>): Prisma__UnlinkedReportDetailClient<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnlinkedReportDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportDetailFindFirstOrThrowArgs} args - Arguments to find a UnlinkedReportDetail
     * @example
     * // Get one UnlinkedReportDetail
     * const unlinkedReportDetail = await prisma.unlinkedReportDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnlinkedReportDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, UnlinkedReportDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnlinkedReportDetailClient<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnlinkedReportDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnlinkedReportDetails
     * const unlinkedReportDetails = await prisma.unlinkedReportDetail.findMany()
     * 
     * // Get first 10 UnlinkedReportDetails
     * const unlinkedReportDetails = await prisma.unlinkedReportDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unlinkedReportDetailWithIdOnly = await prisma.unlinkedReportDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnlinkedReportDetailFindManyArgs>(args?: SelectSubset<T, UnlinkedReportDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnlinkedReportDetail.
     * @param {UnlinkedReportDetailCreateArgs} args - Arguments to create a UnlinkedReportDetail.
     * @example
     * // Create one UnlinkedReportDetail
     * const UnlinkedReportDetail = await prisma.unlinkedReportDetail.create({
     *   data: {
     *     // ... data to create a UnlinkedReportDetail
     *   }
     * })
     * 
     */
    create<T extends UnlinkedReportDetailCreateArgs>(args: SelectSubset<T, UnlinkedReportDetailCreateArgs<ExtArgs>>): Prisma__UnlinkedReportDetailClient<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnlinkedReportDetails.
     * @param {UnlinkedReportDetailCreateManyArgs} args - Arguments to create many UnlinkedReportDetails.
     * @example
     * // Create many UnlinkedReportDetails
     * const unlinkedReportDetail = await prisma.unlinkedReportDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnlinkedReportDetailCreateManyArgs>(args?: SelectSubset<T, UnlinkedReportDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnlinkedReportDetails and returns the data saved in the database.
     * @param {UnlinkedReportDetailCreateManyAndReturnArgs} args - Arguments to create many UnlinkedReportDetails.
     * @example
     * // Create many UnlinkedReportDetails
     * const unlinkedReportDetail = await prisma.unlinkedReportDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnlinkedReportDetails and only return the `id`
     * const unlinkedReportDetailWithIdOnly = await prisma.unlinkedReportDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnlinkedReportDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, UnlinkedReportDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnlinkedReportDetail.
     * @param {UnlinkedReportDetailDeleteArgs} args - Arguments to delete one UnlinkedReportDetail.
     * @example
     * // Delete one UnlinkedReportDetail
     * const UnlinkedReportDetail = await prisma.unlinkedReportDetail.delete({
     *   where: {
     *     // ... filter to delete one UnlinkedReportDetail
     *   }
     * })
     * 
     */
    delete<T extends UnlinkedReportDetailDeleteArgs>(args: SelectSubset<T, UnlinkedReportDetailDeleteArgs<ExtArgs>>): Prisma__UnlinkedReportDetailClient<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnlinkedReportDetail.
     * @param {UnlinkedReportDetailUpdateArgs} args - Arguments to update one UnlinkedReportDetail.
     * @example
     * // Update one UnlinkedReportDetail
     * const unlinkedReportDetail = await prisma.unlinkedReportDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnlinkedReportDetailUpdateArgs>(args: SelectSubset<T, UnlinkedReportDetailUpdateArgs<ExtArgs>>): Prisma__UnlinkedReportDetailClient<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnlinkedReportDetails.
     * @param {UnlinkedReportDetailDeleteManyArgs} args - Arguments to filter UnlinkedReportDetails to delete.
     * @example
     * // Delete a few UnlinkedReportDetails
     * const { count } = await prisma.unlinkedReportDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnlinkedReportDetailDeleteManyArgs>(args?: SelectSubset<T, UnlinkedReportDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnlinkedReportDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnlinkedReportDetails
     * const unlinkedReportDetail = await prisma.unlinkedReportDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnlinkedReportDetailUpdateManyArgs>(args: SelectSubset<T, UnlinkedReportDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnlinkedReportDetails and returns the data updated in the database.
     * @param {UnlinkedReportDetailUpdateManyAndReturnArgs} args - Arguments to update many UnlinkedReportDetails.
     * @example
     * // Update many UnlinkedReportDetails
     * const unlinkedReportDetail = await prisma.unlinkedReportDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnlinkedReportDetails and only return the `id`
     * const unlinkedReportDetailWithIdOnly = await prisma.unlinkedReportDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnlinkedReportDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, UnlinkedReportDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnlinkedReportDetail.
     * @param {UnlinkedReportDetailUpsertArgs} args - Arguments to update or create a UnlinkedReportDetail.
     * @example
     * // Update or create a UnlinkedReportDetail
     * const unlinkedReportDetail = await prisma.unlinkedReportDetail.upsert({
     *   create: {
     *     // ... data to create a UnlinkedReportDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnlinkedReportDetail we want to update
     *   }
     * })
     */
    upsert<T extends UnlinkedReportDetailUpsertArgs>(args: SelectSubset<T, UnlinkedReportDetailUpsertArgs<ExtArgs>>): Prisma__UnlinkedReportDetailClient<$Result.GetResult<Prisma.$UnlinkedReportDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnlinkedReportDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportDetailCountArgs} args - Arguments to filter UnlinkedReportDetails to count.
     * @example
     * // Count the number of UnlinkedReportDetails
     * const count = await prisma.unlinkedReportDetail.count({
     *   where: {
     *     // ... the filter for the UnlinkedReportDetails we want to count
     *   }
     * })
    **/
    count<T extends UnlinkedReportDetailCountArgs>(
      args?: Subset<T, UnlinkedReportDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnlinkedReportDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnlinkedReportDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnlinkedReportDetailAggregateArgs>(args: Subset<T, UnlinkedReportDetailAggregateArgs>): Prisma.PrismaPromise<GetUnlinkedReportDetailAggregateType<T>>

    /**
     * Group by UnlinkedReportDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnlinkedReportDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnlinkedReportDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnlinkedReportDetailGroupByArgs['orderBy'] }
        : { orderBy?: UnlinkedReportDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnlinkedReportDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnlinkedReportDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnlinkedReportDetail model
   */
  readonly fields: UnlinkedReportDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnlinkedReportDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnlinkedReportDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unlinkedReport<T extends UnlinkedReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnlinkedReportDefaultArgs<ExtArgs>>): Prisma__UnlinkedReportClient<$Result.GetResult<Prisma.$UnlinkedReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnlinkedReportDetail model
   */
  interface UnlinkedReportDetailFieldRefs {
    readonly id: FieldRef<"UnlinkedReportDetail", 'Int'>
    readonly createdAt: FieldRef<"UnlinkedReportDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"UnlinkedReportDetail", 'DateTime'>
    readonly unlinkedReportId: FieldRef<"UnlinkedReportDetail", 'Int'>
    readonly data: FieldRef<"UnlinkedReportDetail", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UnlinkedReportDetail findUnique
   */
  export type UnlinkedReportDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
    /**
     * Filter, which UnlinkedReportDetail to fetch.
     */
    where: UnlinkedReportDetailWhereUniqueInput
  }

  /**
   * UnlinkedReportDetail findUniqueOrThrow
   */
  export type UnlinkedReportDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
    /**
     * Filter, which UnlinkedReportDetail to fetch.
     */
    where: UnlinkedReportDetailWhereUniqueInput
  }

  /**
   * UnlinkedReportDetail findFirst
   */
  export type UnlinkedReportDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
    /**
     * Filter, which UnlinkedReportDetail to fetch.
     */
    where?: UnlinkedReportDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnlinkedReportDetails to fetch.
     */
    orderBy?: UnlinkedReportDetailOrderByWithRelationInput | UnlinkedReportDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnlinkedReportDetails.
     */
    cursor?: UnlinkedReportDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnlinkedReportDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnlinkedReportDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnlinkedReportDetails.
     */
    distinct?: UnlinkedReportDetailScalarFieldEnum | UnlinkedReportDetailScalarFieldEnum[]
  }

  /**
   * UnlinkedReportDetail findFirstOrThrow
   */
  export type UnlinkedReportDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
    /**
     * Filter, which UnlinkedReportDetail to fetch.
     */
    where?: UnlinkedReportDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnlinkedReportDetails to fetch.
     */
    orderBy?: UnlinkedReportDetailOrderByWithRelationInput | UnlinkedReportDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnlinkedReportDetails.
     */
    cursor?: UnlinkedReportDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnlinkedReportDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnlinkedReportDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnlinkedReportDetails.
     */
    distinct?: UnlinkedReportDetailScalarFieldEnum | UnlinkedReportDetailScalarFieldEnum[]
  }

  /**
   * UnlinkedReportDetail findMany
   */
  export type UnlinkedReportDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
    /**
     * Filter, which UnlinkedReportDetails to fetch.
     */
    where?: UnlinkedReportDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnlinkedReportDetails to fetch.
     */
    orderBy?: UnlinkedReportDetailOrderByWithRelationInput | UnlinkedReportDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnlinkedReportDetails.
     */
    cursor?: UnlinkedReportDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnlinkedReportDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnlinkedReportDetails.
     */
    skip?: number
    distinct?: UnlinkedReportDetailScalarFieldEnum | UnlinkedReportDetailScalarFieldEnum[]
  }

  /**
   * UnlinkedReportDetail create
   */
  export type UnlinkedReportDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a UnlinkedReportDetail.
     */
    data: XOR<UnlinkedReportDetailCreateInput, UnlinkedReportDetailUncheckedCreateInput>
  }

  /**
   * UnlinkedReportDetail createMany
   */
  export type UnlinkedReportDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnlinkedReportDetails.
     */
    data: UnlinkedReportDetailCreateManyInput | UnlinkedReportDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnlinkedReportDetail createManyAndReturn
   */
  export type UnlinkedReportDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * The data used to create many UnlinkedReportDetails.
     */
    data: UnlinkedReportDetailCreateManyInput | UnlinkedReportDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnlinkedReportDetail update
   */
  export type UnlinkedReportDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a UnlinkedReportDetail.
     */
    data: XOR<UnlinkedReportDetailUpdateInput, UnlinkedReportDetailUncheckedUpdateInput>
    /**
     * Choose, which UnlinkedReportDetail to update.
     */
    where: UnlinkedReportDetailWhereUniqueInput
  }

  /**
   * UnlinkedReportDetail updateMany
   */
  export type UnlinkedReportDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnlinkedReportDetails.
     */
    data: XOR<UnlinkedReportDetailUpdateManyMutationInput, UnlinkedReportDetailUncheckedUpdateManyInput>
    /**
     * Filter which UnlinkedReportDetails to update
     */
    where?: UnlinkedReportDetailWhereInput
    /**
     * Limit how many UnlinkedReportDetails to update.
     */
    limit?: number
  }

  /**
   * UnlinkedReportDetail updateManyAndReturn
   */
  export type UnlinkedReportDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * The data used to update UnlinkedReportDetails.
     */
    data: XOR<UnlinkedReportDetailUpdateManyMutationInput, UnlinkedReportDetailUncheckedUpdateManyInput>
    /**
     * Filter which UnlinkedReportDetails to update
     */
    where?: UnlinkedReportDetailWhereInput
    /**
     * Limit how many UnlinkedReportDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnlinkedReportDetail upsert
   */
  export type UnlinkedReportDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the UnlinkedReportDetail to update in case it exists.
     */
    where: UnlinkedReportDetailWhereUniqueInput
    /**
     * In case the UnlinkedReportDetail found by the `where` argument doesn't exist, create a new UnlinkedReportDetail with this data.
     */
    create: XOR<UnlinkedReportDetailCreateInput, UnlinkedReportDetailUncheckedCreateInput>
    /**
     * In case the UnlinkedReportDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnlinkedReportDetailUpdateInput, UnlinkedReportDetailUncheckedUpdateInput>
  }

  /**
   * UnlinkedReportDetail delete
   */
  export type UnlinkedReportDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
    /**
     * Filter which UnlinkedReportDetail to delete.
     */
    where: UnlinkedReportDetailWhereUniqueInput
  }

  /**
   * UnlinkedReportDetail deleteMany
   */
  export type UnlinkedReportDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnlinkedReportDetails to delete
     */
    where?: UnlinkedReportDetailWhereInput
    /**
     * Limit how many UnlinkedReportDetails to delete.
     */
    limit?: number
  }

  /**
   * UnlinkedReportDetail without action
   */
  export type UnlinkedReportDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnlinkedReportDetail
     */
    select?: UnlinkedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnlinkedReportDetail
     */
    omit?: UnlinkedReportDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnlinkedReportDetailInclude<ExtArgs> | null
  }


  /**
   * Model FailedReportDetail
   */

  export type AggregateFailedReportDetail = {
    _count: FailedReportDetailCountAggregateOutputType | null
    _avg: FailedReportDetailAvgAggregateOutputType | null
    _sum: FailedReportDetailSumAggregateOutputType | null
    _min: FailedReportDetailMinAggregateOutputType | null
    _max: FailedReportDetailMaxAggregateOutputType | null
  }

  export type FailedReportDetailAvgAggregateOutputType = {
    id: number | null
  }

  export type FailedReportDetailSumAggregateOutputType = {
    id: number | null
  }

  export type FailedReportDetailMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    distributor: $Enums.Distributor | null
    reportingMonth: string | null
    failedReason: string | null
  }

  export type FailedReportDetailMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    distributor: $Enums.Distributor | null
    reportingMonth: string | null
    failedReason: string | null
  }

  export type FailedReportDetailCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    distributor: number
    reportingMonth: number
    failedReason: number
    data: number
    _all: number
  }


  export type FailedReportDetailAvgAggregateInputType = {
    id?: true
  }

  export type FailedReportDetailSumAggregateInputType = {
    id?: true
  }

  export type FailedReportDetailMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributor?: true
    reportingMonth?: true
    failedReason?: true
  }

  export type FailedReportDetailMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributor?: true
    reportingMonth?: true
    failedReason?: true
  }

  export type FailedReportDetailCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    distributor?: true
    reportingMonth?: true
    failedReason?: true
    data?: true
    _all?: true
  }

  export type FailedReportDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FailedReportDetail to aggregate.
     */
    where?: FailedReportDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedReportDetails to fetch.
     */
    orderBy?: FailedReportDetailOrderByWithRelationInput | FailedReportDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FailedReportDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedReportDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedReportDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FailedReportDetails
    **/
    _count?: true | FailedReportDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FailedReportDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FailedReportDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FailedReportDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FailedReportDetailMaxAggregateInputType
  }

  export type GetFailedReportDetailAggregateType<T extends FailedReportDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateFailedReportDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFailedReportDetail[P]>
      : GetScalarType<T[P], AggregateFailedReportDetail[P]>
  }




  export type FailedReportDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FailedReportDetailWhereInput
    orderBy?: FailedReportDetailOrderByWithAggregationInput | FailedReportDetailOrderByWithAggregationInput[]
    by: FailedReportDetailScalarFieldEnum[] | FailedReportDetailScalarFieldEnum
    having?: FailedReportDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FailedReportDetailCountAggregateInputType | true
    _avg?: FailedReportDetailAvgAggregateInputType
    _sum?: FailedReportDetailSumAggregateInputType
    _min?: FailedReportDetailMinAggregateInputType
    _max?: FailedReportDetailMaxAggregateInputType
  }

  export type FailedReportDetailGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    distributor: $Enums.Distributor
    reportingMonth: string
    failedReason: string
    data: JsonValue
    _count: FailedReportDetailCountAggregateOutputType | null
    _avg: FailedReportDetailAvgAggregateOutputType | null
    _sum: FailedReportDetailSumAggregateOutputType | null
    _min: FailedReportDetailMinAggregateOutputType | null
    _max: FailedReportDetailMaxAggregateOutputType | null
  }

  type GetFailedReportDetailGroupByPayload<T extends FailedReportDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FailedReportDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FailedReportDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FailedReportDetailGroupByOutputType[P]>
            : GetScalarType<T[P], FailedReportDetailGroupByOutputType[P]>
        }
      >
    >


  export type FailedReportDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    failedReason?: boolean
    data?: boolean
  }, ExtArgs["result"]["failedReportDetail"]>

  export type FailedReportDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    failedReason?: boolean
    data?: boolean
  }, ExtArgs["result"]["failedReportDetail"]>

  export type FailedReportDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    failedReason?: boolean
    data?: boolean
  }, ExtArgs["result"]["failedReportDetail"]>

  export type FailedReportDetailSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    distributor?: boolean
    reportingMonth?: boolean
    failedReason?: boolean
    data?: boolean
  }

  export type FailedReportDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "distributor" | "reportingMonth" | "failedReason" | "data", ExtArgs["result"]["failedReportDetail"]>

  export type $FailedReportDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FailedReportDetail"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      distributor: $Enums.Distributor
      reportingMonth: string
      failedReason: string
      data: Prisma.JsonValue
    }, ExtArgs["result"]["failedReportDetail"]>
    composites: {}
  }

  type FailedReportDetailGetPayload<S extends boolean | null | undefined | FailedReportDetailDefaultArgs> = $Result.GetResult<Prisma.$FailedReportDetailPayload, S>

  type FailedReportDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FailedReportDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FailedReportDetailCountAggregateInputType | true
    }

  export interface FailedReportDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FailedReportDetail'], meta: { name: 'FailedReportDetail' } }
    /**
     * Find zero or one FailedReportDetail that matches the filter.
     * @param {FailedReportDetailFindUniqueArgs} args - Arguments to find a FailedReportDetail
     * @example
     * // Get one FailedReportDetail
     * const failedReportDetail = await prisma.failedReportDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FailedReportDetailFindUniqueArgs>(args: SelectSubset<T, FailedReportDetailFindUniqueArgs<ExtArgs>>): Prisma__FailedReportDetailClient<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FailedReportDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FailedReportDetailFindUniqueOrThrowArgs} args - Arguments to find a FailedReportDetail
     * @example
     * // Get one FailedReportDetail
     * const failedReportDetail = await prisma.failedReportDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FailedReportDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, FailedReportDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FailedReportDetailClient<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FailedReportDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedReportDetailFindFirstArgs} args - Arguments to find a FailedReportDetail
     * @example
     * // Get one FailedReportDetail
     * const failedReportDetail = await prisma.failedReportDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FailedReportDetailFindFirstArgs>(args?: SelectSubset<T, FailedReportDetailFindFirstArgs<ExtArgs>>): Prisma__FailedReportDetailClient<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FailedReportDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedReportDetailFindFirstOrThrowArgs} args - Arguments to find a FailedReportDetail
     * @example
     * // Get one FailedReportDetail
     * const failedReportDetail = await prisma.failedReportDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FailedReportDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, FailedReportDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__FailedReportDetailClient<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FailedReportDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedReportDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FailedReportDetails
     * const failedReportDetails = await prisma.failedReportDetail.findMany()
     * 
     * // Get first 10 FailedReportDetails
     * const failedReportDetails = await prisma.failedReportDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const failedReportDetailWithIdOnly = await prisma.failedReportDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FailedReportDetailFindManyArgs>(args?: SelectSubset<T, FailedReportDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FailedReportDetail.
     * @param {FailedReportDetailCreateArgs} args - Arguments to create a FailedReportDetail.
     * @example
     * // Create one FailedReportDetail
     * const FailedReportDetail = await prisma.failedReportDetail.create({
     *   data: {
     *     // ... data to create a FailedReportDetail
     *   }
     * })
     * 
     */
    create<T extends FailedReportDetailCreateArgs>(args: SelectSubset<T, FailedReportDetailCreateArgs<ExtArgs>>): Prisma__FailedReportDetailClient<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FailedReportDetails.
     * @param {FailedReportDetailCreateManyArgs} args - Arguments to create many FailedReportDetails.
     * @example
     * // Create many FailedReportDetails
     * const failedReportDetail = await prisma.failedReportDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FailedReportDetailCreateManyArgs>(args?: SelectSubset<T, FailedReportDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FailedReportDetails and returns the data saved in the database.
     * @param {FailedReportDetailCreateManyAndReturnArgs} args - Arguments to create many FailedReportDetails.
     * @example
     * // Create many FailedReportDetails
     * const failedReportDetail = await prisma.failedReportDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FailedReportDetails and only return the `id`
     * const failedReportDetailWithIdOnly = await prisma.failedReportDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FailedReportDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, FailedReportDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FailedReportDetail.
     * @param {FailedReportDetailDeleteArgs} args - Arguments to delete one FailedReportDetail.
     * @example
     * // Delete one FailedReportDetail
     * const FailedReportDetail = await prisma.failedReportDetail.delete({
     *   where: {
     *     // ... filter to delete one FailedReportDetail
     *   }
     * })
     * 
     */
    delete<T extends FailedReportDetailDeleteArgs>(args: SelectSubset<T, FailedReportDetailDeleteArgs<ExtArgs>>): Prisma__FailedReportDetailClient<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FailedReportDetail.
     * @param {FailedReportDetailUpdateArgs} args - Arguments to update one FailedReportDetail.
     * @example
     * // Update one FailedReportDetail
     * const failedReportDetail = await prisma.failedReportDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FailedReportDetailUpdateArgs>(args: SelectSubset<T, FailedReportDetailUpdateArgs<ExtArgs>>): Prisma__FailedReportDetailClient<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FailedReportDetails.
     * @param {FailedReportDetailDeleteManyArgs} args - Arguments to filter FailedReportDetails to delete.
     * @example
     * // Delete a few FailedReportDetails
     * const { count } = await prisma.failedReportDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FailedReportDetailDeleteManyArgs>(args?: SelectSubset<T, FailedReportDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FailedReportDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedReportDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FailedReportDetails
     * const failedReportDetail = await prisma.failedReportDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FailedReportDetailUpdateManyArgs>(args: SelectSubset<T, FailedReportDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FailedReportDetails and returns the data updated in the database.
     * @param {FailedReportDetailUpdateManyAndReturnArgs} args - Arguments to update many FailedReportDetails.
     * @example
     * // Update many FailedReportDetails
     * const failedReportDetail = await prisma.failedReportDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FailedReportDetails and only return the `id`
     * const failedReportDetailWithIdOnly = await prisma.failedReportDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FailedReportDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, FailedReportDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FailedReportDetail.
     * @param {FailedReportDetailUpsertArgs} args - Arguments to update or create a FailedReportDetail.
     * @example
     * // Update or create a FailedReportDetail
     * const failedReportDetail = await prisma.failedReportDetail.upsert({
     *   create: {
     *     // ... data to create a FailedReportDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FailedReportDetail we want to update
     *   }
     * })
     */
    upsert<T extends FailedReportDetailUpsertArgs>(args: SelectSubset<T, FailedReportDetailUpsertArgs<ExtArgs>>): Prisma__FailedReportDetailClient<$Result.GetResult<Prisma.$FailedReportDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FailedReportDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedReportDetailCountArgs} args - Arguments to filter FailedReportDetails to count.
     * @example
     * // Count the number of FailedReportDetails
     * const count = await prisma.failedReportDetail.count({
     *   where: {
     *     // ... the filter for the FailedReportDetails we want to count
     *   }
     * })
    **/
    count<T extends FailedReportDetailCountArgs>(
      args?: Subset<T, FailedReportDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FailedReportDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FailedReportDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedReportDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FailedReportDetailAggregateArgs>(args: Subset<T, FailedReportDetailAggregateArgs>): Prisma.PrismaPromise<GetFailedReportDetailAggregateType<T>>

    /**
     * Group by FailedReportDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedReportDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FailedReportDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FailedReportDetailGroupByArgs['orderBy'] }
        : { orderBy?: FailedReportDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FailedReportDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFailedReportDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FailedReportDetail model
   */
  readonly fields: FailedReportDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FailedReportDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FailedReportDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FailedReportDetail model
   */
  interface FailedReportDetailFieldRefs {
    readonly id: FieldRef<"FailedReportDetail", 'Int'>
    readonly createdAt: FieldRef<"FailedReportDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"FailedReportDetail", 'DateTime'>
    readonly distributor: FieldRef<"FailedReportDetail", 'Distributor'>
    readonly reportingMonth: FieldRef<"FailedReportDetail", 'String'>
    readonly failedReason: FieldRef<"FailedReportDetail", 'String'>
    readonly data: FieldRef<"FailedReportDetail", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * FailedReportDetail findUnique
   */
  export type FailedReportDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * Filter, which FailedReportDetail to fetch.
     */
    where: FailedReportDetailWhereUniqueInput
  }

  /**
   * FailedReportDetail findUniqueOrThrow
   */
  export type FailedReportDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * Filter, which FailedReportDetail to fetch.
     */
    where: FailedReportDetailWhereUniqueInput
  }

  /**
   * FailedReportDetail findFirst
   */
  export type FailedReportDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * Filter, which FailedReportDetail to fetch.
     */
    where?: FailedReportDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedReportDetails to fetch.
     */
    orderBy?: FailedReportDetailOrderByWithRelationInput | FailedReportDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FailedReportDetails.
     */
    cursor?: FailedReportDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedReportDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedReportDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FailedReportDetails.
     */
    distinct?: FailedReportDetailScalarFieldEnum | FailedReportDetailScalarFieldEnum[]
  }

  /**
   * FailedReportDetail findFirstOrThrow
   */
  export type FailedReportDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * Filter, which FailedReportDetail to fetch.
     */
    where?: FailedReportDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedReportDetails to fetch.
     */
    orderBy?: FailedReportDetailOrderByWithRelationInput | FailedReportDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FailedReportDetails.
     */
    cursor?: FailedReportDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedReportDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedReportDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FailedReportDetails.
     */
    distinct?: FailedReportDetailScalarFieldEnum | FailedReportDetailScalarFieldEnum[]
  }

  /**
   * FailedReportDetail findMany
   */
  export type FailedReportDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * Filter, which FailedReportDetails to fetch.
     */
    where?: FailedReportDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedReportDetails to fetch.
     */
    orderBy?: FailedReportDetailOrderByWithRelationInput | FailedReportDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FailedReportDetails.
     */
    cursor?: FailedReportDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedReportDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedReportDetails.
     */
    skip?: number
    distinct?: FailedReportDetailScalarFieldEnum | FailedReportDetailScalarFieldEnum[]
  }

  /**
   * FailedReportDetail create
   */
  export type FailedReportDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * The data needed to create a FailedReportDetail.
     */
    data: XOR<FailedReportDetailCreateInput, FailedReportDetailUncheckedCreateInput>
  }

  /**
   * FailedReportDetail createMany
   */
  export type FailedReportDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FailedReportDetails.
     */
    data: FailedReportDetailCreateManyInput | FailedReportDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FailedReportDetail createManyAndReturn
   */
  export type FailedReportDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * The data used to create many FailedReportDetails.
     */
    data: FailedReportDetailCreateManyInput | FailedReportDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FailedReportDetail update
   */
  export type FailedReportDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * The data needed to update a FailedReportDetail.
     */
    data: XOR<FailedReportDetailUpdateInput, FailedReportDetailUncheckedUpdateInput>
    /**
     * Choose, which FailedReportDetail to update.
     */
    where: FailedReportDetailWhereUniqueInput
  }

  /**
   * FailedReportDetail updateMany
   */
  export type FailedReportDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FailedReportDetails.
     */
    data: XOR<FailedReportDetailUpdateManyMutationInput, FailedReportDetailUncheckedUpdateManyInput>
    /**
     * Filter which FailedReportDetails to update
     */
    where?: FailedReportDetailWhereInput
    /**
     * Limit how many FailedReportDetails to update.
     */
    limit?: number
  }

  /**
   * FailedReportDetail updateManyAndReturn
   */
  export type FailedReportDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * The data used to update FailedReportDetails.
     */
    data: XOR<FailedReportDetailUpdateManyMutationInput, FailedReportDetailUncheckedUpdateManyInput>
    /**
     * Filter which FailedReportDetails to update
     */
    where?: FailedReportDetailWhereInput
    /**
     * Limit how many FailedReportDetails to update.
     */
    limit?: number
  }

  /**
   * FailedReportDetail upsert
   */
  export type FailedReportDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * The filter to search for the FailedReportDetail to update in case it exists.
     */
    where: FailedReportDetailWhereUniqueInput
    /**
     * In case the FailedReportDetail found by the `where` argument doesn't exist, create a new FailedReportDetail with this data.
     */
    create: XOR<FailedReportDetailCreateInput, FailedReportDetailUncheckedCreateInput>
    /**
     * In case the FailedReportDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FailedReportDetailUpdateInput, FailedReportDetailUncheckedUpdateInput>
  }

  /**
   * FailedReportDetail delete
   */
  export type FailedReportDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
    /**
     * Filter which FailedReportDetail to delete.
     */
    where: FailedReportDetailWhereUniqueInput
  }

  /**
   * FailedReportDetail deleteMany
   */
  export type FailedReportDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FailedReportDetails to delete
     */
    where?: FailedReportDetailWhereInput
    /**
     * Limit how many FailedReportDetails to delete.
     */
    limit?: number
  }

  /**
   * FailedReportDetail without action
   */
  export type FailedReportDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedReportDetail
     */
    select?: FailedReportDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FailedReportDetail
     */
    omit?: FailedReportDetailOmit<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isRevoked: boolean | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isRevoked: boolean | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    isRevoked: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    isRevoked?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    isRevoked?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    isRevoked?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: number
    token: string
    userId: number
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    isRevoked: boolean
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRevoked?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRevoked?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRevoked?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isRevoked?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "createdAt" | "updatedAt" | "isRevoked", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      userId: number
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
      isRevoked: boolean
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'Int'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'Int'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly isRevoked: FieldRef<"RefreshToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const InitializationStatusScalarFieldEnum: {
    id: 'id',
    initialized: 'initialized',
    adminInit: 'adminInit'
  };

  export type InitializationStatusScalarFieldEnum = (typeof InitializationStatusScalarFieldEnum)[keyof typeof InitializationStatusScalarFieldEnum]


  export const S3FileScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fileName: 'fileName',
    type: 'type',
    folder: 'folder',
    bucket: 'bucket',
    key: 'key'
  };

  export type S3FileScalarFieldEnum = (typeof S3FileScalarFieldEnum)[keyof typeof S3FileScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    object: 'object',
    objectId: 'objectId',
    message: 'message',
    script: 'script',
    ip: 'ip'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    username: 'username',
    email: 'email',
    password: 'password',
    fullName: 'fullName',
    usernameDMB: 'usernameDMB',
    role: 'role',
    clientId: 'clientId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    expiresAt: 'expiresAt',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    fontSize: 'fontSize',
    mainMenuCollapsed: 'mainMenuCollapsed',
    theme: 'theme',
    language: 'language'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const UserCommsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    type: 'type',
    value: 'value'
  };

  export type UserCommsScalarFieldEnum = (typeof UserCommsScalarFieldEnum)[keyof typeof UserCommsScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    wp_id: 'wp_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientName: 'clientName',
    firstName: 'firstName',
    lastName: 'lastName',
    type: 'type',
    addressId: 'addressId',
    taxIdType: 'taxIdType',
    taxId: 'taxId',
    vatRegistered: 'vatRegistered',
    vatId: 'vatId',
    status: 'status',
    isBlocked: 'isBlocked',
    isPaymentsBlocked: 'isPaymentsBlocked',
    isPaymentInProgress: 'isPaymentInProgress',
    isPaymentDataInValidation: 'isPaymentDataInValidation'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ClientDMBScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    accessType: 'accessType',
    status: 'status',
    subclientName: 'subclientName',
    username: 'username'
  };

  export type ClientDMBScalarFieldEnum = (typeof ClientDMBScalarFieldEnum)[keyof typeof ClientDMBScalarFieldEnum]


  export const ClientPaymentInformationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    paymentMethod: 'paymentMethod',
    data: 'data'
  };

  export type ClientPaymentInformationScalarFieldEnum = (typeof ClientPaymentInformationScalarFieldEnum)[keyof typeof ClientPaymentInformationScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    uuid: 'uuid',
    type: 'type',
    ppd: 'ppd',
    status: 'status',
    docUrl: 'docUrl',
    startDate: 'startDate',
    endDate: 'endDate',
    signed: 'signed',
    signedAt: 'signedAt',
    signedBy: 'signedBy'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const BalanceScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    currency: 'currency',
    amount: 'amount',
    amountRetain: 'amountRetain',
    amountTerminated: 'amountTerminated'
  };

  export type BalanceScalarFieldEnum = (typeof BalanceScalarFieldEnum)[keyof typeof BalanceScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    type: 'type',
    description: 'description',
    amount: 'amount',
    balanceAmount: 'balanceAmount',
    reversed: 'reversed',
    distributor: 'distributor',
    balanceId: 'balanceId',
    baseReportId: 'baseReportId',
    userReportId: 'userReportId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    street: 'street',
    street2: 'street2',
    city: 'city',
    state: 'state',
    countryId: 'countryId',
    zip: 'zip'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortCode: 'shortCode',
    code: 'code'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const LabelScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    name: 'name',
    status: 'status',
    website: 'website',
    countryId: 'countryId',
    beatportStatus: 'beatportStatus',
    traxsourceStatus: 'traxsourceStatus',
    beatportUrl: 'beatportUrl',
    traxsourceUrl: 'traxsourceUrl'
  };

  export type LabelScalarFieldEnum = (typeof LabelScalarFieldEnum)[keyof typeof LabelScalarFieldEnum]


  export const ImportedRoyaltyReportScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    distributor: 'distributor',
    reportingMonth: 'reportingMonth',
    importStatus: 'importStatus',
    s3FileId: 's3FileId'
  };

  export type ImportedRoyaltyReportScalarFieldEnum = (typeof ImportedRoyaltyReportScalarFieldEnum)[keyof typeof ImportedRoyaltyReportScalarFieldEnum]


  export const BaseRoyaltyReportScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency',
    distributor: 'distributor',
    reportingMonth: 'reportingMonth',
    totalRoyalties: 'totalRoyalties',
    totalEarnings: 'totalEarnings',
    debitState: 'debitState',
    paidOn: 'paidOn',
    s3FileId: 's3FileId'
  };

  export type BaseRoyaltyReportScalarFieldEnum = (typeof BaseRoyaltyReportScalarFieldEnum)[keyof typeof BaseRoyaltyReportScalarFieldEnum]


  export const UserRoyaltyReportScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency',
    distributor: 'distributor',
    reportingMonth: 'reportingMonth',
    totalRoyalties: 'totalRoyalties',
    debitState: 'debitState',
    paidOn: 'paidOn',
    s3FileId: 's3FileId',
    baseReportId: 'baseReportId',
    clientId: 'clientId'
  };

  export type UserRoyaltyReportScalarFieldEnum = (typeof UserRoyaltyReportScalarFieldEnum)[keyof typeof UserRoyaltyReportScalarFieldEnum]


  export const KontorRoyaltyReportScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency',
    labelId: 'labelId',
    reportingMonth: 'reportingMonth',
    salesMonth: 'salesMonth',
    store: 'store',
    chType: 'chType',
    channelId: 'channelId',
    country: 'country',
    labelName: 'labelName',
    productType: 'productType',
    productTitle: 'productTitle',
    productArtist: 'productArtist',
    ean: 'ean',
    isrc: 'isrc',
    grid: 'grid',
    articleNo: 'articleNo',
    royalties: 'royalties',
    units: 'units',
    cmg_clientRate: 'cmg_clientRate',
    cmg_netRevenue: 'cmg_netRevenue',
    baseReportId: 'baseReportId',
    userReportId: 'userReportId',
    importedReportId: 'importedReportId'
  };

  export type KontorRoyaltyReportScalarFieldEnum = (typeof KontorRoyaltyReportScalarFieldEnum)[keyof typeof KontorRoyaltyReportScalarFieldEnum]


  export const BelieveRoyaltyReportScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency',
    labelId: 'labelId',
    reportingMonth: 'reportingMonth',
    salesMonth: 'salesMonth',
    platform: 'platform',
    countryRegion: 'countryRegion',
    labelName: 'labelName',
    artistName: 'artistName',
    releaseTitle: 'releaseTitle',
    trackTitle: 'trackTitle',
    upc: 'upc',
    isrc: 'isrc',
    catalogNb: 'catalogNb',
    streamingSubscriptionType: 'streamingSubscriptionType',
    releaseType: 'releaseType',
    salesType: 'salesType',
    quantity: 'quantity',
    clientPaymentCurrency: 'clientPaymentCurrency',
    unitPrice: 'unitPrice',
    mechanicalFee: 'mechanicalFee',
    grossRevenue: 'grossRevenue',
    clientShareRate: 'clientShareRate',
    netRevenue: 'netRevenue',
    cmg_clientRate: 'cmg_clientRate',
    cmg_netRevenue: 'cmg_netRevenue',
    baseReportId: 'baseReportId',
    userReportId: 'userReportId',
    importedReportId: 'importedReportId'
  };

  export type BelieveRoyaltyReportScalarFieldEnum = (typeof BelieveRoyaltyReportScalarFieldEnum)[keyof typeof BelieveRoyaltyReportScalarFieldEnum]


  export const UnlinkedReportScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    distributor: 'distributor',
    reportingMonth: 'reportingMonth',
    labelName: 'labelName',
    count: 'count'
  };

  export type UnlinkedReportScalarFieldEnum = (typeof UnlinkedReportScalarFieldEnum)[keyof typeof UnlinkedReportScalarFieldEnum]


  export const UnlinkedReportDetailScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    unlinkedReportId: 'unlinkedReportId',
    data: 'data'
  };

  export type UnlinkedReportDetailScalarFieldEnum = (typeof UnlinkedReportDetailScalarFieldEnum)[keyof typeof UnlinkedReportDetailScalarFieldEnum]


  export const FailedReportDetailScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    distributor: 'distributor',
    reportingMonth: 'reportingMonth',
    failedReason: 'failedReason',
    data: 'data'
  };

  export type FailedReportDetailScalarFieldEnum = (typeof FailedReportDetailScalarFieldEnum)[keyof typeof FailedReportDetailScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isRevoked: 'isRevoked'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'CommsChannels'
   */
  export type EnumCommsChannelsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommsChannels'>
    


  /**
   * Reference to a field of type 'CommsChannels[]'
   */
  export type ListEnumCommsChannelsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommsChannels[]'>
    


  /**
   * Reference to a field of type 'ClientType'
   */
  export type EnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType'>
    


  /**
   * Reference to a field of type 'ClientType[]'
   */
  export type ListEnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType[]'>
    


  /**
   * Reference to a field of type 'TaxIdType'
   */
  export type EnumTaxIdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxIdType'>
    


  /**
   * Reference to a field of type 'TaxIdType[]'
   */
  export type ListEnumTaxIdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaxIdType[]'>
    


  /**
   * Reference to a field of type 'ClientStatus'
   */
  export type EnumClientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientStatus'>
    


  /**
   * Reference to a field of type 'ClientStatus[]'
   */
  export type ListEnumClientStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientStatus[]'>
    


  /**
   * Reference to a field of type 'AccessTypeDMB'
   */
  export type EnumAccessTypeDMBFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessTypeDMB'>
    


  /**
   * Reference to a field of type 'AccessTypeDMB[]'
   */
  export type ListEnumAccessTypeDMBFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessTypeDMB[]'>
    


  /**
   * Reference to a field of type 'DMBStatus'
   */
  export type EnumDMBStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DMBStatus'>
    


  /**
   * Reference to a field of type 'DMBStatus[]'
   */
  export type ListEnumDMBStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DMBStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ContractType'
   */
  export type EnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType'>
    


  /**
   * Reference to a field of type 'ContractType[]'
   */
  export type ListEnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ContractStatus'
   */
  export type EnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus'>
    


  /**
   * Reference to a field of type 'ContractStatus[]'
   */
  export type ListEnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus[]'>
    


  /**
   * Reference to a field of type 'Currency'
   */
  export type EnumCurrencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Currency'>
    


  /**
   * Reference to a field of type 'Currency[]'
   */
  export type ListEnumCurrencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Currency[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'Distributor'
   */
  export type EnumDistributorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Distributor'>
    


  /**
   * Reference to a field of type 'Distributor[]'
   */
  export type ListEnumDistributorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Distributor[]'>
    


  /**
   * Reference to a field of type 'LabelStatus'
   */
  export type EnumLabelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabelStatus'>
    


  /**
   * Reference to a field of type 'LabelStatus[]'
   */
  export type ListEnumLabelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabelStatus[]'>
    


  /**
   * Reference to a field of type 'LabelRegistrationStatus'
   */
  export type EnumLabelRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabelRegistrationStatus'>
    


  /**
   * Reference to a field of type 'LabelRegistrationStatus[]'
   */
  export type ListEnumLabelRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabelRegistrationStatus[]'>
    


  /**
   * Reference to a field of type 'DebitState'
   */
  export type EnumDebitStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebitState'>
    


  /**
   * Reference to a field of type 'DebitState[]'
   */
  export type ListEnumDebitStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebitState[]'>
    
  /**
   * Deep Input Types
   */


  export type InitializationStatusWhereInput = {
    AND?: InitializationStatusWhereInput | InitializationStatusWhereInput[]
    OR?: InitializationStatusWhereInput[]
    NOT?: InitializationStatusWhereInput | InitializationStatusWhereInput[]
    id?: IntFilter<"InitializationStatus"> | number
    initialized?: BoolFilter<"InitializationStatus"> | boolean
    adminInit?: BoolFilter<"InitializationStatus"> | boolean
  }

  export type InitializationStatusOrderByWithRelationInput = {
    id?: SortOrder
    initialized?: SortOrder
    adminInit?: SortOrder
  }

  export type InitializationStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InitializationStatusWhereInput | InitializationStatusWhereInput[]
    OR?: InitializationStatusWhereInput[]
    NOT?: InitializationStatusWhereInput | InitializationStatusWhereInput[]
    initialized?: BoolFilter<"InitializationStatus"> | boolean
    adminInit?: BoolFilter<"InitializationStatus"> | boolean
  }, "id">

  export type InitializationStatusOrderByWithAggregationInput = {
    id?: SortOrder
    initialized?: SortOrder
    adminInit?: SortOrder
    _count?: InitializationStatusCountOrderByAggregateInput
    _avg?: InitializationStatusAvgOrderByAggregateInput
    _max?: InitializationStatusMaxOrderByAggregateInput
    _min?: InitializationStatusMinOrderByAggregateInput
    _sum?: InitializationStatusSumOrderByAggregateInput
  }

  export type InitializationStatusScalarWhereWithAggregatesInput = {
    AND?: InitializationStatusScalarWhereWithAggregatesInput | InitializationStatusScalarWhereWithAggregatesInput[]
    OR?: InitializationStatusScalarWhereWithAggregatesInput[]
    NOT?: InitializationStatusScalarWhereWithAggregatesInput | InitializationStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InitializationStatus"> | number
    initialized?: BoolWithAggregatesFilter<"InitializationStatus"> | boolean
    adminInit?: BoolWithAggregatesFilter<"InitializationStatus"> | boolean
  }

  export type S3FileWhereInput = {
    AND?: S3FileWhereInput | S3FileWhereInput[]
    OR?: S3FileWhereInput[]
    NOT?: S3FileWhereInput | S3FileWhereInput[]
    id?: IntFilter<"S3File"> | number
    createdAt?: DateTimeFilter<"S3File"> | Date | string
    updatedAt?: DateTimeFilter<"S3File"> | Date | string
    fileName?: StringFilter<"S3File"> | string
    type?: StringFilter<"S3File"> | string
    folder?: StringNullableFilter<"S3File"> | string | null
    bucket?: StringFilter<"S3File"> | string
    key?: StringFilter<"S3File"> | string
    UserRoyaltyReport?: UserRoyaltyReportListRelationFilter
    BaseRoyaltyReport?: BaseRoyaltyReportListRelationFilter
    ImportedRoyaltyReport?: ImportedRoyaltyReportListRelationFilter
  }

  export type S3FileOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
    type?: SortOrder
    folder?: SortOrderInput | SortOrder
    bucket?: SortOrder
    key?: SortOrder
    UserRoyaltyReport?: UserRoyaltyReportOrderByRelationAggregateInput
    BaseRoyaltyReport?: BaseRoyaltyReportOrderByRelationAggregateInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportOrderByRelationAggregateInput
  }

  export type S3FileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: S3FileWhereInput | S3FileWhereInput[]
    OR?: S3FileWhereInput[]
    NOT?: S3FileWhereInput | S3FileWhereInput[]
    createdAt?: DateTimeFilter<"S3File"> | Date | string
    updatedAt?: DateTimeFilter<"S3File"> | Date | string
    fileName?: StringFilter<"S3File"> | string
    type?: StringFilter<"S3File"> | string
    folder?: StringNullableFilter<"S3File"> | string | null
    bucket?: StringFilter<"S3File"> | string
    key?: StringFilter<"S3File"> | string
    UserRoyaltyReport?: UserRoyaltyReportListRelationFilter
    BaseRoyaltyReport?: BaseRoyaltyReportListRelationFilter
    ImportedRoyaltyReport?: ImportedRoyaltyReportListRelationFilter
  }, "id">

  export type S3FileOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
    type?: SortOrder
    folder?: SortOrderInput | SortOrder
    bucket?: SortOrder
    key?: SortOrder
    _count?: S3FileCountOrderByAggregateInput
    _avg?: S3FileAvgOrderByAggregateInput
    _max?: S3FileMaxOrderByAggregateInput
    _min?: S3FileMinOrderByAggregateInput
    _sum?: S3FileSumOrderByAggregateInput
  }

  export type S3FileScalarWhereWithAggregatesInput = {
    AND?: S3FileScalarWhereWithAggregatesInput | S3FileScalarWhereWithAggregatesInput[]
    OR?: S3FileScalarWhereWithAggregatesInput[]
    NOT?: S3FileScalarWhereWithAggregatesInput | S3FileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"S3File"> | number
    createdAt?: DateTimeWithAggregatesFilter<"S3File"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"S3File"> | Date | string
    fileName?: StringWithAggregatesFilter<"S3File"> | string
    type?: StringWithAggregatesFilter<"S3File"> | string
    folder?: StringNullableWithAggregatesFilter<"S3File"> | string | null
    bucket?: StringWithAggregatesFilter<"S3File"> | string
    key?: StringWithAggregatesFilter<"S3File"> | string
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: IntFilter<"Log"> | number
    createdAt?: DateTimeFilter<"Log"> | Date | string
    userId?: IntFilter<"Log"> | number
    object?: StringFilter<"Log"> | string
    objectId?: IntNullableFilter<"Log"> | number | null
    message?: StringFilter<"Log"> | string
    script?: StringNullableFilter<"Log"> | string | null
    ip?: StringNullableFilter<"Log"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    object?: SortOrder
    objectId?: SortOrderInput | SortOrder
    message?: SortOrder
    script?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    createdAt?: DateTimeFilter<"Log"> | Date | string
    userId?: IntFilter<"Log"> | number
    object?: StringFilter<"Log"> | string
    objectId?: IntNullableFilter<"Log"> | number | null
    message?: StringFilter<"Log"> | string
    script?: StringNullableFilter<"Log"> | string | null
    ip?: StringNullableFilter<"Log"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    object?: SortOrder
    objectId?: SortOrderInput | SortOrder
    message?: SortOrder
    script?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Log"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    userId?: IntWithAggregatesFilter<"Log"> | number
    object?: StringWithAggregatesFilter<"Log"> | string
    objectId?: IntNullableWithAggregatesFilter<"Log"> | number | null
    message?: StringWithAggregatesFilter<"Log"> | string
    script?: StringNullableWithAggregatesFilter<"Log"> | string | null
    ip?: StringNullableWithAggregatesFilter<"Log"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    usernameDMB?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    clientId?: IntNullableFilter<"User"> | number | null
    preferences?: UserPreferencesListRelationFilter
    comms?: UserCommsListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    logs?: LogListRelationFilter
    resetToken?: XOR<PasswordResetTokenNullableScalarRelationFilter, PasswordResetTokenWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    usernameDMB?: SortOrderInput | SortOrder
    role?: SortOrder
    clientId?: SortOrderInput | SortOrder
    preferences?: UserPreferencesOrderByRelationAggregateInput
    comms?: UserCommsOrderByRelationAggregateInput
    client?: ClientOrderByWithRelationInput
    logs?: LogOrderByRelationAggregateInput
    resetToken?: PasswordResetTokenOrderByWithRelationInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    usernameDMB?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    clientId?: IntNullableFilter<"User"> | number | null
    preferences?: UserPreferencesListRelationFilter
    comms?: UserCommsListRelationFilter
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    logs?: LogListRelationFilter
    resetToken?: XOR<PasswordResetTokenNullableScalarRelationFilter, PasswordResetTokenWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    usernameDMB?: SortOrderInput | SortOrder
    role?: SortOrder
    clientId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    usernameDMB?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    clientId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    userId?: IntFilter<"PasswordResetToken"> | number
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _avg?: PasswordResetTokenAvgOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
    _sum?: PasswordResetTokenSumOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    userId?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    id?: IntFilter<"UserPreferences"> | number
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    userId?: IntNullableFilter<"UserPreferences"> | number | null
    fontSize?: StringNullableFilter<"UserPreferences"> | string | null
    mainMenuCollapsed?: BoolNullableFilter<"UserPreferences"> | boolean | null
    theme?: StringNullableFilter<"UserPreferences"> | string | null
    language?: StringNullableFilter<"UserPreferences"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    fontSize?: SortOrderInput | SortOrder
    mainMenuCollapsed?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    userId?: IntNullableFilter<"UserPreferences"> | number | null
    fontSize?: StringNullableFilter<"UserPreferences"> | string | null
    mainMenuCollapsed?: BoolNullableFilter<"UserPreferences"> | boolean | null
    theme?: StringNullableFilter<"UserPreferences"> | string | null
    language?: StringNullableFilter<"UserPreferences"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    fontSize?: SortOrderInput | SortOrder
    mainMenuCollapsed?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    _count?: UserPreferencesCountOrderByAggregateInput
    _avg?: UserPreferencesAvgOrderByAggregateInput
    _max?: UserPreferencesMaxOrderByAggregateInput
    _min?: UserPreferencesMinOrderByAggregateInput
    _sum?: UserPreferencesSumOrderByAggregateInput
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPreferences"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
    userId?: IntNullableWithAggregatesFilter<"UserPreferences"> | number | null
    fontSize?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    mainMenuCollapsed?: BoolNullableWithAggregatesFilter<"UserPreferences"> | boolean | null
    theme?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    language?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
  }

  export type UserCommsWhereInput = {
    AND?: UserCommsWhereInput | UserCommsWhereInput[]
    OR?: UserCommsWhereInput[]
    NOT?: UserCommsWhereInput | UserCommsWhereInput[]
    id?: IntFilter<"UserComms"> | number
    createdAt?: DateTimeFilter<"UserComms"> | Date | string
    updatedAt?: DateTimeFilter<"UserComms"> | Date | string
    userId?: IntFilter<"UserComms"> | number
    type?: EnumCommsChannelsFilter<"UserComms"> | $Enums.CommsChannels
    value?: StringFilter<"UserComms"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserCommsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserCommsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserCommsWhereInput | UserCommsWhereInput[]
    OR?: UserCommsWhereInput[]
    NOT?: UserCommsWhereInput | UserCommsWhereInput[]
    createdAt?: DateTimeFilter<"UserComms"> | Date | string
    updatedAt?: DateTimeFilter<"UserComms"> | Date | string
    userId?: IntFilter<"UserComms"> | number
    type?: EnumCommsChannelsFilter<"UserComms"> | $Enums.CommsChannels
    value?: StringFilter<"UserComms"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserCommsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    _count?: UserCommsCountOrderByAggregateInput
    _avg?: UserCommsAvgOrderByAggregateInput
    _max?: UserCommsMaxOrderByAggregateInput
    _min?: UserCommsMinOrderByAggregateInput
    _sum?: UserCommsSumOrderByAggregateInput
  }

  export type UserCommsScalarWhereWithAggregatesInput = {
    AND?: UserCommsScalarWhereWithAggregatesInput | UserCommsScalarWhereWithAggregatesInput[]
    OR?: UserCommsScalarWhereWithAggregatesInput[]
    NOT?: UserCommsScalarWhereWithAggregatesInput | UserCommsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserComms"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserComms"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserComms"> | Date | string
    userId?: IntWithAggregatesFilter<"UserComms"> | number
    type?: EnumCommsChannelsWithAggregatesFilter<"UserComms"> | $Enums.CommsChannels
    value?: StringWithAggregatesFilter<"UserComms"> | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    wp_id?: IntNullableFilter<"Client"> | number | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    clientName?: StringFilter<"Client"> | string
    firstName?: StringFilter<"Client"> | string
    lastName?: StringFilter<"Client"> | string
    type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    addressId?: IntFilter<"Client"> | number
    taxIdType?: EnumTaxIdTypeFilter<"Client"> | $Enums.TaxIdType
    taxId?: StringFilter<"Client"> | string
    vatRegistered?: BoolFilter<"Client"> | boolean
    vatId?: StringNullableFilter<"Client"> | string | null
    status?: EnumClientStatusFilter<"Client"> | $Enums.ClientStatus
    isBlocked?: BoolNullableFilter<"Client"> | boolean | null
    isPaymentsBlocked?: BoolNullableFilter<"Client"> | boolean | null
    isPaymentInProgress?: BoolFilter<"Client"> | boolean
    isPaymentDataInValidation?: BoolFilter<"Client"> | boolean
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    dmb?: XOR<ClientDMBNullableScalarRelationFilter, ClientDMBWhereInput> | null
    balances?: BalanceListRelationFilter
    paymentData?: XOR<ClientPaymentInformationNullableScalarRelationFilter, ClientPaymentInformationWhereInput> | null
    labels?: LabelListRelationFilter
    users?: UserListRelationFilter
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
    userRoyaltyReport?: UserRoyaltyReportListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    wp_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    type?: SortOrder
    addressId?: SortOrder
    taxIdType?: SortOrder
    taxId?: SortOrder
    vatRegistered?: SortOrder
    vatId?: SortOrderInput | SortOrder
    status?: SortOrder
    isBlocked?: SortOrderInput | SortOrder
    isPaymentsBlocked?: SortOrderInput | SortOrder
    isPaymentInProgress?: SortOrder
    isPaymentDataInValidation?: SortOrder
    address?: AddressOrderByWithRelationInput
    dmb?: ClientDMBOrderByWithRelationInput
    balances?: BalanceOrderByRelationAggregateInput
    paymentData?: ClientPaymentInformationOrderByWithRelationInput
    labels?: LabelOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    contract?: ContractOrderByWithRelationInput
    userRoyaltyReport?: UserRoyaltyReportOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    wp_id?: number
    clientName?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    firstName?: StringFilter<"Client"> | string
    lastName?: StringFilter<"Client"> | string
    type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    addressId?: IntFilter<"Client"> | number
    taxIdType?: EnumTaxIdTypeFilter<"Client"> | $Enums.TaxIdType
    taxId?: StringFilter<"Client"> | string
    vatRegistered?: BoolFilter<"Client"> | boolean
    vatId?: StringNullableFilter<"Client"> | string | null
    status?: EnumClientStatusFilter<"Client"> | $Enums.ClientStatus
    isBlocked?: BoolNullableFilter<"Client"> | boolean | null
    isPaymentsBlocked?: BoolNullableFilter<"Client"> | boolean | null
    isPaymentInProgress?: BoolFilter<"Client"> | boolean
    isPaymentDataInValidation?: BoolFilter<"Client"> | boolean
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    dmb?: XOR<ClientDMBNullableScalarRelationFilter, ClientDMBWhereInput> | null
    balances?: BalanceListRelationFilter
    paymentData?: XOR<ClientPaymentInformationNullableScalarRelationFilter, ClientPaymentInformationWhereInput> | null
    labels?: LabelListRelationFilter
    users?: UserListRelationFilter
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
    userRoyaltyReport?: UserRoyaltyReportListRelationFilter
  }, "id" | "wp_id" | "clientName">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    wp_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    type?: SortOrder
    addressId?: SortOrder
    taxIdType?: SortOrder
    taxId?: SortOrder
    vatRegistered?: SortOrder
    vatId?: SortOrderInput | SortOrder
    status?: SortOrder
    isBlocked?: SortOrderInput | SortOrder
    isPaymentsBlocked?: SortOrderInput | SortOrder
    isPaymentInProgress?: SortOrder
    isPaymentDataInValidation?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    wp_id?: IntNullableWithAggregatesFilter<"Client"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    clientName?: StringWithAggregatesFilter<"Client"> | string
    firstName?: StringWithAggregatesFilter<"Client"> | string
    lastName?: StringWithAggregatesFilter<"Client"> | string
    type?: EnumClientTypeWithAggregatesFilter<"Client"> | $Enums.ClientType
    addressId?: IntWithAggregatesFilter<"Client"> | number
    taxIdType?: EnumTaxIdTypeWithAggregatesFilter<"Client"> | $Enums.TaxIdType
    taxId?: StringWithAggregatesFilter<"Client"> | string
    vatRegistered?: BoolWithAggregatesFilter<"Client"> | boolean
    vatId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    status?: EnumClientStatusWithAggregatesFilter<"Client"> | $Enums.ClientStatus
    isBlocked?: BoolNullableWithAggregatesFilter<"Client"> | boolean | null
    isPaymentsBlocked?: BoolNullableWithAggregatesFilter<"Client"> | boolean | null
    isPaymentInProgress?: BoolWithAggregatesFilter<"Client"> | boolean
    isPaymentDataInValidation?: BoolWithAggregatesFilter<"Client"> | boolean
  }

  export type ClientDMBWhereInput = {
    AND?: ClientDMBWhereInput | ClientDMBWhereInput[]
    OR?: ClientDMBWhereInput[]
    NOT?: ClientDMBWhereInput | ClientDMBWhereInput[]
    id?: IntFilter<"ClientDMB"> | number
    createdAt?: DateTimeFilter<"ClientDMB"> | Date | string
    updatedAt?: DateTimeFilter<"ClientDMB"> | Date | string
    clientId?: IntFilter<"ClientDMB"> | number
    accessType?: EnumAccessTypeDMBFilter<"ClientDMB"> | $Enums.AccessTypeDMB
    status?: EnumDMBStatusFilter<"ClientDMB"> | $Enums.DMBStatus
    subclientName?: StringNullableFilter<"ClientDMB"> | string | null
    username?: StringNullableFilter<"ClientDMB"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ClientDMBOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    accessType?: SortOrder
    status?: SortOrder
    subclientName?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ClientDMBWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clientId?: number
    AND?: ClientDMBWhereInput | ClientDMBWhereInput[]
    OR?: ClientDMBWhereInput[]
    NOT?: ClientDMBWhereInput | ClientDMBWhereInput[]
    createdAt?: DateTimeFilter<"ClientDMB"> | Date | string
    updatedAt?: DateTimeFilter<"ClientDMB"> | Date | string
    accessType?: EnumAccessTypeDMBFilter<"ClientDMB"> | $Enums.AccessTypeDMB
    status?: EnumDMBStatusFilter<"ClientDMB"> | $Enums.DMBStatus
    subclientName?: StringNullableFilter<"ClientDMB"> | string | null
    username?: StringNullableFilter<"ClientDMB"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id" | "clientId">

  export type ClientDMBOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    accessType?: SortOrder
    status?: SortOrder
    subclientName?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    _count?: ClientDMBCountOrderByAggregateInput
    _avg?: ClientDMBAvgOrderByAggregateInput
    _max?: ClientDMBMaxOrderByAggregateInput
    _min?: ClientDMBMinOrderByAggregateInput
    _sum?: ClientDMBSumOrderByAggregateInput
  }

  export type ClientDMBScalarWhereWithAggregatesInput = {
    AND?: ClientDMBScalarWhereWithAggregatesInput | ClientDMBScalarWhereWithAggregatesInput[]
    OR?: ClientDMBScalarWhereWithAggregatesInput[]
    NOT?: ClientDMBScalarWhereWithAggregatesInput | ClientDMBScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientDMB"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ClientDMB"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientDMB"> | Date | string
    clientId?: IntWithAggregatesFilter<"ClientDMB"> | number
    accessType?: EnumAccessTypeDMBWithAggregatesFilter<"ClientDMB"> | $Enums.AccessTypeDMB
    status?: EnumDMBStatusWithAggregatesFilter<"ClientDMB"> | $Enums.DMBStatus
    subclientName?: StringNullableWithAggregatesFilter<"ClientDMB"> | string | null
    username?: StringNullableWithAggregatesFilter<"ClientDMB"> | string | null
  }

  export type ClientPaymentInformationWhereInput = {
    AND?: ClientPaymentInformationWhereInput | ClientPaymentInformationWhereInput[]
    OR?: ClientPaymentInformationWhereInput[]
    NOT?: ClientPaymentInformationWhereInput | ClientPaymentInformationWhereInput[]
    id?: IntFilter<"ClientPaymentInformation"> | number
    createdAt?: DateTimeFilter<"ClientPaymentInformation"> | Date | string
    updatedAt?: DateTimeFilter<"ClientPaymentInformation"> | Date | string
    clientId?: IntFilter<"ClientPaymentInformation"> | number
    paymentMethod?: EnumPaymentMethodNullableFilter<"ClientPaymentInformation"> | $Enums.PaymentMethod | null
    data?: JsonNullableFilter<"ClientPaymentInformation">
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ClientPaymentInformationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ClientPaymentInformationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clientId?: number
    AND?: ClientPaymentInformationWhereInput | ClientPaymentInformationWhereInput[]
    OR?: ClientPaymentInformationWhereInput[]
    NOT?: ClientPaymentInformationWhereInput | ClientPaymentInformationWhereInput[]
    createdAt?: DateTimeFilter<"ClientPaymentInformation"> | Date | string
    updatedAt?: DateTimeFilter<"ClientPaymentInformation"> | Date | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"ClientPaymentInformation"> | $Enums.PaymentMethod | null
    data?: JsonNullableFilter<"ClientPaymentInformation">
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id" | "clientId">

  export type ClientPaymentInformationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    _count?: ClientPaymentInformationCountOrderByAggregateInput
    _avg?: ClientPaymentInformationAvgOrderByAggregateInput
    _max?: ClientPaymentInformationMaxOrderByAggregateInput
    _min?: ClientPaymentInformationMinOrderByAggregateInput
    _sum?: ClientPaymentInformationSumOrderByAggregateInput
  }

  export type ClientPaymentInformationScalarWhereWithAggregatesInput = {
    AND?: ClientPaymentInformationScalarWhereWithAggregatesInput | ClientPaymentInformationScalarWhereWithAggregatesInput[]
    OR?: ClientPaymentInformationScalarWhereWithAggregatesInput[]
    NOT?: ClientPaymentInformationScalarWhereWithAggregatesInput | ClientPaymentInformationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientPaymentInformation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ClientPaymentInformation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientPaymentInformation"> | Date | string
    clientId?: IntWithAggregatesFilter<"ClientPaymentInformation"> | number
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"ClientPaymentInformation"> | $Enums.PaymentMethod | null
    data?: JsonNullableWithAggregatesFilter<"ClientPaymentInformation">
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: IntFilter<"Contract"> | number
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    clientId?: IntNullableFilter<"Contract"> | number | null
    uuid?: UuidFilter<"Contract"> | string
    type?: EnumContractTypeFilter<"Contract"> | $Enums.ContractType
    ppd?: FloatNullableFilter<"Contract"> | number | null
    status?: EnumContractStatusFilter<"Contract"> | $Enums.ContractStatus
    docUrl?: StringNullableFilter<"Contract"> | string | null
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    signed?: BoolFilter<"Contract"> | boolean
    signedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    signedBy?: StringNullableFilter<"Contract"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    uuid?: SortOrder
    type?: SortOrder
    ppd?: SortOrderInput | SortOrder
    status?: SortOrder
    docUrl?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    signed?: SortOrder
    signedAt?: SortOrderInput | SortOrder
    signedBy?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clientId?: number
    uuid?: string
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    type?: EnumContractTypeFilter<"Contract"> | $Enums.ContractType
    ppd?: FloatNullableFilter<"Contract"> | number | null
    status?: EnumContractStatusFilter<"Contract"> | $Enums.ContractStatus
    docUrl?: StringNullableFilter<"Contract"> | string | null
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    signed?: BoolFilter<"Contract"> | boolean
    signedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    signedBy?: StringNullableFilter<"Contract"> | string | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id" | "clientId" | "uuid">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    uuid?: SortOrder
    type?: SortOrder
    ppd?: SortOrderInput | SortOrder
    status?: SortOrder
    docUrl?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    signed?: SortOrder
    signedAt?: SortOrderInput | SortOrder
    signedBy?: SortOrderInput | SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contract"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    clientId?: IntNullableWithAggregatesFilter<"Contract"> | number | null
    uuid?: UuidWithAggregatesFilter<"Contract"> | string
    type?: EnumContractTypeWithAggregatesFilter<"Contract"> | $Enums.ContractType
    ppd?: FloatNullableWithAggregatesFilter<"Contract"> | number | null
    status?: EnumContractStatusWithAggregatesFilter<"Contract"> | $Enums.ContractStatus
    docUrl?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    signed?: BoolWithAggregatesFilter<"Contract"> | boolean
    signedAt?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    signedBy?: StringNullableWithAggregatesFilter<"Contract"> | string | null
  }

  export type BalanceWhereInput = {
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    id?: IntFilter<"Balance"> | number
    clientId?: IntFilter<"Balance"> | number
    currency?: EnumCurrencyFilter<"Balance"> | $Enums.Currency
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type BalanceOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    amountRetain?: SortOrder
    amountTerminated?: SortOrder
    client?: ClientOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type BalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    currency_clientId?: BalanceCurrencyClientIdCompoundUniqueInput
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    clientId?: IntFilter<"Balance"> | number
    currency?: EnumCurrencyFilter<"Balance"> | $Enums.Currency
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id" | "currency_clientId">

  export type BalanceOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    amountRetain?: SortOrder
    amountTerminated?: SortOrder
    _count?: BalanceCountOrderByAggregateInput
    _avg?: BalanceAvgOrderByAggregateInput
    _max?: BalanceMaxOrderByAggregateInput
    _min?: BalanceMinOrderByAggregateInput
    _sum?: BalanceSumOrderByAggregateInput
  }

  export type BalanceScalarWhereWithAggregatesInput = {
    AND?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    OR?: BalanceScalarWhereWithAggregatesInput[]
    NOT?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Balance"> | number
    clientId?: IntWithAggregatesFilter<"Balance"> | number
    currency?: EnumCurrencyWithAggregatesFilter<"Balance"> | $Enums.Currency
    amount?: DecimalWithAggregatesFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalWithAggregatesFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalWithAggregatesFilter<"Balance"> | Decimal | DecimalJsLike | number | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    description?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    reversed?: BoolFilter<"Transaction"> | boolean
    distributor?: EnumDistributorNullableFilter<"Transaction"> | $Enums.Distributor | null
    balanceId?: IntFilter<"Transaction"> | number
    baseReportId?: IntNullableFilter<"Transaction"> | number | null
    userReportId?: IntNullableFilter<"Transaction"> | number | null
    balance?: XOR<BalanceScalarRelationFilter, BalanceWhereInput>
    baseReport?: XOR<BaseRoyaltyReportNullableScalarRelationFilter, BaseRoyaltyReportWhereInput> | null
    userReport?: XOR<UserRoyaltyReportNullableScalarRelationFilter, UserRoyaltyReportWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    balanceAmount?: SortOrder
    reversed?: SortOrder
    distributor?: SortOrderInput | SortOrder
    balanceId?: SortOrder
    baseReportId?: SortOrderInput | SortOrder
    userReportId?: SortOrderInput | SortOrder
    balance?: BalanceOrderByWithRelationInput
    baseReport?: BaseRoyaltyReportOrderByWithRelationInput
    userReport?: UserRoyaltyReportOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    description?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    reversed?: BoolFilter<"Transaction"> | boolean
    distributor?: EnumDistributorNullableFilter<"Transaction"> | $Enums.Distributor | null
    balanceId?: IntFilter<"Transaction"> | number
    baseReportId?: IntNullableFilter<"Transaction"> | number | null
    userReportId?: IntNullableFilter<"Transaction"> | number | null
    balance?: XOR<BalanceScalarRelationFilter, BalanceWhereInput>
    baseReport?: XOR<BaseRoyaltyReportNullableScalarRelationFilter, BaseRoyaltyReportWhereInput> | null
    userReport?: XOR<UserRoyaltyReportNullableScalarRelationFilter, UserRoyaltyReportWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    balanceAmount?: SortOrder
    reversed?: SortOrder
    distributor?: SortOrderInput | SortOrder
    balanceId?: SortOrder
    baseReportId?: SortOrderInput | SortOrder
    userReportId?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    description?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    reversed?: BoolWithAggregatesFilter<"Transaction"> | boolean
    distributor?: EnumDistributorNullableWithAggregatesFilter<"Transaction"> | $Enums.Distributor | null
    balanceId?: IntWithAggregatesFilter<"Transaction"> | number
    baseReportId?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    userReportId?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: IntFilter<"Address"> | number
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    street?: StringFilter<"Address"> | string
    street2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    countryId?: IntFilter<"Address"> | number
    zip?: StringFilter<"Address"> | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    client?: ClientListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    street?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    countryId?: SortOrder
    zip?: SortOrder
    country?: CountryOrderByWithRelationInput
    client?: ClientOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    street?: StringFilter<"Address"> | string
    street2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    countryId?: IntFilter<"Address"> | number
    zip?: StringFilter<"Address"> | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    client?: ClientListRelationFilter
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    street?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    countryId?: SortOrder
    zip?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Address"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    street?: StringWithAggregatesFilter<"Address"> | string
    street2?: StringNullableWithAggregatesFilter<"Address"> | string | null
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    countryId?: IntWithAggregatesFilter<"Address"> | number
    zip?: StringWithAggregatesFilter<"Address"> | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: IntFilter<"Country"> | number
    name?: StringFilter<"Country"> | string
    shortCode?: StringFilter<"Country"> | string
    code?: StringFilter<"Country"> | string
    address?: AddressListRelationFilter
    label?: LabelListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shortCode?: SortOrder
    code?: SortOrder
    address?: AddressOrderByRelationAggregateInput
    label?: LabelOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    shortCode?: string
    code?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    address?: AddressListRelationFilter
    label?: LabelListRelationFilter
  }, "id" | "shortCode" | "code">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortCode?: SortOrder
    code?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Country"> | number
    name?: StringWithAggregatesFilter<"Country"> | string
    shortCode?: StringWithAggregatesFilter<"Country"> | string
    code?: StringWithAggregatesFilter<"Country"> | string
  }

  export type LabelWhereInput = {
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    id?: IntFilter<"Label"> | number
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    clientId?: IntFilter<"Label"> | number
    name?: StringFilter<"Label"> | string
    status?: EnumLabelStatusFilter<"Label"> | $Enums.LabelStatus
    website?: StringNullableFilter<"Label"> | string | null
    countryId?: IntNullableFilter<"Label"> | number | null
    beatportStatus?: EnumLabelRegistrationStatusFilter<"Label"> | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFilter<"Label"> | $Enums.LabelRegistrationStatus
    beatportUrl?: StringNullableFilter<"Label"> | string | null
    traxsourceUrl?: StringNullableFilter<"Label"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    country?: XOR<CountryNullableScalarRelationFilter, CountryWhereInput> | null
    KontorRoyaltyReport?: KontorRoyaltyReportListRelationFilter
    BelieveRoyaltyReport?: BelieveRoyaltyReportListRelationFilter
  }

  export type LabelOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    website?: SortOrderInput | SortOrder
    countryId?: SortOrderInput | SortOrder
    beatportStatus?: SortOrder
    traxsourceStatus?: SortOrder
    beatportUrl?: SortOrderInput | SortOrder
    traxsourceUrl?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    country?: CountryOrderByWithRelationInput
    KontorRoyaltyReport?: KontorRoyaltyReportOrderByRelationAggregateInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportOrderByRelationAggregateInput
  }

  export type LabelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    clientId?: IntFilter<"Label"> | number
    status?: EnumLabelStatusFilter<"Label"> | $Enums.LabelStatus
    website?: StringNullableFilter<"Label"> | string | null
    countryId?: IntNullableFilter<"Label"> | number | null
    beatportStatus?: EnumLabelRegistrationStatusFilter<"Label"> | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFilter<"Label"> | $Enums.LabelRegistrationStatus
    beatportUrl?: StringNullableFilter<"Label"> | string | null
    traxsourceUrl?: StringNullableFilter<"Label"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    country?: XOR<CountryNullableScalarRelationFilter, CountryWhereInput> | null
    KontorRoyaltyReport?: KontorRoyaltyReportListRelationFilter
    BelieveRoyaltyReport?: BelieveRoyaltyReportListRelationFilter
  }, "id" | "name">

  export type LabelOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    website?: SortOrderInput | SortOrder
    countryId?: SortOrderInput | SortOrder
    beatportStatus?: SortOrder
    traxsourceStatus?: SortOrder
    beatportUrl?: SortOrderInput | SortOrder
    traxsourceUrl?: SortOrderInput | SortOrder
    _count?: LabelCountOrderByAggregateInput
    _avg?: LabelAvgOrderByAggregateInput
    _max?: LabelMaxOrderByAggregateInput
    _min?: LabelMinOrderByAggregateInput
    _sum?: LabelSumOrderByAggregateInput
  }

  export type LabelScalarWhereWithAggregatesInput = {
    AND?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    OR?: LabelScalarWhereWithAggregatesInput[]
    NOT?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Label"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Label"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Label"> | Date | string
    clientId?: IntWithAggregatesFilter<"Label"> | number
    name?: StringWithAggregatesFilter<"Label"> | string
    status?: EnumLabelStatusWithAggregatesFilter<"Label"> | $Enums.LabelStatus
    website?: StringNullableWithAggregatesFilter<"Label"> | string | null
    countryId?: IntNullableWithAggregatesFilter<"Label"> | number | null
    beatportStatus?: EnumLabelRegistrationStatusWithAggregatesFilter<"Label"> | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusWithAggregatesFilter<"Label"> | $Enums.LabelRegistrationStatus
    beatportUrl?: StringNullableWithAggregatesFilter<"Label"> | string | null
    traxsourceUrl?: StringNullableWithAggregatesFilter<"Label"> | string | null
  }

  export type ImportedRoyaltyReportWhereInput = {
    AND?: ImportedRoyaltyReportWhereInput | ImportedRoyaltyReportWhereInput[]
    OR?: ImportedRoyaltyReportWhereInput[]
    NOT?: ImportedRoyaltyReportWhereInput | ImportedRoyaltyReportWhereInput[]
    id?: IntFilter<"ImportedRoyaltyReport"> | number
    createdAt?: DateTimeFilter<"ImportedRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"ImportedRoyaltyReport"> | Date | string
    distributor?: EnumDistributorFilter<"ImportedRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"ImportedRoyaltyReport"> | string
    importStatus?: StringFilter<"ImportedRoyaltyReport"> | string
    s3FileId?: IntNullableFilter<"ImportedRoyaltyReport"> | number | null
    s3File?: XOR<S3FileNullableScalarRelationFilter, S3FileWhereInput> | null
    KontorRoyaltyReport?: KontorRoyaltyReportListRelationFilter
    BelieveRoyaltyReport?: BelieveRoyaltyReportListRelationFilter
  }

  export type ImportedRoyaltyReportOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    importStatus?: SortOrder
    s3FileId?: SortOrderInput | SortOrder
    s3File?: S3FileOrderByWithRelationInput
    KontorRoyaltyReport?: KontorRoyaltyReportOrderByRelationAggregateInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportOrderByRelationAggregateInput
  }

  export type ImportedRoyaltyReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImportedRoyaltyReportWhereInput | ImportedRoyaltyReportWhereInput[]
    OR?: ImportedRoyaltyReportWhereInput[]
    NOT?: ImportedRoyaltyReportWhereInput | ImportedRoyaltyReportWhereInput[]
    createdAt?: DateTimeFilter<"ImportedRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"ImportedRoyaltyReport"> | Date | string
    distributor?: EnumDistributorFilter<"ImportedRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"ImportedRoyaltyReport"> | string
    importStatus?: StringFilter<"ImportedRoyaltyReport"> | string
    s3FileId?: IntNullableFilter<"ImportedRoyaltyReport"> | number | null
    s3File?: XOR<S3FileNullableScalarRelationFilter, S3FileWhereInput> | null
    KontorRoyaltyReport?: KontorRoyaltyReportListRelationFilter
    BelieveRoyaltyReport?: BelieveRoyaltyReportListRelationFilter
  }, "id">

  export type ImportedRoyaltyReportOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    importStatus?: SortOrder
    s3FileId?: SortOrderInput | SortOrder
    _count?: ImportedRoyaltyReportCountOrderByAggregateInput
    _avg?: ImportedRoyaltyReportAvgOrderByAggregateInput
    _max?: ImportedRoyaltyReportMaxOrderByAggregateInput
    _min?: ImportedRoyaltyReportMinOrderByAggregateInput
    _sum?: ImportedRoyaltyReportSumOrderByAggregateInput
  }

  export type ImportedRoyaltyReportScalarWhereWithAggregatesInput = {
    AND?: ImportedRoyaltyReportScalarWhereWithAggregatesInput | ImportedRoyaltyReportScalarWhereWithAggregatesInput[]
    OR?: ImportedRoyaltyReportScalarWhereWithAggregatesInput[]
    NOT?: ImportedRoyaltyReportScalarWhereWithAggregatesInput | ImportedRoyaltyReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ImportedRoyaltyReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ImportedRoyaltyReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImportedRoyaltyReport"> | Date | string
    distributor?: EnumDistributorWithAggregatesFilter<"ImportedRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringWithAggregatesFilter<"ImportedRoyaltyReport"> | string
    importStatus?: StringWithAggregatesFilter<"ImportedRoyaltyReport"> | string
    s3FileId?: IntNullableWithAggregatesFilter<"ImportedRoyaltyReport"> | number | null
  }

  export type BaseRoyaltyReportWhereInput = {
    AND?: BaseRoyaltyReportWhereInput | BaseRoyaltyReportWhereInput[]
    OR?: BaseRoyaltyReportWhereInput[]
    NOT?: BaseRoyaltyReportWhereInput | BaseRoyaltyReportWhereInput[]
    id?: IntFilter<"BaseRoyaltyReport"> | number
    createdAt?: DateTimeFilter<"BaseRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"BaseRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"BaseRoyaltyReport"> | $Enums.Currency
    distributor?: EnumDistributorFilter<"BaseRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"BaseRoyaltyReport"> | string
    totalRoyalties?: FloatFilter<"BaseRoyaltyReport"> | number
    totalEarnings?: FloatFilter<"BaseRoyaltyReport"> | number
    debitState?: EnumDebitStateFilter<"BaseRoyaltyReport"> | $Enums.DebitState
    paidOn?: DateTimeNullableFilter<"BaseRoyaltyReport"> | Date | string | null
    s3FileId?: IntNullableFilter<"BaseRoyaltyReport"> | number | null
    s3File?: XOR<S3FileNullableScalarRelationFilter, S3FileWhereInput> | null
    kontorReports?: KontorRoyaltyReportListRelationFilter
    believeReports?: BelieveRoyaltyReportListRelationFilter
    userReports?: UserRoyaltyReportListRelationFilter
    Transaction?: TransactionListRelationFilter
  }

  export type BaseRoyaltyReportOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    totalRoyalties?: SortOrder
    totalEarnings?: SortOrder
    debitState?: SortOrder
    paidOn?: SortOrderInput | SortOrder
    s3FileId?: SortOrderInput | SortOrder
    s3File?: S3FileOrderByWithRelationInput
    kontorReports?: KontorRoyaltyReportOrderByRelationAggregateInput
    believeReports?: BelieveRoyaltyReportOrderByRelationAggregateInput
    userReports?: UserRoyaltyReportOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type BaseRoyaltyReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    distributor_reportingMonth?: BaseRoyaltyReportDistributorReportingMonthCompoundUniqueInput
    AND?: BaseRoyaltyReportWhereInput | BaseRoyaltyReportWhereInput[]
    OR?: BaseRoyaltyReportWhereInput[]
    NOT?: BaseRoyaltyReportWhereInput | BaseRoyaltyReportWhereInput[]
    createdAt?: DateTimeFilter<"BaseRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"BaseRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"BaseRoyaltyReport"> | $Enums.Currency
    distributor?: EnumDistributorFilter<"BaseRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"BaseRoyaltyReport"> | string
    totalRoyalties?: FloatFilter<"BaseRoyaltyReport"> | number
    totalEarnings?: FloatFilter<"BaseRoyaltyReport"> | number
    debitState?: EnumDebitStateFilter<"BaseRoyaltyReport"> | $Enums.DebitState
    paidOn?: DateTimeNullableFilter<"BaseRoyaltyReport"> | Date | string | null
    s3FileId?: IntNullableFilter<"BaseRoyaltyReport"> | number | null
    s3File?: XOR<S3FileNullableScalarRelationFilter, S3FileWhereInput> | null
    kontorReports?: KontorRoyaltyReportListRelationFilter
    believeReports?: BelieveRoyaltyReportListRelationFilter
    userReports?: UserRoyaltyReportListRelationFilter
    Transaction?: TransactionListRelationFilter
  }, "id" | "distributor_reportingMonth">

  export type BaseRoyaltyReportOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    totalRoyalties?: SortOrder
    totalEarnings?: SortOrder
    debitState?: SortOrder
    paidOn?: SortOrderInput | SortOrder
    s3FileId?: SortOrderInput | SortOrder
    _count?: BaseRoyaltyReportCountOrderByAggregateInput
    _avg?: BaseRoyaltyReportAvgOrderByAggregateInput
    _max?: BaseRoyaltyReportMaxOrderByAggregateInput
    _min?: BaseRoyaltyReportMinOrderByAggregateInput
    _sum?: BaseRoyaltyReportSumOrderByAggregateInput
  }

  export type BaseRoyaltyReportScalarWhereWithAggregatesInput = {
    AND?: BaseRoyaltyReportScalarWhereWithAggregatesInput | BaseRoyaltyReportScalarWhereWithAggregatesInput[]
    OR?: BaseRoyaltyReportScalarWhereWithAggregatesInput[]
    NOT?: BaseRoyaltyReportScalarWhereWithAggregatesInput | BaseRoyaltyReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BaseRoyaltyReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BaseRoyaltyReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BaseRoyaltyReport"> | Date | string
    currency?: EnumCurrencyWithAggregatesFilter<"BaseRoyaltyReport"> | $Enums.Currency
    distributor?: EnumDistributorWithAggregatesFilter<"BaseRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringWithAggregatesFilter<"BaseRoyaltyReport"> | string
    totalRoyalties?: FloatWithAggregatesFilter<"BaseRoyaltyReport"> | number
    totalEarnings?: FloatWithAggregatesFilter<"BaseRoyaltyReport"> | number
    debitState?: EnumDebitStateWithAggregatesFilter<"BaseRoyaltyReport"> | $Enums.DebitState
    paidOn?: DateTimeNullableWithAggregatesFilter<"BaseRoyaltyReport"> | Date | string | null
    s3FileId?: IntNullableWithAggregatesFilter<"BaseRoyaltyReport"> | number | null
  }

  export type UserRoyaltyReportWhereInput = {
    AND?: UserRoyaltyReportWhereInput | UserRoyaltyReportWhereInput[]
    OR?: UserRoyaltyReportWhereInput[]
    NOT?: UserRoyaltyReportWhereInput | UserRoyaltyReportWhereInput[]
    id?: IntFilter<"UserRoyaltyReport"> | number
    createdAt?: DateTimeFilter<"UserRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"UserRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"UserRoyaltyReport"> | $Enums.Currency
    distributor?: EnumDistributorFilter<"UserRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"UserRoyaltyReport"> | string
    totalRoyalties?: FloatFilter<"UserRoyaltyReport"> | number
    debitState?: EnumDebitStateFilter<"UserRoyaltyReport"> | $Enums.DebitState
    paidOn?: DateTimeNullableFilter<"UserRoyaltyReport"> | Date | string | null
    s3FileId?: IntNullableFilter<"UserRoyaltyReport"> | number | null
    baseReportId?: IntNullableFilter<"UserRoyaltyReport"> | number | null
    clientId?: IntNullableFilter<"UserRoyaltyReport"> | number | null
    s3File?: XOR<S3FileNullableScalarRelationFilter, S3FileWhereInput> | null
    kontorReports?: KontorRoyaltyReportListRelationFilter
    believeReports?: BelieveRoyaltyReportListRelationFilter
    baseReport?: XOR<BaseRoyaltyReportNullableScalarRelationFilter, BaseRoyaltyReportWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    transactions?: TransactionListRelationFilter
  }

  export type UserRoyaltyReportOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    totalRoyalties?: SortOrder
    debitState?: SortOrder
    paidOn?: SortOrderInput | SortOrder
    s3FileId?: SortOrderInput | SortOrder
    baseReportId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    s3File?: S3FileOrderByWithRelationInput
    kontorReports?: KontorRoyaltyReportOrderByRelationAggregateInput
    believeReports?: BelieveRoyaltyReportOrderByRelationAggregateInput
    baseReport?: BaseRoyaltyReportOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type UserRoyaltyReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserRoyaltyReportWhereInput | UserRoyaltyReportWhereInput[]
    OR?: UserRoyaltyReportWhereInput[]
    NOT?: UserRoyaltyReportWhereInput | UserRoyaltyReportWhereInput[]
    createdAt?: DateTimeFilter<"UserRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"UserRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"UserRoyaltyReport"> | $Enums.Currency
    distributor?: EnumDistributorFilter<"UserRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"UserRoyaltyReport"> | string
    totalRoyalties?: FloatFilter<"UserRoyaltyReport"> | number
    debitState?: EnumDebitStateFilter<"UserRoyaltyReport"> | $Enums.DebitState
    paidOn?: DateTimeNullableFilter<"UserRoyaltyReport"> | Date | string | null
    s3FileId?: IntNullableFilter<"UserRoyaltyReport"> | number | null
    baseReportId?: IntNullableFilter<"UserRoyaltyReport"> | number | null
    clientId?: IntNullableFilter<"UserRoyaltyReport"> | number | null
    s3File?: XOR<S3FileNullableScalarRelationFilter, S3FileWhereInput> | null
    kontorReports?: KontorRoyaltyReportListRelationFilter
    believeReports?: BelieveRoyaltyReportListRelationFilter
    baseReport?: XOR<BaseRoyaltyReportNullableScalarRelationFilter, BaseRoyaltyReportWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    transactions?: TransactionListRelationFilter
  }, "id">

  export type UserRoyaltyReportOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    totalRoyalties?: SortOrder
    debitState?: SortOrder
    paidOn?: SortOrderInput | SortOrder
    s3FileId?: SortOrderInput | SortOrder
    baseReportId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    _count?: UserRoyaltyReportCountOrderByAggregateInput
    _avg?: UserRoyaltyReportAvgOrderByAggregateInput
    _max?: UserRoyaltyReportMaxOrderByAggregateInput
    _min?: UserRoyaltyReportMinOrderByAggregateInput
    _sum?: UserRoyaltyReportSumOrderByAggregateInput
  }

  export type UserRoyaltyReportScalarWhereWithAggregatesInput = {
    AND?: UserRoyaltyReportScalarWhereWithAggregatesInput | UserRoyaltyReportScalarWhereWithAggregatesInput[]
    OR?: UserRoyaltyReportScalarWhereWithAggregatesInput[]
    NOT?: UserRoyaltyReportScalarWhereWithAggregatesInput | UserRoyaltyReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRoyaltyReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserRoyaltyReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserRoyaltyReport"> | Date | string
    currency?: EnumCurrencyWithAggregatesFilter<"UserRoyaltyReport"> | $Enums.Currency
    distributor?: EnumDistributorWithAggregatesFilter<"UserRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringWithAggregatesFilter<"UserRoyaltyReport"> | string
    totalRoyalties?: FloatWithAggregatesFilter<"UserRoyaltyReport"> | number
    debitState?: EnumDebitStateWithAggregatesFilter<"UserRoyaltyReport"> | $Enums.DebitState
    paidOn?: DateTimeNullableWithAggregatesFilter<"UserRoyaltyReport"> | Date | string | null
    s3FileId?: IntNullableWithAggregatesFilter<"UserRoyaltyReport"> | number | null
    baseReportId?: IntNullableWithAggregatesFilter<"UserRoyaltyReport"> | number | null
    clientId?: IntNullableWithAggregatesFilter<"UserRoyaltyReport"> | number | null
  }

  export type KontorRoyaltyReportWhereInput = {
    AND?: KontorRoyaltyReportWhereInput | KontorRoyaltyReportWhereInput[]
    OR?: KontorRoyaltyReportWhereInput[]
    NOT?: KontorRoyaltyReportWhereInput | KontorRoyaltyReportWhereInput[]
    id?: IntFilter<"KontorRoyaltyReport"> | number
    createdAt?: DateTimeFilter<"KontorRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"KontorRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"KontorRoyaltyReport"> | $Enums.Currency
    labelId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    reportingMonth?: StringFilter<"KontorRoyaltyReport"> | string
    salesMonth?: StringFilter<"KontorRoyaltyReport"> | string
    store?: StringFilter<"KontorRoyaltyReport"> | string
    chType?: StringNullableFilter<"KontorRoyaltyReport"> | string | null
    channelId?: StringNullableFilter<"KontorRoyaltyReport"> | string | null
    country?: StringFilter<"KontorRoyaltyReport"> | string
    labelName?: StringFilter<"KontorRoyaltyReport"> | string
    productType?: StringFilter<"KontorRoyaltyReport"> | string
    productTitle?: StringFilter<"KontorRoyaltyReport"> | string
    productArtist?: StringFilter<"KontorRoyaltyReport"> | string
    ean?: StringFilter<"KontorRoyaltyReport"> | string
    isrc?: StringFilter<"KontorRoyaltyReport"> | string
    grid?: StringFilter<"KontorRoyaltyReport"> | string
    articleNo?: StringNullableFilter<"KontorRoyaltyReport"> | string | null
    royalties?: DecimalFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    units?: IntFilter<"KontorRoyaltyReport"> | number
    cmg_clientRate?: DecimalNullableFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: DecimalNullableFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    baseReportId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    userReportId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    importedReportId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    label?: XOR<LabelNullableScalarRelationFilter, LabelWhereInput> | null
    baseReport?: XOR<BaseRoyaltyReportNullableScalarRelationFilter, BaseRoyaltyReportWhereInput> | null
    userReport?: XOR<UserRoyaltyReportNullableScalarRelationFilter, UserRoyaltyReportWhereInput> | null
    importedReport?: XOR<ImportedRoyaltyReportNullableScalarRelationFilter, ImportedRoyaltyReportWhereInput> | null
  }

  export type KontorRoyaltyReportOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    labelId?: SortOrderInput | SortOrder
    reportingMonth?: SortOrder
    salesMonth?: SortOrder
    store?: SortOrder
    chType?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    country?: SortOrder
    labelName?: SortOrder
    productType?: SortOrder
    productTitle?: SortOrder
    productArtist?: SortOrder
    ean?: SortOrder
    isrc?: SortOrder
    grid?: SortOrder
    articleNo?: SortOrderInput | SortOrder
    royalties?: SortOrder
    units?: SortOrder
    cmg_clientRate?: SortOrderInput | SortOrder
    cmg_netRevenue?: SortOrderInput | SortOrder
    baseReportId?: SortOrderInput | SortOrder
    userReportId?: SortOrderInput | SortOrder
    importedReportId?: SortOrderInput | SortOrder
    label?: LabelOrderByWithRelationInput
    baseReport?: BaseRoyaltyReportOrderByWithRelationInput
    userReport?: UserRoyaltyReportOrderByWithRelationInput
    importedReport?: ImportedRoyaltyReportOrderByWithRelationInput
  }

  export type KontorRoyaltyReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KontorRoyaltyReportWhereInput | KontorRoyaltyReportWhereInput[]
    OR?: KontorRoyaltyReportWhereInput[]
    NOT?: KontorRoyaltyReportWhereInput | KontorRoyaltyReportWhereInput[]
    createdAt?: DateTimeFilter<"KontorRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"KontorRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"KontorRoyaltyReport"> | $Enums.Currency
    labelId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    reportingMonth?: StringFilter<"KontorRoyaltyReport"> | string
    salesMonth?: StringFilter<"KontorRoyaltyReport"> | string
    store?: StringFilter<"KontorRoyaltyReport"> | string
    chType?: StringNullableFilter<"KontorRoyaltyReport"> | string | null
    channelId?: StringNullableFilter<"KontorRoyaltyReport"> | string | null
    country?: StringFilter<"KontorRoyaltyReport"> | string
    labelName?: StringFilter<"KontorRoyaltyReport"> | string
    productType?: StringFilter<"KontorRoyaltyReport"> | string
    productTitle?: StringFilter<"KontorRoyaltyReport"> | string
    productArtist?: StringFilter<"KontorRoyaltyReport"> | string
    ean?: StringFilter<"KontorRoyaltyReport"> | string
    isrc?: StringFilter<"KontorRoyaltyReport"> | string
    grid?: StringFilter<"KontorRoyaltyReport"> | string
    articleNo?: StringNullableFilter<"KontorRoyaltyReport"> | string | null
    royalties?: DecimalFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    units?: IntFilter<"KontorRoyaltyReport"> | number
    cmg_clientRate?: DecimalNullableFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: DecimalNullableFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    baseReportId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    userReportId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    importedReportId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    label?: XOR<LabelNullableScalarRelationFilter, LabelWhereInput> | null
    baseReport?: XOR<BaseRoyaltyReportNullableScalarRelationFilter, BaseRoyaltyReportWhereInput> | null
    userReport?: XOR<UserRoyaltyReportNullableScalarRelationFilter, UserRoyaltyReportWhereInput> | null
    importedReport?: XOR<ImportedRoyaltyReportNullableScalarRelationFilter, ImportedRoyaltyReportWhereInput> | null
  }, "id">

  export type KontorRoyaltyReportOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    labelId?: SortOrderInput | SortOrder
    reportingMonth?: SortOrder
    salesMonth?: SortOrder
    store?: SortOrder
    chType?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    country?: SortOrder
    labelName?: SortOrder
    productType?: SortOrder
    productTitle?: SortOrder
    productArtist?: SortOrder
    ean?: SortOrder
    isrc?: SortOrder
    grid?: SortOrder
    articleNo?: SortOrderInput | SortOrder
    royalties?: SortOrder
    units?: SortOrder
    cmg_clientRate?: SortOrderInput | SortOrder
    cmg_netRevenue?: SortOrderInput | SortOrder
    baseReportId?: SortOrderInput | SortOrder
    userReportId?: SortOrderInput | SortOrder
    importedReportId?: SortOrderInput | SortOrder
    _count?: KontorRoyaltyReportCountOrderByAggregateInput
    _avg?: KontorRoyaltyReportAvgOrderByAggregateInput
    _max?: KontorRoyaltyReportMaxOrderByAggregateInput
    _min?: KontorRoyaltyReportMinOrderByAggregateInput
    _sum?: KontorRoyaltyReportSumOrderByAggregateInput
  }

  export type KontorRoyaltyReportScalarWhereWithAggregatesInput = {
    AND?: KontorRoyaltyReportScalarWhereWithAggregatesInput | KontorRoyaltyReportScalarWhereWithAggregatesInput[]
    OR?: KontorRoyaltyReportScalarWhereWithAggregatesInput[]
    NOT?: KontorRoyaltyReportScalarWhereWithAggregatesInput | KontorRoyaltyReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KontorRoyaltyReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"KontorRoyaltyReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KontorRoyaltyReport"> | Date | string
    currency?: EnumCurrencyWithAggregatesFilter<"KontorRoyaltyReport"> | $Enums.Currency
    labelId?: IntNullableWithAggregatesFilter<"KontorRoyaltyReport"> | number | null
    reportingMonth?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    salesMonth?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    store?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    chType?: StringNullableWithAggregatesFilter<"KontorRoyaltyReport"> | string | null
    channelId?: StringNullableWithAggregatesFilter<"KontorRoyaltyReport"> | string | null
    country?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    labelName?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    productType?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    productTitle?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    productArtist?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    ean?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    isrc?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    grid?: StringWithAggregatesFilter<"KontorRoyaltyReport"> | string
    articleNo?: StringNullableWithAggregatesFilter<"KontorRoyaltyReport"> | string | null
    royalties?: DecimalWithAggregatesFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    units?: IntWithAggregatesFilter<"KontorRoyaltyReport"> | number
    cmg_clientRate?: DecimalNullableWithAggregatesFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: DecimalNullableWithAggregatesFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    baseReportId?: IntNullableWithAggregatesFilter<"KontorRoyaltyReport"> | number | null
    userReportId?: IntNullableWithAggregatesFilter<"KontorRoyaltyReport"> | number | null
    importedReportId?: IntNullableWithAggregatesFilter<"KontorRoyaltyReport"> | number | null
  }

  export type BelieveRoyaltyReportWhereInput = {
    AND?: BelieveRoyaltyReportWhereInput | BelieveRoyaltyReportWhereInput[]
    OR?: BelieveRoyaltyReportWhereInput[]
    NOT?: BelieveRoyaltyReportWhereInput | BelieveRoyaltyReportWhereInput[]
    id?: IntFilter<"BelieveRoyaltyReport"> | number
    createdAt?: DateTimeFilter<"BelieveRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"BelieveRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"BelieveRoyaltyReport"> | $Enums.Currency
    labelId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    reportingMonth?: StringFilter<"BelieveRoyaltyReport"> | string
    salesMonth?: StringFilter<"BelieveRoyaltyReport"> | string
    platform?: StringFilter<"BelieveRoyaltyReport"> | string
    countryRegion?: StringFilter<"BelieveRoyaltyReport"> | string
    labelName?: StringFilter<"BelieveRoyaltyReport"> | string
    artistName?: StringFilter<"BelieveRoyaltyReport"> | string
    releaseTitle?: StringFilter<"BelieveRoyaltyReport"> | string
    trackTitle?: StringFilter<"BelieveRoyaltyReport"> | string
    upc?: StringFilter<"BelieveRoyaltyReport"> | string
    isrc?: StringFilter<"BelieveRoyaltyReport"> | string
    catalogNb?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    streamingSubscriptionType?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    releaseType?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    salesType?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    quantity?: StringFilter<"BelieveRoyaltyReport"> | string
    clientPaymentCurrency?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    unitPrice?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    mechanicalFee?: DecimalNullableFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: DecimalNullableFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: DecimalNullableFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    baseReportId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    userReportId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    importedReportId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    label?: XOR<LabelNullableScalarRelationFilter, LabelWhereInput> | null
    baseReport?: XOR<BaseRoyaltyReportNullableScalarRelationFilter, BaseRoyaltyReportWhereInput> | null
    userReport?: XOR<UserRoyaltyReportNullableScalarRelationFilter, UserRoyaltyReportWhereInput> | null
    importedReport?: XOR<ImportedRoyaltyReportNullableScalarRelationFilter, ImportedRoyaltyReportWhereInput> | null
  }

  export type BelieveRoyaltyReportOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    labelId?: SortOrderInput | SortOrder
    reportingMonth?: SortOrder
    salesMonth?: SortOrder
    platform?: SortOrder
    countryRegion?: SortOrder
    labelName?: SortOrder
    artistName?: SortOrder
    releaseTitle?: SortOrder
    trackTitle?: SortOrder
    upc?: SortOrder
    isrc?: SortOrder
    catalogNb?: SortOrderInput | SortOrder
    streamingSubscriptionType?: SortOrderInput | SortOrder
    releaseType?: SortOrderInput | SortOrder
    salesType?: SortOrderInput | SortOrder
    quantity?: SortOrder
    clientPaymentCurrency?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    mechanicalFee?: SortOrderInput | SortOrder
    grossRevenue?: SortOrder
    clientShareRate?: SortOrder
    netRevenue?: SortOrder
    cmg_clientRate?: SortOrderInput | SortOrder
    cmg_netRevenue?: SortOrderInput | SortOrder
    baseReportId?: SortOrderInput | SortOrder
    userReportId?: SortOrderInput | SortOrder
    importedReportId?: SortOrderInput | SortOrder
    label?: LabelOrderByWithRelationInput
    baseReport?: BaseRoyaltyReportOrderByWithRelationInput
    userReport?: UserRoyaltyReportOrderByWithRelationInput
    importedReport?: ImportedRoyaltyReportOrderByWithRelationInput
  }

  export type BelieveRoyaltyReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BelieveRoyaltyReportWhereInput | BelieveRoyaltyReportWhereInput[]
    OR?: BelieveRoyaltyReportWhereInput[]
    NOT?: BelieveRoyaltyReportWhereInput | BelieveRoyaltyReportWhereInput[]
    createdAt?: DateTimeFilter<"BelieveRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"BelieveRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"BelieveRoyaltyReport"> | $Enums.Currency
    labelId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    reportingMonth?: StringFilter<"BelieveRoyaltyReport"> | string
    salesMonth?: StringFilter<"BelieveRoyaltyReport"> | string
    platform?: StringFilter<"BelieveRoyaltyReport"> | string
    countryRegion?: StringFilter<"BelieveRoyaltyReport"> | string
    labelName?: StringFilter<"BelieveRoyaltyReport"> | string
    artistName?: StringFilter<"BelieveRoyaltyReport"> | string
    releaseTitle?: StringFilter<"BelieveRoyaltyReport"> | string
    trackTitle?: StringFilter<"BelieveRoyaltyReport"> | string
    upc?: StringFilter<"BelieveRoyaltyReport"> | string
    isrc?: StringFilter<"BelieveRoyaltyReport"> | string
    catalogNb?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    streamingSubscriptionType?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    releaseType?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    salesType?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    quantity?: StringFilter<"BelieveRoyaltyReport"> | string
    clientPaymentCurrency?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    unitPrice?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    mechanicalFee?: DecimalNullableFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: DecimalNullableFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: DecimalNullableFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    baseReportId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    userReportId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    importedReportId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    label?: XOR<LabelNullableScalarRelationFilter, LabelWhereInput> | null
    baseReport?: XOR<BaseRoyaltyReportNullableScalarRelationFilter, BaseRoyaltyReportWhereInput> | null
    userReport?: XOR<UserRoyaltyReportNullableScalarRelationFilter, UserRoyaltyReportWhereInput> | null
    importedReport?: XOR<ImportedRoyaltyReportNullableScalarRelationFilter, ImportedRoyaltyReportWhereInput> | null
  }, "id">

  export type BelieveRoyaltyReportOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    labelId?: SortOrderInput | SortOrder
    reportingMonth?: SortOrder
    salesMonth?: SortOrder
    platform?: SortOrder
    countryRegion?: SortOrder
    labelName?: SortOrder
    artistName?: SortOrder
    releaseTitle?: SortOrder
    trackTitle?: SortOrder
    upc?: SortOrder
    isrc?: SortOrder
    catalogNb?: SortOrderInput | SortOrder
    streamingSubscriptionType?: SortOrderInput | SortOrder
    releaseType?: SortOrderInput | SortOrder
    salesType?: SortOrderInput | SortOrder
    quantity?: SortOrder
    clientPaymentCurrency?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    mechanicalFee?: SortOrderInput | SortOrder
    grossRevenue?: SortOrder
    clientShareRate?: SortOrder
    netRevenue?: SortOrder
    cmg_clientRate?: SortOrderInput | SortOrder
    cmg_netRevenue?: SortOrderInput | SortOrder
    baseReportId?: SortOrderInput | SortOrder
    userReportId?: SortOrderInput | SortOrder
    importedReportId?: SortOrderInput | SortOrder
    _count?: BelieveRoyaltyReportCountOrderByAggregateInput
    _avg?: BelieveRoyaltyReportAvgOrderByAggregateInput
    _max?: BelieveRoyaltyReportMaxOrderByAggregateInput
    _min?: BelieveRoyaltyReportMinOrderByAggregateInput
    _sum?: BelieveRoyaltyReportSumOrderByAggregateInput
  }

  export type BelieveRoyaltyReportScalarWhereWithAggregatesInput = {
    AND?: BelieveRoyaltyReportScalarWhereWithAggregatesInput | BelieveRoyaltyReportScalarWhereWithAggregatesInput[]
    OR?: BelieveRoyaltyReportScalarWhereWithAggregatesInput[]
    NOT?: BelieveRoyaltyReportScalarWhereWithAggregatesInput | BelieveRoyaltyReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BelieveRoyaltyReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BelieveRoyaltyReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BelieveRoyaltyReport"> | Date | string
    currency?: EnumCurrencyWithAggregatesFilter<"BelieveRoyaltyReport"> | $Enums.Currency
    labelId?: IntNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | number | null
    reportingMonth?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    salesMonth?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    platform?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    countryRegion?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    labelName?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    artistName?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    releaseTitle?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    trackTitle?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    upc?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    isrc?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    catalogNb?: StringNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | string | null
    streamingSubscriptionType?: StringNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | string | null
    releaseType?: StringNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | string | null
    salesType?: StringNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | string | null
    quantity?: StringWithAggregatesFilter<"BelieveRoyaltyReport"> | string
    clientPaymentCurrency?: StringNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | string | null
    unitPrice?: DecimalWithAggregatesFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    mechanicalFee?: DecimalNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalWithAggregatesFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalWithAggregatesFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalWithAggregatesFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: DecimalNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: DecimalNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    baseReportId?: IntNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | number | null
    userReportId?: IntNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | number | null
    importedReportId?: IntNullableWithAggregatesFilter<"BelieveRoyaltyReport"> | number | null
  }

  export type UnlinkedReportWhereInput = {
    AND?: UnlinkedReportWhereInput | UnlinkedReportWhereInput[]
    OR?: UnlinkedReportWhereInput[]
    NOT?: UnlinkedReportWhereInput | UnlinkedReportWhereInput[]
    id?: IntFilter<"UnlinkedReport"> | number
    createdAt?: DateTimeFilter<"UnlinkedReport"> | Date | string
    updatedAt?: DateTimeFilter<"UnlinkedReport"> | Date | string
    distributor?: EnumDistributorFilter<"UnlinkedReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"UnlinkedReport"> | string
    labelName?: StringFilter<"UnlinkedReport"> | string
    count?: IntFilter<"UnlinkedReport"> | number
    UnlinkedReportDetail?: UnlinkedReportDetailListRelationFilter
  }

  export type UnlinkedReportOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    labelName?: SortOrder
    count?: SortOrder
    UnlinkedReportDetail?: UnlinkedReportDetailOrderByRelationAggregateInput
  }

  export type UnlinkedReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UnlinkedReportWhereInput | UnlinkedReportWhereInput[]
    OR?: UnlinkedReportWhereInput[]
    NOT?: UnlinkedReportWhereInput | UnlinkedReportWhereInput[]
    createdAt?: DateTimeFilter<"UnlinkedReport"> | Date | string
    updatedAt?: DateTimeFilter<"UnlinkedReport"> | Date | string
    distributor?: EnumDistributorFilter<"UnlinkedReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"UnlinkedReport"> | string
    labelName?: StringFilter<"UnlinkedReport"> | string
    count?: IntFilter<"UnlinkedReport"> | number
    UnlinkedReportDetail?: UnlinkedReportDetailListRelationFilter
  }, "id">

  export type UnlinkedReportOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    labelName?: SortOrder
    count?: SortOrder
    _count?: UnlinkedReportCountOrderByAggregateInput
    _avg?: UnlinkedReportAvgOrderByAggregateInput
    _max?: UnlinkedReportMaxOrderByAggregateInput
    _min?: UnlinkedReportMinOrderByAggregateInput
    _sum?: UnlinkedReportSumOrderByAggregateInput
  }

  export type UnlinkedReportScalarWhereWithAggregatesInput = {
    AND?: UnlinkedReportScalarWhereWithAggregatesInput | UnlinkedReportScalarWhereWithAggregatesInput[]
    OR?: UnlinkedReportScalarWhereWithAggregatesInput[]
    NOT?: UnlinkedReportScalarWhereWithAggregatesInput | UnlinkedReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UnlinkedReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UnlinkedReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnlinkedReport"> | Date | string
    distributor?: EnumDistributorWithAggregatesFilter<"UnlinkedReport"> | $Enums.Distributor
    reportingMonth?: StringWithAggregatesFilter<"UnlinkedReport"> | string
    labelName?: StringWithAggregatesFilter<"UnlinkedReport"> | string
    count?: IntWithAggregatesFilter<"UnlinkedReport"> | number
  }

  export type UnlinkedReportDetailWhereInput = {
    AND?: UnlinkedReportDetailWhereInput | UnlinkedReportDetailWhereInput[]
    OR?: UnlinkedReportDetailWhereInput[]
    NOT?: UnlinkedReportDetailWhereInput | UnlinkedReportDetailWhereInput[]
    id?: IntFilter<"UnlinkedReportDetail"> | number
    createdAt?: DateTimeFilter<"UnlinkedReportDetail"> | Date | string
    updatedAt?: DateTimeFilter<"UnlinkedReportDetail"> | Date | string
    unlinkedReportId?: IntFilter<"UnlinkedReportDetail"> | number
    data?: JsonFilter<"UnlinkedReportDetail">
    unlinkedReport?: XOR<UnlinkedReportScalarRelationFilter, UnlinkedReportWhereInput>
  }

  export type UnlinkedReportDetailOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unlinkedReportId?: SortOrder
    data?: SortOrder
    unlinkedReport?: UnlinkedReportOrderByWithRelationInput
  }

  export type UnlinkedReportDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UnlinkedReportDetailWhereInput | UnlinkedReportDetailWhereInput[]
    OR?: UnlinkedReportDetailWhereInput[]
    NOT?: UnlinkedReportDetailWhereInput | UnlinkedReportDetailWhereInput[]
    createdAt?: DateTimeFilter<"UnlinkedReportDetail"> | Date | string
    updatedAt?: DateTimeFilter<"UnlinkedReportDetail"> | Date | string
    unlinkedReportId?: IntFilter<"UnlinkedReportDetail"> | number
    data?: JsonFilter<"UnlinkedReportDetail">
    unlinkedReport?: XOR<UnlinkedReportScalarRelationFilter, UnlinkedReportWhereInput>
  }, "id">

  export type UnlinkedReportDetailOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unlinkedReportId?: SortOrder
    data?: SortOrder
    _count?: UnlinkedReportDetailCountOrderByAggregateInput
    _avg?: UnlinkedReportDetailAvgOrderByAggregateInput
    _max?: UnlinkedReportDetailMaxOrderByAggregateInput
    _min?: UnlinkedReportDetailMinOrderByAggregateInput
    _sum?: UnlinkedReportDetailSumOrderByAggregateInput
  }

  export type UnlinkedReportDetailScalarWhereWithAggregatesInput = {
    AND?: UnlinkedReportDetailScalarWhereWithAggregatesInput | UnlinkedReportDetailScalarWhereWithAggregatesInput[]
    OR?: UnlinkedReportDetailScalarWhereWithAggregatesInput[]
    NOT?: UnlinkedReportDetailScalarWhereWithAggregatesInput | UnlinkedReportDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UnlinkedReportDetail"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UnlinkedReportDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnlinkedReportDetail"> | Date | string
    unlinkedReportId?: IntWithAggregatesFilter<"UnlinkedReportDetail"> | number
    data?: JsonWithAggregatesFilter<"UnlinkedReportDetail">
  }

  export type FailedReportDetailWhereInput = {
    AND?: FailedReportDetailWhereInput | FailedReportDetailWhereInput[]
    OR?: FailedReportDetailWhereInput[]
    NOT?: FailedReportDetailWhereInput | FailedReportDetailWhereInput[]
    id?: IntFilter<"FailedReportDetail"> | number
    createdAt?: DateTimeFilter<"FailedReportDetail"> | Date | string
    updatedAt?: DateTimeFilter<"FailedReportDetail"> | Date | string
    distributor?: EnumDistributorFilter<"FailedReportDetail"> | $Enums.Distributor
    reportingMonth?: StringFilter<"FailedReportDetail"> | string
    failedReason?: StringFilter<"FailedReportDetail"> | string
    data?: JsonFilter<"FailedReportDetail">
  }

  export type FailedReportDetailOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    failedReason?: SortOrder
    data?: SortOrder
  }

  export type FailedReportDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FailedReportDetailWhereInput | FailedReportDetailWhereInput[]
    OR?: FailedReportDetailWhereInput[]
    NOT?: FailedReportDetailWhereInput | FailedReportDetailWhereInput[]
    createdAt?: DateTimeFilter<"FailedReportDetail"> | Date | string
    updatedAt?: DateTimeFilter<"FailedReportDetail"> | Date | string
    distributor?: EnumDistributorFilter<"FailedReportDetail"> | $Enums.Distributor
    reportingMonth?: StringFilter<"FailedReportDetail"> | string
    failedReason?: StringFilter<"FailedReportDetail"> | string
    data?: JsonFilter<"FailedReportDetail">
  }, "id">

  export type FailedReportDetailOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    failedReason?: SortOrder
    data?: SortOrder
    _count?: FailedReportDetailCountOrderByAggregateInput
    _avg?: FailedReportDetailAvgOrderByAggregateInput
    _max?: FailedReportDetailMaxOrderByAggregateInput
    _min?: FailedReportDetailMinOrderByAggregateInput
    _sum?: FailedReportDetailSumOrderByAggregateInput
  }

  export type FailedReportDetailScalarWhereWithAggregatesInput = {
    AND?: FailedReportDetailScalarWhereWithAggregatesInput | FailedReportDetailScalarWhereWithAggregatesInput[]
    OR?: FailedReportDetailScalarWhereWithAggregatesInput[]
    NOT?: FailedReportDetailScalarWhereWithAggregatesInput | FailedReportDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FailedReportDetail"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FailedReportDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FailedReportDetail"> | Date | string
    distributor?: EnumDistributorWithAggregatesFilter<"FailedReportDetail"> | $Enums.Distributor
    reportingMonth?: StringWithAggregatesFilter<"FailedReportDetail"> | string
    failedReason?: StringWithAggregatesFilter<"FailedReportDetail"> | string
    data?: JsonWithAggregatesFilter<"FailedReportDetail">
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: IntFilter<"RefreshToken"> | number
    token?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRevoked?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRevoked?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RefreshToken"> | number
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: IntWithAggregatesFilter<"RefreshToken"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
  }

  export type InitializationStatusCreateInput = {
    initialized?: boolean
    adminInit?: boolean
  }

  export type InitializationStatusUncheckedCreateInput = {
    id?: number
    initialized?: boolean
    adminInit?: boolean
  }

  export type InitializationStatusUpdateInput = {
    initialized?: BoolFieldUpdateOperationsInput | boolean
    adminInit?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InitializationStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    initialized?: BoolFieldUpdateOperationsInput | boolean
    adminInit?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InitializationStatusCreateManyInput = {
    id?: number
    initialized?: boolean
    adminInit?: boolean
  }

  export type InitializationStatusUpdateManyMutationInput = {
    initialized?: BoolFieldUpdateOperationsInput | boolean
    adminInit?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InitializationStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    initialized?: BoolFieldUpdateOperationsInput | boolean
    adminInit?: BoolFieldUpdateOperationsInput | boolean
  }

  export type S3FileCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    type: string
    folder?: string | null
    bucket: string
    key: string
    UserRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutS3FileInput
    BaseRoyaltyReport?: BaseRoyaltyReportCreateNestedManyWithoutS3FileInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportCreateNestedManyWithoutS3FileInput
  }

  export type S3FileUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    type: string
    folder?: string | null
    bucket: string
    key: string
    UserRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput
    BaseRoyaltyReport?: BaseRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput
  }

  export type S3FileUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    folder?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    UserRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutS3FileNestedInput
    BaseRoyaltyReport?: BaseRoyaltyReportUpdateManyWithoutS3FileNestedInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportUpdateManyWithoutS3FileNestedInput
  }

  export type S3FileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    folder?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    UserRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput
    BaseRoyaltyReport?: BaseRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput
  }

  export type S3FileCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    type: string
    folder?: string | null
    bucket: string
    key: string
  }

  export type S3FileUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    folder?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type S3FileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    folder?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type LogCreateInput = {
    createdAt?: Date | string
    object: string
    objectId?: number | null
    message: string
    script?: string | null
    ip?: string | null
    user: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    userId: number
    object: string
    objectId?: number | null
    message: string
    script?: string | null
    ip?: string | null
  }

  export type LogUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: StringFieldUpdateOperationsInput | string
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    object?: StringFieldUpdateOperationsInput | string
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogCreateManyInput = {
    id?: number
    createdAt?: Date | string
    userId: number
    object: string
    objectId?: number | null
    message: string
    script?: string | null
    ip?: string | null
  }

  export type LogUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: StringFieldUpdateOperationsInput | string
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    object?: StringFieldUpdateOperationsInput | string
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    preferences?: UserPreferencesCreateNestedManyWithoutUserInput
    comms?: UserCommsCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    clientId?: number | null
    preferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput
    comms?: UserCommsUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: UserPreferencesUpdateManyWithoutUserNestedInput
    comms?: UserCommsUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    preferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput
    comms?: UserCommsUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    clientId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PasswordResetTokenCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutResetTokenInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: number
    token: string
    expiresAt: Date | string
    userId: number
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResetTokenNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: number
    token: string
    expiresAt: Date | string
    userId: number
    createdAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    fontSize?: string | null
    mainMenuCollapsed?: boolean | null
    theme?: string | null
    language?: string | null
    user?: UserCreateNestedOneWithoutPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
    fontSize?: string | null
    mainMenuCollapsed?: boolean | null
    theme?: string | null
    language?: string | null
  }

  export type UserPreferencesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    mainMenuCollapsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    mainMenuCollapsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPreferencesCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
    fontSize?: string | null
    mainMenuCollapsed?: boolean | null
    theme?: string | null
    language?: string | null
  }

  export type UserPreferencesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    mainMenuCollapsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    mainMenuCollapsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommsCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.CommsChannels
    value: string
    user: UserCreateNestedOneWithoutCommsInput
  }

  export type UserCommsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    type: $Enums.CommsChannels
    value: string
  }

  export type UserCommsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCommsChannelsFieldUpdateOperationsInput | $Enums.CommsChannels
    value?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCommsNestedInput
  }

  export type UserCommsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumCommsChannelsFieldUpdateOperationsInput | $Enums.CommsChannels
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserCommsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    type: $Enums.CommsChannels
    value: string
  }

  export type UserCommsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCommsChannelsFieldUpdateOperationsInput | $Enums.CommsChannels
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserCommsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumCommsChannelsFieldUpdateOperationsInput | $Enums.CommsChannels
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ClientCreateInput = {
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address: AddressCreateNestedOneWithoutClientInput
    dmb?: ClientDMBCreateNestedOneWithoutClientInput
    balances?: BalanceCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationCreateNestedOneWithoutClientInput
    labels?: LabelCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    contract?: ContractCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    addressId: number
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    dmb?: ClientDMBUncheckedCreateNestedOneWithoutClientInput
    balances?: BalanceUncheckedCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationUncheckedCreateNestedOneWithoutClientInput
    labels?: LabelUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    contract?: ContractUncheckedCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneRequiredWithoutClientNestedInput
    dmb?: ClientDMBUpdateOneWithoutClientNestedInput
    balances?: BalanceUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUpdateOneWithoutClientNestedInput
    labels?: LabelUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    contract?: ContractUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    addressId?: IntFieldUpdateOperationsInput | number
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    dmb?: ClientDMBUncheckedUpdateOneWithoutClientNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUncheckedUpdateOneWithoutClientNestedInput
    labels?: LabelUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    contract?: ContractUncheckedUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    addressId: number
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
  }

  export type ClientUpdateManyMutationInput = {
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    addressId?: IntFieldUpdateOperationsInput | number
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClientDMBCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    accessType?: $Enums.AccessTypeDMB
    status?: $Enums.DMBStatus
    subclientName?: string | null
    username?: string | null
    client: ClientCreateNestedOneWithoutDmbInput
  }

  export type ClientDMBUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: number
    accessType?: $Enums.AccessTypeDMB
    status?: $Enums.DMBStatus
    subclientName?: string | null
    username?: string | null
  }

  export type ClientDMBUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessType?: EnumAccessTypeDMBFieldUpdateOperationsInput | $Enums.AccessTypeDMB
    status?: EnumDMBStatusFieldUpdateOperationsInput | $Enums.DMBStatus
    subclientName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutDmbNestedInput
  }

  export type ClientDMBUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    accessType?: EnumAccessTypeDMBFieldUpdateOperationsInput | $Enums.AccessTypeDMB
    status?: EnumDMBStatusFieldUpdateOperationsInput | $Enums.DMBStatus
    subclientName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientDMBCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: number
    accessType?: $Enums.AccessTypeDMB
    status?: $Enums.DMBStatus
    subclientName?: string | null
    username?: string | null
  }

  export type ClientDMBUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessType?: EnumAccessTypeDMBFieldUpdateOperationsInput | $Enums.AccessTypeDMB
    status?: EnumDMBStatusFieldUpdateOperationsInput | $Enums.DMBStatus
    subclientName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientDMBUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    accessType?: EnumAccessTypeDMBFieldUpdateOperationsInput | $Enums.AccessTypeDMB
    status?: EnumDMBStatusFieldUpdateOperationsInput | $Enums.DMBStatus
    subclientName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientPaymentInformationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
    client: ClientCreateNestedOneWithoutPaymentDataInput
  }

  export type ClientPaymentInformationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: number
    paymentMethod?: $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientPaymentInformationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
    client?: ClientUpdateOneRequiredWithoutPaymentDataNestedInput
  }

  export type ClientPaymentInformationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientPaymentInformationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: number
    paymentMethod?: $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientPaymentInformationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientPaymentInformationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ContractCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    uuid?: string
    type?: $Enums.ContractType
    ppd?: number | null
    status?: $Enums.ContractStatus
    docUrl?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    signed?: boolean
    signedAt?: Date | string | null
    signedBy?: string | null
    client?: ClientCreateNestedOneWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: number | null
    uuid?: string
    type?: $Enums.ContractType
    ppd?: number | null
    status?: $Enums.ContractStatus
    docUrl?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    signed?: boolean
    signedAt?: Date | string | null
    signedBy?: string | null
  }

  export type ContractUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    ppd?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    ppd?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: number | null
    uuid?: string
    type?: $Enums.ContractType
    ppd?: number | null
    status?: $Enums.ContractStatus
    docUrl?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    signed?: boolean
    signedAt?: Date | string | null
    signedBy?: string | null
  }

  export type ContractUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    ppd?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    ppd?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BalanceCreateInput = {
    currency?: $Enums.Currency
    amount?: Decimal | DecimalJsLike | number | string
    amountRetain?: Decimal | DecimalJsLike | number | string
    amountTerminated?: Decimal | DecimalJsLike | number | string
    client: ClientCreateNestedOneWithoutBalancesInput
    transactions?: TransactionCreateNestedManyWithoutBalanceInput
  }

  export type BalanceUncheckedCreateInput = {
    id?: number
    clientId: number
    currency?: $Enums.Currency
    amount?: Decimal | DecimalJsLike | number | string
    amountRetain?: Decimal | DecimalJsLike | number | string
    amountTerminated?: Decimal | DecimalJsLike | number | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutBalanceInput
  }

  export type BalanceUpdateInput = {
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client?: ClientUpdateOneRequiredWithoutBalancesNestedInput
    transactions?: TransactionUpdateManyWithoutBalanceNestedInput
  }

  export type BalanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactions?: TransactionUncheckedUpdateManyWithoutBalanceNestedInput
  }

  export type BalanceCreateManyInput = {
    id?: number
    clientId: number
    currency?: $Enums.Currency
    amount?: Decimal | DecimalJsLike | number | string
    amountRetain?: Decimal | DecimalJsLike | number | string
    amountTerminated?: Decimal | DecimalJsLike | number | string
  }

  export type BalanceUpdateManyMutationInput = {
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BalanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TransactionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    balance: BalanceCreateNestedOneWithoutTransactionsInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutTransactionInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    balanceId: number
    baseReportId?: number | null
    userReportId?: number | null
  }

  export type TransactionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    balance?: BalanceUpdateOneRequiredWithoutTransactionsNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutTransactionNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    balanceId?: IntFieldUpdateOperationsInput | number
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    balanceId: number
    baseReportId?: number | null
    userReportId?: number | null
  }

  export type TransactionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    balanceId?: IntFieldUpdateOperationsInput | number
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AddressCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    street: string
    street2?: string | null
    city: string
    state: string
    zip: string
    country: CountryCreateNestedOneWithoutAddressInput
    client?: ClientCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    street: string
    street2?: string | null
    city: string
    state: string
    countryId: number
    zip: string
    client?: ClientUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    street?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutAddressNestedInput
    client?: ClientUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    street?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
    client?: ClientUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    street: string
    street2?: string | null
    city: string
    state: string
    countryId: number
    zip: string
  }

  export type AddressUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    street?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    street?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
  }

  export type CountryCreateInput = {
    name: string
    shortCode: string
    code: string
    address?: AddressCreateNestedManyWithoutCountryInput
    label?: LabelCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    name: string
    shortCode: string
    code: string
    address?: AddressUncheckedCreateNestedManyWithoutCountryInput
    label?: LabelUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutCountryNestedInput
    label?: LabelUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutCountryNestedInput
    label?: LabelUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: number
    name: string
    shortCode: string
    code: string
  }

  export type CountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type LabelCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
    client: ClientCreateNestedOneWithoutLabelsInput
    country?: CountryCreateNestedOneWithoutLabelInput
    KontorRoyaltyReport?: KontorRoyaltyReportCreateNestedManyWithoutLabelInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: number
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    countryId?: number | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutLabelInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneWithoutLabelNestedInput
    KontorRoyaltyReport?: KontorRoyaltyReportUpdateManyWithoutLabelNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedUpdateManyWithoutLabelNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type LabelCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: number
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    countryId?: number | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
  }

  export type LabelUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportedRoyaltyReportCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
    s3File?: S3FileCreateNestedOneWithoutImportedRoyaltyReportInput
    KontorRoyaltyReport?: KontorRoyaltyReportCreateNestedManyWithoutImportedReportInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportCreateNestedManyWithoutImportedReportInput
  }

  export type ImportedRoyaltyReportUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
    s3FileId?: number | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutImportedReportInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutImportedReportInput
  }

  export type ImportedRoyaltyReportUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
    s3File?: S3FileUpdateOneWithoutImportedRoyaltyReportNestedInput
    KontorRoyaltyReport?: KontorRoyaltyReportUpdateManyWithoutImportedReportNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUpdateManyWithoutImportedReportNestedInput
  }

  export type ImportedRoyaltyReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedUpdateManyWithoutImportedReportNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedUpdateManyWithoutImportedReportNestedInput
  }

  export type ImportedRoyaltyReportCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
    s3FileId?: number | null
  }

  export type ImportedRoyaltyReportUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
  }

  export type ImportedRoyaltyReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BaseRoyaltyReportCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutBaseRoyaltyReportInput
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutBaseReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutBaseReportInput
    userReports?: UserRoyaltyReportCreateNestedManyWithoutBaseReportInput
    Transaction?: TransactionCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    userReports?: UserRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutBaseRoyaltyReportNestedInput
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    userReports?: UserRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    Transaction?: TransactionUpdateManyWithoutBaseReportNestedInput
  }

  export type BaseRoyaltyReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    userReports?: UserRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBaseReportNestedInput
  }

  export type BaseRoyaltyReportCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
  }

  export type BaseRoyaltyReportUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BaseRoyaltyReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoyaltyReportCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutUserRoyaltyReportInput
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutUserReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutUserReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutUserReportsInput
    client?: ClientCreateNestedOneWithoutUserRoyaltyReportInput
    transactions?: TransactionCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    baseReportId?: number | null
    clientId?: number | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutUserRoyaltyReportNestedInput
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutUserReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutUserReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutUserReportsNestedInput
    client?: ClientUpdateOneWithoutUserRoyaltyReportNestedInput
    transactions?: TransactionUpdateManyWithoutUserReportNestedInput
  }

  export type UserRoyaltyReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserReportNestedInput
  }

  export type UserRoyaltyReportCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    baseReportId?: number | null
    clientId?: number | null
  }

  export type UserRoyaltyReportUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRoyaltyReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KontorRoyaltyReportCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    label?: LabelCreateNestedOneWithoutKontorRoyaltyReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutKontorReportsInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutKontorReportsInput
    importedReport?: ImportedRoyaltyReportCreateNestedOneWithoutKontorRoyaltyReportInput
  }

  export type KontorRoyaltyReportUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type KontorRoyaltyReportUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    label?: LabelUpdateOneWithoutKontorRoyaltyReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutKontorReportsNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutKontorReportsNestedInput
    importedReport?: ImportedRoyaltyReportUpdateOneWithoutKontorRoyaltyReportNestedInput
  }

  export type KontorRoyaltyReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KontorRoyaltyReportCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type KontorRoyaltyReportUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type KontorRoyaltyReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BelieveRoyaltyReportCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    label?: LabelCreateNestedOneWithoutBelieveRoyaltyReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutBelieveReportsInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutBelieveReportsInput
    importedReport?: ImportedRoyaltyReportCreateNestedOneWithoutBelieveRoyaltyReportInput
  }

  export type BelieveRoyaltyReportUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type BelieveRoyaltyReportUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    label?: LabelUpdateOneWithoutBelieveRoyaltyReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutBelieveReportsNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutBelieveReportsNestedInput
    importedReport?: ImportedRoyaltyReportUpdateOneWithoutBelieveRoyaltyReportNestedInput
  }

  export type BelieveRoyaltyReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BelieveRoyaltyReportCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type BelieveRoyaltyReportUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BelieveRoyaltyReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnlinkedReportCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    labelName: string
    count: number
    UnlinkedReportDetail?: UnlinkedReportDetailCreateNestedManyWithoutUnlinkedReportInput
  }

  export type UnlinkedReportUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    labelName: string
    count: number
    UnlinkedReportDetail?: UnlinkedReportDetailUncheckedCreateNestedManyWithoutUnlinkedReportInput
  }

  export type UnlinkedReportUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    UnlinkedReportDetail?: UnlinkedReportDetailUpdateManyWithoutUnlinkedReportNestedInput
  }

  export type UnlinkedReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    UnlinkedReportDetail?: UnlinkedReportDetailUncheckedUpdateManyWithoutUnlinkedReportNestedInput
  }

  export type UnlinkedReportCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    labelName: string
    count: number
  }

  export type UnlinkedReportUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type UnlinkedReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type UnlinkedReportDetailCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
    unlinkedReport: UnlinkedReportCreateNestedOneWithoutUnlinkedReportDetailInput
  }

  export type UnlinkedReportDetailUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    unlinkedReportId: number
    data: JsonNullValueInput | InputJsonValue
  }

  export type UnlinkedReportDetailUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
    unlinkedReport?: UnlinkedReportUpdateOneRequiredWithoutUnlinkedReportDetailNestedInput
  }

  export type UnlinkedReportDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedReportId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UnlinkedReportDetailCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    unlinkedReportId: number
    data: JsonNullValueInput | InputJsonValue
  }

  export type UnlinkedReportDetailUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UnlinkedReportDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedReportId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
  }

  export type FailedReportDetailCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    failedReason: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type FailedReportDetailUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    failedReason: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type FailedReportDetailUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    failedReason?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type FailedReportDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    failedReason?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type FailedReportDetailCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    failedReason: string
    data: JsonNullValueInput | InputJsonValue
  }

  export type FailedReportDetailUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    failedReason?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type FailedReportDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    failedReason?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type RefreshTokenCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRevoked?: boolean
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: number
    token: string
    userId: number
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRevoked?: boolean
  }

  export type RefreshTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenCreateManyInput = {
    id?: number
    token: string
    userId: number
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRevoked?: boolean
  }

  export type RefreshTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type InitializationStatusCountOrderByAggregateInput = {
    id?: SortOrder
    initialized?: SortOrder
    adminInit?: SortOrder
  }

  export type InitializationStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InitializationStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    initialized?: SortOrder
    adminInit?: SortOrder
  }

  export type InitializationStatusMinOrderByAggregateInput = {
    id?: SortOrder
    initialized?: SortOrder
    adminInit?: SortOrder
  }

  export type InitializationStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserRoyaltyReportListRelationFilter = {
    every?: UserRoyaltyReportWhereInput
    some?: UserRoyaltyReportWhereInput
    none?: UserRoyaltyReportWhereInput
  }

  export type BaseRoyaltyReportListRelationFilter = {
    every?: BaseRoyaltyReportWhereInput
    some?: BaseRoyaltyReportWhereInput
    none?: BaseRoyaltyReportWhereInput
  }

  export type ImportedRoyaltyReportListRelationFilter = {
    every?: ImportedRoyaltyReportWhereInput
    some?: ImportedRoyaltyReportWhereInput
    none?: ImportedRoyaltyReportWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoyaltyReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BaseRoyaltyReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportedRoyaltyReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type S3FileCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
    type?: SortOrder
    folder?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
  }

  export type S3FileAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type S3FileMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
    type?: SortOrder
    folder?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
  }

  export type S3FileMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
    type?: SortOrder
    folder?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
  }

  export type S3FileSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    object?: SortOrder
    objectId?: SortOrder
    message?: SortOrder
    script?: SortOrder
    ip?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    objectId?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    object?: SortOrder
    objectId?: SortOrder
    message?: SortOrder
    script?: SortOrder
    ip?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    object?: SortOrder
    objectId?: SortOrder
    message?: SortOrder
    script?: SortOrder
    ip?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    objectId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type UserPreferencesListRelationFilter = {
    every?: UserPreferencesWhereInput
    some?: UserPreferencesWhereInput
    none?: UserPreferencesWhereInput
  }

  export type UserCommsListRelationFilter = {
    every?: UserCommsWhereInput
    some?: UserCommsWhereInput
    none?: UserCommsWhereInput
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type PasswordResetTokenNullableScalarRelationFilter = {
    is?: PasswordResetTokenWhereInput | null
    isNot?: PasswordResetTokenWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type UserPreferencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCommsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    usernameDMB?: SortOrder
    role?: SortOrder
    clientId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    usernameDMB?: SortOrder
    role?: SortOrder
    clientId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    usernameDMB?: SortOrder
    role?: SortOrder
    clientId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    fontSize?: SortOrder
    mainMenuCollapsed?: SortOrder
    theme?: SortOrder
    language?: SortOrder
  }

  export type UserPreferencesAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    fontSize?: SortOrder
    mainMenuCollapsed?: SortOrder
    theme?: SortOrder
    language?: SortOrder
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    fontSize?: SortOrder
    mainMenuCollapsed?: SortOrder
    theme?: SortOrder
    language?: SortOrder
  }

  export type UserPreferencesSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumCommsChannelsFilter<$PrismaModel = never> = {
    equals?: $Enums.CommsChannels | EnumCommsChannelsFieldRefInput<$PrismaModel>
    in?: $Enums.CommsChannels[] | ListEnumCommsChannelsFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommsChannels[] | ListEnumCommsChannelsFieldRefInput<$PrismaModel>
    not?: NestedEnumCommsChannelsFilter<$PrismaModel> | $Enums.CommsChannels
  }

  export type UserCommsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type UserCommsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserCommsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type UserCommsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type UserCommsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumCommsChannelsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommsChannels | EnumCommsChannelsFieldRefInput<$PrismaModel>
    in?: $Enums.CommsChannels[] | ListEnumCommsChannelsFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommsChannels[] | ListEnumCommsChannelsFieldRefInput<$PrismaModel>
    not?: NestedEnumCommsChannelsWithAggregatesFilter<$PrismaModel> | $Enums.CommsChannels
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommsChannelsFilter<$PrismaModel>
    _max?: NestedEnumCommsChannelsFilter<$PrismaModel>
  }

  export type EnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type EnumTaxIdTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxIdTypeFilter<$PrismaModel> | $Enums.TaxIdType
  }

  export type EnumClientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusFilter<$PrismaModel> | $Enums.ClientStatus
  }

  export type AddressScalarRelationFilter = {
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type ClientDMBNullableScalarRelationFilter = {
    is?: ClientDMBWhereInput | null
    isNot?: ClientDMBWhereInput | null
  }

  export type BalanceListRelationFilter = {
    every?: BalanceWhereInput
    some?: BalanceWhereInput
    none?: BalanceWhereInput
  }

  export type ClientPaymentInformationNullableScalarRelationFilter = {
    is?: ClientPaymentInformationWhereInput | null
    isNot?: ClientPaymentInformationWhereInput | null
  }

  export type LabelListRelationFilter = {
    every?: LabelWhereInput
    some?: LabelWhereInput
    none?: LabelWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ContractNullableScalarRelationFilter = {
    is?: ContractWhereInput | null
    isNot?: ContractWhereInput | null
  }

  export type BalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    wp_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    type?: SortOrder
    addressId?: SortOrder
    taxIdType?: SortOrder
    taxId?: SortOrder
    vatRegistered?: SortOrder
    vatId?: SortOrder
    status?: SortOrder
    isBlocked?: SortOrder
    isPaymentsBlocked?: SortOrder
    isPaymentInProgress?: SortOrder
    isPaymentDataInValidation?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
    wp_id?: SortOrder
    addressId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    wp_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    type?: SortOrder
    addressId?: SortOrder
    taxIdType?: SortOrder
    taxId?: SortOrder
    vatRegistered?: SortOrder
    vatId?: SortOrder
    status?: SortOrder
    isBlocked?: SortOrder
    isPaymentsBlocked?: SortOrder
    isPaymentInProgress?: SortOrder
    isPaymentDataInValidation?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    wp_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    type?: SortOrder
    addressId?: SortOrder
    taxIdType?: SortOrder
    taxId?: SortOrder
    vatRegistered?: SortOrder
    vatId?: SortOrder
    status?: SortOrder
    isBlocked?: SortOrder
    isPaymentsBlocked?: SortOrder
    isPaymentInProgress?: SortOrder
    isPaymentDataInValidation?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
    wp_id?: SortOrder
    addressId?: SortOrder
  }

  export type EnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type EnumTaxIdTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxIdTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaxIdType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxIdTypeFilter<$PrismaModel>
    _max?: NestedEnumTaxIdTypeFilter<$PrismaModel>
  }

  export type EnumClientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientStatusFilter<$PrismaModel>
    _max?: NestedEnumClientStatusFilter<$PrismaModel>
  }

  export type EnumAccessTypeDMBFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessTypeDMB | EnumAccessTypeDMBFieldRefInput<$PrismaModel>
    in?: $Enums.AccessTypeDMB[] | ListEnumAccessTypeDMBFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessTypeDMB[] | ListEnumAccessTypeDMBFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeDMBFilter<$PrismaModel> | $Enums.AccessTypeDMB
  }

  export type EnumDMBStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DMBStatus | EnumDMBStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DMBStatus[] | ListEnumDMBStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DMBStatus[] | ListEnumDMBStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDMBStatusFilter<$PrismaModel> | $Enums.DMBStatus
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ClientDMBCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    accessType?: SortOrder
    status?: SortOrder
    subclientName?: SortOrder
    username?: SortOrder
  }

  export type ClientDMBAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type ClientDMBMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    accessType?: SortOrder
    status?: SortOrder
    subclientName?: SortOrder
    username?: SortOrder
  }

  export type ClientDMBMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    accessType?: SortOrder
    status?: SortOrder
    subclientName?: SortOrder
    username?: SortOrder
  }

  export type ClientDMBSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type EnumAccessTypeDMBWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessTypeDMB | EnumAccessTypeDMBFieldRefInput<$PrismaModel>
    in?: $Enums.AccessTypeDMB[] | ListEnumAccessTypeDMBFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessTypeDMB[] | ListEnumAccessTypeDMBFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeDMBWithAggregatesFilter<$PrismaModel> | $Enums.AccessTypeDMB
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessTypeDMBFilter<$PrismaModel>
    _max?: NestedEnumAccessTypeDMBFilter<$PrismaModel>
  }

  export type EnumDMBStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DMBStatus | EnumDMBStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DMBStatus[] | ListEnumDMBStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DMBStatus[] | ListEnumDMBStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDMBStatusWithAggregatesFilter<$PrismaModel> | $Enums.DMBStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDMBStatusFilter<$PrismaModel>
    _max?: NestedEnumDMBStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ClientPaymentInformationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    paymentMethod?: SortOrder
    data?: SortOrder
  }

  export type ClientPaymentInformationAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type ClientPaymentInformationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    paymentMethod?: SortOrder
  }

  export type ClientPaymentInformationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    paymentMethod?: SortOrder
  }

  export type ClientPaymentInformationSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type EnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumContractStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusFilter<$PrismaModel> | $Enums.ContractStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    uuid?: SortOrder
    type?: SortOrder
    ppd?: SortOrder
    status?: SortOrder
    docUrl?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    signed?: SortOrder
    signedAt?: SortOrder
    signedBy?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    ppd?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    uuid?: SortOrder
    type?: SortOrder
    ppd?: SortOrder
    status?: SortOrder
    docUrl?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    signed?: SortOrder
    signedAt?: SortOrder
    signedBy?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    uuid?: SortOrder
    type?: SortOrder
    ppd?: SortOrder
    status?: SortOrder
    docUrl?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    signed?: SortOrder
    signedAt?: SortOrder
    signedBy?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    ppd?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumContractStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractStatusFilter<$PrismaModel>
    _max?: NestedEnumContractStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumCurrencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyFilter<$PrismaModel> | $Enums.Currency
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BalanceCurrencyClientIdCompoundUniqueInput = {
    currency: $Enums.Currency
    clientId: number
  }

  export type BalanceCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    amountRetain?: SortOrder
    amountTerminated?: SortOrder
  }

  export type BalanceAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    amount?: SortOrder
    amountRetain?: SortOrder
    amountTerminated?: SortOrder
  }

  export type BalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    amountRetain?: SortOrder
    amountTerminated?: SortOrder
  }

  export type BalanceMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    amountRetain?: SortOrder
    amountTerminated?: SortOrder
  }

  export type BalanceSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    amount?: SortOrder
    amountRetain?: SortOrder
    amountTerminated?: SortOrder
  }

  export type EnumCurrencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyWithAggregatesFilter<$PrismaModel> | $Enums.Currency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyFilter<$PrismaModel>
    _max?: NestedEnumCurrencyFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumDistributorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Distributor | EnumDistributorFieldRefInput<$PrismaModel> | null
    in?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDistributorNullableFilter<$PrismaModel> | $Enums.Distributor | null
  }

  export type BalanceScalarRelationFilter = {
    is?: BalanceWhereInput
    isNot?: BalanceWhereInput
  }

  export type BaseRoyaltyReportNullableScalarRelationFilter = {
    is?: BaseRoyaltyReportWhereInput | null
    isNot?: BaseRoyaltyReportWhereInput | null
  }

  export type UserRoyaltyReportNullableScalarRelationFilter = {
    is?: UserRoyaltyReportWhereInput | null
    isNot?: UserRoyaltyReportWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    balanceAmount?: SortOrder
    reversed?: SortOrder
    distributor?: SortOrder
    balanceId?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    balanceAmount?: SortOrder
    balanceId?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    balanceAmount?: SortOrder
    reversed?: SortOrder
    distributor?: SortOrder
    balanceId?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    balanceAmount?: SortOrder
    reversed?: SortOrder
    distributor?: SortOrder
    balanceId?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    balanceAmount?: SortOrder
    balanceId?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumDistributorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Distributor | EnumDistributorFieldRefInput<$PrismaModel> | null
    in?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDistributorNullableWithAggregatesFilter<$PrismaModel> | $Enums.Distributor | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDistributorNullableFilter<$PrismaModel>
    _max?: NestedEnumDistributorNullableFilter<$PrismaModel>
  }

  export type CountryScalarRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    street?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    countryId?: SortOrder
    zip?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    street?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    countryId?: SortOrder
    zip?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    street?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    countryId?: SortOrder
    zip?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortCode?: SortOrder
    code?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortCode?: SortOrder
    code?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortCode?: SortOrder
    code?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumLabelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabelStatus | EnumLabelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabelStatus[] | ListEnumLabelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabelStatus[] | ListEnumLabelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelStatusFilter<$PrismaModel> | $Enums.LabelStatus
  }

  export type EnumLabelRegistrationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabelRegistrationStatus | EnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabelRegistrationStatus[] | ListEnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabelRegistrationStatus[] | ListEnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelRegistrationStatusFilter<$PrismaModel> | $Enums.LabelRegistrationStatus
  }

  export type CountryNullableScalarRelationFilter = {
    is?: CountryWhereInput | null
    isNot?: CountryWhereInput | null
  }

  export type KontorRoyaltyReportListRelationFilter = {
    every?: KontorRoyaltyReportWhereInput
    some?: KontorRoyaltyReportWhereInput
    none?: KontorRoyaltyReportWhereInput
  }

  export type BelieveRoyaltyReportListRelationFilter = {
    every?: BelieveRoyaltyReportWhereInput
    some?: BelieveRoyaltyReportWhereInput
    none?: BelieveRoyaltyReportWhereInput
  }

  export type KontorRoyaltyReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BelieveRoyaltyReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabelCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    website?: SortOrder
    countryId?: SortOrder
    beatportStatus?: SortOrder
    traxsourceStatus?: SortOrder
    beatportUrl?: SortOrder
    traxsourceUrl?: SortOrder
  }

  export type LabelAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    countryId?: SortOrder
  }

  export type LabelMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    website?: SortOrder
    countryId?: SortOrder
    beatportStatus?: SortOrder
    traxsourceStatus?: SortOrder
    beatportUrl?: SortOrder
    traxsourceUrl?: SortOrder
  }

  export type LabelMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    website?: SortOrder
    countryId?: SortOrder
    beatportStatus?: SortOrder
    traxsourceStatus?: SortOrder
    beatportUrl?: SortOrder
    traxsourceUrl?: SortOrder
  }

  export type LabelSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    countryId?: SortOrder
  }

  export type EnumLabelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabelStatus | EnumLabelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabelStatus[] | ListEnumLabelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabelStatus[] | ListEnumLabelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabelStatusFilter<$PrismaModel>
    _max?: NestedEnumLabelStatusFilter<$PrismaModel>
  }

  export type EnumLabelRegistrationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabelRegistrationStatus | EnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabelRegistrationStatus[] | ListEnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabelRegistrationStatus[] | ListEnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelRegistrationStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabelRegistrationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabelRegistrationStatusFilter<$PrismaModel>
    _max?: NestedEnumLabelRegistrationStatusFilter<$PrismaModel>
  }

  export type EnumDistributorFilter<$PrismaModel = never> = {
    equals?: $Enums.Distributor | EnumDistributorFieldRefInput<$PrismaModel>
    in?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel>
    not?: NestedEnumDistributorFilter<$PrismaModel> | $Enums.Distributor
  }

  export type S3FileNullableScalarRelationFilter = {
    is?: S3FileWhereInput | null
    isNot?: S3FileWhereInput | null
  }

  export type ImportedRoyaltyReportCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    importStatus?: SortOrder
    s3FileId?: SortOrder
  }

  export type ImportedRoyaltyReportAvgOrderByAggregateInput = {
    id?: SortOrder
    s3FileId?: SortOrder
  }

  export type ImportedRoyaltyReportMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    importStatus?: SortOrder
    s3FileId?: SortOrder
  }

  export type ImportedRoyaltyReportMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    importStatus?: SortOrder
    s3FileId?: SortOrder
  }

  export type ImportedRoyaltyReportSumOrderByAggregateInput = {
    id?: SortOrder
    s3FileId?: SortOrder
  }

  export type EnumDistributorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Distributor | EnumDistributorFieldRefInput<$PrismaModel>
    in?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel>
    not?: NestedEnumDistributorWithAggregatesFilter<$PrismaModel> | $Enums.Distributor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDistributorFilter<$PrismaModel>
    _max?: NestedEnumDistributorFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumDebitStateFilter<$PrismaModel = never> = {
    equals?: $Enums.DebitState | EnumDebitStateFieldRefInput<$PrismaModel>
    in?: $Enums.DebitState[] | ListEnumDebitStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebitState[] | ListEnumDebitStateFieldRefInput<$PrismaModel>
    not?: NestedEnumDebitStateFilter<$PrismaModel> | $Enums.DebitState
  }

  export type BaseRoyaltyReportDistributorReportingMonthCompoundUniqueInput = {
    distributor: $Enums.Distributor
    reportingMonth: string
  }

  export type BaseRoyaltyReportCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    totalRoyalties?: SortOrder
    totalEarnings?: SortOrder
    debitState?: SortOrder
    paidOn?: SortOrder
    s3FileId?: SortOrder
  }

  export type BaseRoyaltyReportAvgOrderByAggregateInput = {
    id?: SortOrder
    totalRoyalties?: SortOrder
    totalEarnings?: SortOrder
    s3FileId?: SortOrder
  }

  export type BaseRoyaltyReportMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    totalRoyalties?: SortOrder
    totalEarnings?: SortOrder
    debitState?: SortOrder
    paidOn?: SortOrder
    s3FileId?: SortOrder
  }

  export type BaseRoyaltyReportMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    totalRoyalties?: SortOrder
    totalEarnings?: SortOrder
    debitState?: SortOrder
    paidOn?: SortOrder
    s3FileId?: SortOrder
  }

  export type BaseRoyaltyReportSumOrderByAggregateInput = {
    id?: SortOrder
    totalRoyalties?: SortOrder
    totalEarnings?: SortOrder
    s3FileId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumDebitStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DebitState | EnumDebitStateFieldRefInput<$PrismaModel>
    in?: $Enums.DebitState[] | ListEnumDebitStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebitState[] | ListEnumDebitStateFieldRefInput<$PrismaModel>
    not?: NestedEnumDebitStateWithAggregatesFilter<$PrismaModel> | $Enums.DebitState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDebitStateFilter<$PrismaModel>
    _max?: NestedEnumDebitStateFilter<$PrismaModel>
  }

  export type UserRoyaltyReportCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    totalRoyalties?: SortOrder
    debitState?: SortOrder
    paidOn?: SortOrder
    s3FileId?: SortOrder
    baseReportId?: SortOrder
    clientId?: SortOrder
  }

  export type UserRoyaltyReportAvgOrderByAggregateInput = {
    id?: SortOrder
    totalRoyalties?: SortOrder
    s3FileId?: SortOrder
    baseReportId?: SortOrder
    clientId?: SortOrder
  }

  export type UserRoyaltyReportMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    totalRoyalties?: SortOrder
    debitState?: SortOrder
    paidOn?: SortOrder
    s3FileId?: SortOrder
    baseReportId?: SortOrder
    clientId?: SortOrder
  }

  export type UserRoyaltyReportMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    totalRoyalties?: SortOrder
    debitState?: SortOrder
    paidOn?: SortOrder
    s3FileId?: SortOrder
    baseReportId?: SortOrder
    clientId?: SortOrder
  }

  export type UserRoyaltyReportSumOrderByAggregateInput = {
    id?: SortOrder
    totalRoyalties?: SortOrder
    s3FileId?: SortOrder
    baseReportId?: SortOrder
    clientId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type LabelNullableScalarRelationFilter = {
    is?: LabelWhereInput | null
    isNot?: LabelWhereInput | null
  }

  export type ImportedRoyaltyReportNullableScalarRelationFilter = {
    is?: ImportedRoyaltyReportWhereInput | null
    isNot?: ImportedRoyaltyReportWhereInput | null
  }

  export type KontorRoyaltyReportCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    labelId?: SortOrder
    reportingMonth?: SortOrder
    salesMonth?: SortOrder
    store?: SortOrder
    chType?: SortOrder
    channelId?: SortOrder
    country?: SortOrder
    labelName?: SortOrder
    productType?: SortOrder
    productTitle?: SortOrder
    productArtist?: SortOrder
    ean?: SortOrder
    isrc?: SortOrder
    grid?: SortOrder
    articleNo?: SortOrder
    royalties?: SortOrder
    units?: SortOrder
    cmg_clientRate?: SortOrder
    cmg_netRevenue?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
    importedReportId?: SortOrder
  }

  export type KontorRoyaltyReportAvgOrderByAggregateInput = {
    id?: SortOrder
    labelId?: SortOrder
    royalties?: SortOrder
    units?: SortOrder
    cmg_clientRate?: SortOrder
    cmg_netRevenue?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
    importedReportId?: SortOrder
  }

  export type KontorRoyaltyReportMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    labelId?: SortOrder
    reportingMonth?: SortOrder
    salesMonth?: SortOrder
    store?: SortOrder
    chType?: SortOrder
    channelId?: SortOrder
    country?: SortOrder
    labelName?: SortOrder
    productType?: SortOrder
    productTitle?: SortOrder
    productArtist?: SortOrder
    ean?: SortOrder
    isrc?: SortOrder
    grid?: SortOrder
    articleNo?: SortOrder
    royalties?: SortOrder
    units?: SortOrder
    cmg_clientRate?: SortOrder
    cmg_netRevenue?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
    importedReportId?: SortOrder
  }

  export type KontorRoyaltyReportMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    labelId?: SortOrder
    reportingMonth?: SortOrder
    salesMonth?: SortOrder
    store?: SortOrder
    chType?: SortOrder
    channelId?: SortOrder
    country?: SortOrder
    labelName?: SortOrder
    productType?: SortOrder
    productTitle?: SortOrder
    productArtist?: SortOrder
    ean?: SortOrder
    isrc?: SortOrder
    grid?: SortOrder
    articleNo?: SortOrder
    royalties?: SortOrder
    units?: SortOrder
    cmg_clientRate?: SortOrder
    cmg_netRevenue?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
    importedReportId?: SortOrder
  }

  export type KontorRoyaltyReportSumOrderByAggregateInput = {
    id?: SortOrder
    labelId?: SortOrder
    royalties?: SortOrder
    units?: SortOrder
    cmg_clientRate?: SortOrder
    cmg_netRevenue?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
    importedReportId?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BelieveRoyaltyReportCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    labelId?: SortOrder
    reportingMonth?: SortOrder
    salesMonth?: SortOrder
    platform?: SortOrder
    countryRegion?: SortOrder
    labelName?: SortOrder
    artistName?: SortOrder
    releaseTitle?: SortOrder
    trackTitle?: SortOrder
    upc?: SortOrder
    isrc?: SortOrder
    catalogNb?: SortOrder
    streamingSubscriptionType?: SortOrder
    releaseType?: SortOrder
    salesType?: SortOrder
    quantity?: SortOrder
    clientPaymentCurrency?: SortOrder
    unitPrice?: SortOrder
    mechanicalFee?: SortOrder
    grossRevenue?: SortOrder
    clientShareRate?: SortOrder
    netRevenue?: SortOrder
    cmg_clientRate?: SortOrder
    cmg_netRevenue?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
    importedReportId?: SortOrder
  }

  export type BelieveRoyaltyReportAvgOrderByAggregateInput = {
    id?: SortOrder
    labelId?: SortOrder
    unitPrice?: SortOrder
    mechanicalFee?: SortOrder
    grossRevenue?: SortOrder
    clientShareRate?: SortOrder
    netRevenue?: SortOrder
    cmg_clientRate?: SortOrder
    cmg_netRevenue?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
    importedReportId?: SortOrder
  }

  export type BelieveRoyaltyReportMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    labelId?: SortOrder
    reportingMonth?: SortOrder
    salesMonth?: SortOrder
    platform?: SortOrder
    countryRegion?: SortOrder
    labelName?: SortOrder
    artistName?: SortOrder
    releaseTitle?: SortOrder
    trackTitle?: SortOrder
    upc?: SortOrder
    isrc?: SortOrder
    catalogNb?: SortOrder
    streamingSubscriptionType?: SortOrder
    releaseType?: SortOrder
    salesType?: SortOrder
    quantity?: SortOrder
    clientPaymentCurrency?: SortOrder
    unitPrice?: SortOrder
    mechanicalFee?: SortOrder
    grossRevenue?: SortOrder
    clientShareRate?: SortOrder
    netRevenue?: SortOrder
    cmg_clientRate?: SortOrder
    cmg_netRevenue?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
    importedReportId?: SortOrder
  }

  export type BelieveRoyaltyReportMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    labelId?: SortOrder
    reportingMonth?: SortOrder
    salesMonth?: SortOrder
    platform?: SortOrder
    countryRegion?: SortOrder
    labelName?: SortOrder
    artistName?: SortOrder
    releaseTitle?: SortOrder
    trackTitle?: SortOrder
    upc?: SortOrder
    isrc?: SortOrder
    catalogNb?: SortOrder
    streamingSubscriptionType?: SortOrder
    releaseType?: SortOrder
    salesType?: SortOrder
    quantity?: SortOrder
    clientPaymentCurrency?: SortOrder
    unitPrice?: SortOrder
    mechanicalFee?: SortOrder
    grossRevenue?: SortOrder
    clientShareRate?: SortOrder
    netRevenue?: SortOrder
    cmg_clientRate?: SortOrder
    cmg_netRevenue?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
    importedReportId?: SortOrder
  }

  export type BelieveRoyaltyReportSumOrderByAggregateInput = {
    id?: SortOrder
    labelId?: SortOrder
    unitPrice?: SortOrder
    mechanicalFee?: SortOrder
    grossRevenue?: SortOrder
    clientShareRate?: SortOrder
    netRevenue?: SortOrder
    cmg_clientRate?: SortOrder
    cmg_netRevenue?: SortOrder
    baseReportId?: SortOrder
    userReportId?: SortOrder
    importedReportId?: SortOrder
  }

  export type UnlinkedReportDetailListRelationFilter = {
    every?: UnlinkedReportDetailWhereInput
    some?: UnlinkedReportDetailWhereInput
    none?: UnlinkedReportDetailWhereInput
  }

  export type UnlinkedReportDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnlinkedReportCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    labelName?: SortOrder
    count?: SortOrder
  }

  export type UnlinkedReportAvgOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
  }

  export type UnlinkedReportMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    labelName?: SortOrder
    count?: SortOrder
  }

  export type UnlinkedReportMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    labelName?: SortOrder
    count?: SortOrder
  }

  export type UnlinkedReportSumOrderByAggregateInput = {
    id?: SortOrder
    count?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UnlinkedReportScalarRelationFilter = {
    is?: UnlinkedReportWhereInput
    isNot?: UnlinkedReportWhereInput
  }

  export type UnlinkedReportDetailCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unlinkedReportId?: SortOrder
    data?: SortOrder
  }

  export type UnlinkedReportDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    unlinkedReportId?: SortOrder
  }

  export type UnlinkedReportDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unlinkedReportId?: SortOrder
  }

  export type UnlinkedReportDetailMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unlinkedReportId?: SortOrder
  }

  export type UnlinkedReportDetailSumOrderByAggregateInput = {
    id?: SortOrder
    unlinkedReportId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FailedReportDetailCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    failedReason?: SortOrder
    data?: SortOrder
  }

  export type FailedReportDetailAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FailedReportDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    failedReason?: SortOrder
  }

  export type FailedReportDetailMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    distributor?: SortOrder
    reportingMonth?: SortOrder
    failedReason?: SortOrder
  }

  export type FailedReportDetailSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRevoked?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRevoked?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isRevoked?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserRoyaltyReportCreateNestedManyWithoutS3FileInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutS3FileInput, UserRoyaltyReportUncheckedCreateWithoutS3FileInput> | UserRoyaltyReportCreateWithoutS3FileInput[] | UserRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutS3FileInput | UserRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    createMany?: UserRoyaltyReportCreateManyS3FileInputEnvelope
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
  }

  export type BaseRoyaltyReportCreateNestedManyWithoutS3FileInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutS3FileInput, BaseRoyaltyReportUncheckedCreateWithoutS3FileInput> | BaseRoyaltyReportCreateWithoutS3FileInput[] | BaseRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutS3FileInput | BaseRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    createMany?: BaseRoyaltyReportCreateManyS3FileInputEnvelope
    connect?: BaseRoyaltyReportWhereUniqueInput | BaseRoyaltyReportWhereUniqueInput[]
  }

  export type ImportedRoyaltyReportCreateNestedManyWithoutS3FileInput = {
    create?: XOR<ImportedRoyaltyReportCreateWithoutS3FileInput, ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput> | ImportedRoyaltyReportCreateWithoutS3FileInput[] | ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: ImportedRoyaltyReportCreateOrConnectWithoutS3FileInput | ImportedRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    createMany?: ImportedRoyaltyReportCreateManyS3FileInputEnvelope
    connect?: ImportedRoyaltyReportWhereUniqueInput | ImportedRoyaltyReportWhereUniqueInput[]
  }

  export type UserRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutS3FileInput, UserRoyaltyReportUncheckedCreateWithoutS3FileInput> | UserRoyaltyReportCreateWithoutS3FileInput[] | UserRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutS3FileInput | UserRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    createMany?: UserRoyaltyReportCreateManyS3FileInputEnvelope
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
  }

  export type BaseRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutS3FileInput, BaseRoyaltyReportUncheckedCreateWithoutS3FileInput> | BaseRoyaltyReportCreateWithoutS3FileInput[] | BaseRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutS3FileInput | BaseRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    createMany?: BaseRoyaltyReportCreateManyS3FileInputEnvelope
    connect?: BaseRoyaltyReportWhereUniqueInput | BaseRoyaltyReportWhereUniqueInput[]
  }

  export type ImportedRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput = {
    create?: XOR<ImportedRoyaltyReportCreateWithoutS3FileInput, ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput> | ImportedRoyaltyReportCreateWithoutS3FileInput[] | ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: ImportedRoyaltyReportCreateOrConnectWithoutS3FileInput | ImportedRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    createMany?: ImportedRoyaltyReportCreateManyS3FileInputEnvelope
    connect?: ImportedRoyaltyReportWhereUniqueInput | ImportedRoyaltyReportWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserRoyaltyReportUpdateManyWithoutS3FileNestedInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutS3FileInput, UserRoyaltyReportUncheckedCreateWithoutS3FileInput> | UserRoyaltyReportCreateWithoutS3FileInput[] | UserRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutS3FileInput | UserRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    upsert?: UserRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput | UserRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput[]
    createMany?: UserRoyaltyReportCreateManyS3FileInputEnvelope
    set?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    disconnect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    delete?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    update?: UserRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput | UserRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput[]
    updateMany?: UserRoyaltyReportUpdateManyWithWhereWithoutS3FileInput | UserRoyaltyReportUpdateManyWithWhereWithoutS3FileInput[]
    deleteMany?: UserRoyaltyReportScalarWhereInput | UserRoyaltyReportScalarWhereInput[]
  }

  export type BaseRoyaltyReportUpdateManyWithoutS3FileNestedInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutS3FileInput, BaseRoyaltyReportUncheckedCreateWithoutS3FileInput> | BaseRoyaltyReportCreateWithoutS3FileInput[] | BaseRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutS3FileInput | BaseRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    upsert?: BaseRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput | BaseRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput[]
    createMany?: BaseRoyaltyReportCreateManyS3FileInputEnvelope
    set?: BaseRoyaltyReportWhereUniqueInput | BaseRoyaltyReportWhereUniqueInput[]
    disconnect?: BaseRoyaltyReportWhereUniqueInput | BaseRoyaltyReportWhereUniqueInput[]
    delete?: BaseRoyaltyReportWhereUniqueInput | BaseRoyaltyReportWhereUniqueInput[]
    connect?: BaseRoyaltyReportWhereUniqueInput | BaseRoyaltyReportWhereUniqueInput[]
    update?: BaseRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput | BaseRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput[]
    updateMany?: BaseRoyaltyReportUpdateManyWithWhereWithoutS3FileInput | BaseRoyaltyReportUpdateManyWithWhereWithoutS3FileInput[]
    deleteMany?: BaseRoyaltyReportScalarWhereInput | BaseRoyaltyReportScalarWhereInput[]
  }

  export type ImportedRoyaltyReportUpdateManyWithoutS3FileNestedInput = {
    create?: XOR<ImportedRoyaltyReportCreateWithoutS3FileInput, ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput> | ImportedRoyaltyReportCreateWithoutS3FileInput[] | ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: ImportedRoyaltyReportCreateOrConnectWithoutS3FileInput | ImportedRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    upsert?: ImportedRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput | ImportedRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput[]
    createMany?: ImportedRoyaltyReportCreateManyS3FileInputEnvelope
    set?: ImportedRoyaltyReportWhereUniqueInput | ImportedRoyaltyReportWhereUniqueInput[]
    disconnect?: ImportedRoyaltyReportWhereUniqueInput | ImportedRoyaltyReportWhereUniqueInput[]
    delete?: ImportedRoyaltyReportWhereUniqueInput | ImportedRoyaltyReportWhereUniqueInput[]
    connect?: ImportedRoyaltyReportWhereUniqueInput | ImportedRoyaltyReportWhereUniqueInput[]
    update?: ImportedRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput | ImportedRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput[]
    updateMany?: ImportedRoyaltyReportUpdateManyWithWhereWithoutS3FileInput | ImportedRoyaltyReportUpdateManyWithWhereWithoutS3FileInput[]
    deleteMany?: ImportedRoyaltyReportScalarWhereInput | ImportedRoyaltyReportScalarWhereInput[]
  }

  export type UserRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutS3FileInput, UserRoyaltyReportUncheckedCreateWithoutS3FileInput> | UserRoyaltyReportCreateWithoutS3FileInput[] | UserRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutS3FileInput | UserRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    upsert?: UserRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput | UserRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput[]
    createMany?: UserRoyaltyReportCreateManyS3FileInputEnvelope
    set?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    disconnect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    delete?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    update?: UserRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput | UserRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput[]
    updateMany?: UserRoyaltyReportUpdateManyWithWhereWithoutS3FileInput | UserRoyaltyReportUpdateManyWithWhereWithoutS3FileInput[]
    deleteMany?: UserRoyaltyReportScalarWhereInput | UserRoyaltyReportScalarWhereInput[]
  }

  export type BaseRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutS3FileInput, BaseRoyaltyReportUncheckedCreateWithoutS3FileInput> | BaseRoyaltyReportCreateWithoutS3FileInput[] | BaseRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutS3FileInput | BaseRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    upsert?: BaseRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput | BaseRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput[]
    createMany?: BaseRoyaltyReportCreateManyS3FileInputEnvelope
    set?: BaseRoyaltyReportWhereUniqueInput | BaseRoyaltyReportWhereUniqueInput[]
    disconnect?: BaseRoyaltyReportWhereUniqueInput | BaseRoyaltyReportWhereUniqueInput[]
    delete?: BaseRoyaltyReportWhereUniqueInput | BaseRoyaltyReportWhereUniqueInput[]
    connect?: BaseRoyaltyReportWhereUniqueInput | BaseRoyaltyReportWhereUniqueInput[]
    update?: BaseRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput | BaseRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput[]
    updateMany?: BaseRoyaltyReportUpdateManyWithWhereWithoutS3FileInput | BaseRoyaltyReportUpdateManyWithWhereWithoutS3FileInput[]
    deleteMany?: BaseRoyaltyReportScalarWhereInput | BaseRoyaltyReportScalarWhereInput[]
  }

  export type ImportedRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput = {
    create?: XOR<ImportedRoyaltyReportCreateWithoutS3FileInput, ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput> | ImportedRoyaltyReportCreateWithoutS3FileInput[] | ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput[]
    connectOrCreate?: ImportedRoyaltyReportCreateOrConnectWithoutS3FileInput | ImportedRoyaltyReportCreateOrConnectWithoutS3FileInput[]
    upsert?: ImportedRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput | ImportedRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput[]
    createMany?: ImportedRoyaltyReportCreateManyS3FileInputEnvelope
    set?: ImportedRoyaltyReportWhereUniqueInput | ImportedRoyaltyReportWhereUniqueInput[]
    disconnect?: ImportedRoyaltyReportWhereUniqueInput | ImportedRoyaltyReportWhereUniqueInput[]
    delete?: ImportedRoyaltyReportWhereUniqueInput | ImportedRoyaltyReportWhereUniqueInput[]
    connect?: ImportedRoyaltyReportWhereUniqueInput | ImportedRoyaltyReportWhereUniqueInput[]
    update?: ImportedRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput | ImportedRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput[]
    updateMany?: ImportedRoyaltyReportUpdateManyWithWhereWithoutS3FileInput | ImportedRoyaltyReportUpdateManyWithWhereWithoutS3FileInput[]
    deleteMany?: ImportedRoyaltyReportScalarWhereInput | ImportedRoyaltyReportScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserPreferencesCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput> | UserPreferencesCreateWithoutUserInput[] | UserPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput | UserPreferencesCreateOrConnectWithoutUserInput[]
    createMany?: UserPreferencesCreateManyUserInputEnvelope
    connect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[]
  }

  export type UserCommsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCommsCreateWithoutUserInput, UserCommsUncheckedCreateWithoutUserInput> | UserCommsCreateWithoutUserInput[] | UserCommsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCommsCreateOrConnectWithoutUserInput | UserCommsCreateOrConnectWithoutUserInput[]
    createMany?: UserCommsCreateManyUserInputEnvelope
    connect?: UserCommsWhereUniqueInput | UserCommsWhereUniqueInput[]
  }

  export type ClientCreateNestedOneWithoutUsersInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    connect?: ClientWhereUniqueInput
  }

  export type LogCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    connect?: PasswordResetTokenWhereUniqueInput
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserPreferencesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput> | UserPreferencesCreateWithoutUserInput[] | UserPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput | UserPreferencesCreateOrConnectWithoutUserInput[]
    createMany?: UserPreferencesCreateManyUserInputEnvelope
    connect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[]
  }

  export type UserCommsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCommsCreateWithoutUserInput, UserCommsUncheckedCreateWithoutUserInput> | UserCommsCreateWithoutUserInput[] | UserCommsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCommsCreateOrConnectWithoutUserInput | UserCommsCreateOrConnectWithoutUserInput[]
    createMany?: UserCommsCreateManyUserInputEnvelope
    connect?: UserCommsWhereUniqueInput | UserCommsWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    connect?: PasswordResetTokenWhereUniqueInput
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type UserPreferencesUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput> | UserPreferencesCreateWithoutUserInput[] | UserPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput | UserPreferencesCreateOrConnectWithoutUserInput[]
    upsert?: UserPreferencesUpsertWithWhereUniqueWithoutUserInput | UserPreferencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPreferencesCreateManyUserInputEnvelope
    set?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[]
    disconnect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[]
    delete?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[]
    connect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[]
    update?: UserPreferencesUpdateWithWhereUniqueWithoutUserInput | UserPreferencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPreferencesUpdateManyWithWhereWithoutUserInput | UserPreferencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPreferencesScalarWhereInput | UserPreferencesScalarWhereInput[]
  }

  export type UserCommsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCommsCreateWithoutUserInput, UserCommsUncheckedCreateWithoutUserInput> | UserCommsCreateWithoutUserInput[] | UserCommsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCommsCreateOrConnectWithoutUserInput | UserCommsCreateOrConnectWithoutUserInput[]
    upsert?: UserCommsUpsertWithWhereUniqueWithoutUserInput | UserCommsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCommsCreateManyUserInputEnvelope
    set?: UserCommsWhereUniqueInput | UserCommsWhereUniqueInput[]
    disconnect?: UserCommsWhereUniqueInput | UserCommsWhereUniqueInput[]
    delete?: UserCommsWhereUniqueInput | UserCommsWhereUniqueInput[]
    connect?: UserCommsWhereUniqueInput | UserCommsWhereUniqueInput[]
    update?: UserCommsUpdateWithWhereUniqueWithoutUserInput | UserCommsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCommsUpdateManyWithWhereWithoutUserInput | UserCommsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCommsScalarWhereInput | UserCommsScalarWhereInput[]
  }

  export type ClientUpdateOneWithoutUsersNestedInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    upsert?: ClientUpsertWithoutUsersInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUsersInput, ClientUpdateWithoutUsersInput>, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type LogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    upsert?: PasswordResetTokenUpsertWithoutUserInput
    disconnect?: PasswordResetTokenWhereInput | boolean
    delete?: PasswordResetTokenWhereInput | boolean
    connect?: PasswordResetTokenWhereUniqueInput
    update?: XOR<XOR<PasswordResetTokenUpdateToOneWithWhereWithoutUserInput, PasswordResetTokenUpdateWithoutUserInput>, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserPreferencesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput> | UserPreferencesCreateWithoutUserInput[] | UserPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput | UserPreferencesCreateOrConnectWithoutUserInput[]
    upsert?: UserPreferencesUpsertWithWhereUniqueWithoutUserInput | UserPreferencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPreferencesCreateManyUserInputEnvelope
    set?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[]
    disconnect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[]
    delete?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[]
    connect?: UserPreferencesWhereUniqueInput | UserPreferencesWhereUniqueInput[]
    update?: UserPreferencesUpdateWithWhereUniqueWithoutUserInput | UserPreferencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPreferencesUpdateManyWithWhereWithoutUserInput | UserPreferencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPreferencesScalarWhereInput | UserPreferencesScalarWhereInput[]
  }

  export type UserCommsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCommsCreateWithoutUserInput, UserCommsUncheckedCreateWithoutUserInput> | UserCommsCreateWithoutUserInput[] | UserCommsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCommsCreateOrConnectWithoutUserInput | UserCommsCreateOrConnectWithoutUserInput[]
    upsert?: UserCommsUpsertWithWhereUniqueWithoutUserInput | UserCommsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCommsCreateManyUserInputEnvelope
    set?: UserCommsWhereUniqueInput | UserCommsWhereUniqueInput[]
    disconnect?: UserCommsWhereUniqueInput | UserCommsWhereUniqueInput[]
    delete?: UserCommsWhereUniqueInput | UserCommsWhereUniqueInput[]
    connect?: UserCommsWhereUniqueInput | UserCommsWhereUniqueInput[]
    update?: UserCommsUpdateWithWhereUniqueWithoutUserInput | UserCommsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCommsUpdateManyWithWhereWithoutUserInput | UserCommsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCommsScalarWhereInput | UserCommsScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput
    upsert?: PasswordResetTokenUpsertWithoutUserInput
    disconnect?: PasswordResetTokenWhereInput | boolean
    delete?: PasswordResetTokenWhereInput | boolean
    connect?: PasswordResetTokenWhereUniqueInput
    update?: XOR<XOR<PasswordResetTokenUpdateToOneWithWhereWithoutUserInput, PasswordResetTokenUpdateWithoutUserInput>, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutResetTokenInput = {
    create?: XOR<UserCreateWithoutResetTokenInput, UserUncheckedCreateWithoutResetTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutResetTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResetTokenNestedInput = {
    create?: XOR<UserCreateWithoutResetTokenInput, UserUncheckedCreateWithoutResetTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutResetTokenInput
    upsert?: UserUpsertWithoutResetTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResetTokenInput, UserUpdateWithoutResetTokenInput>, UserUncheckedUpdateWithoutResetTokenInput>
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserCreateNestedOneWithoutCommsInput = {
    create?: XOR<UserCreateWithoutCommsInput, UserUncheckedCreateWithoutCommsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCommsChannelsFieldUpdateOperationsInput = {
    set?: $Enums.CommsChannels
  }

  export type UserUpdateOneRequiredWithoutCommsNestedInput = {
    create?: XOR<UserCreateWithoutCommsInput, UserUncheckedCreateWithoutCommsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommsInput
    upsert?: UserUpsertWithoutCommsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommsInput, UserUpdateWithoutCommsInput>, UserUncheckedUpdateWithoutCommsInput>
  }

  export type AddressCreateNestedOneWithoutClientInput = {
    create?: XOR<AddressCreateWithoutClientInput, AddressUncheckedCreateWithoutClientInput>
    connectOrCreate?: AddressCreateOrConnectWithoutClientInput
    connect?: AddressWhereUniqueInput
  }

  export type ClientDMBCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientDMBCreateWithoutClientInput, ClientDMBUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientDMBCreateOrConnectWithoutClientInput
    connect?: ClientDMBWhereUniqueInput
  }

  export type BalanceCreateNestedManyWithoutClientInput = {
    create?: XOR<BalanceCreateWithoutClientInput, BalanceUncheckedCreateWithoutClientInput> | BalanceCreateWithoutClientInput[] | BalanceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutClientInput | BalanceCreateOrConnectWithoutClientInput[]
    createMany?: BalanceCreateManyClientInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type ClientPaymentInformationCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientPaymentInformationCreateWithoutClientInput, ClientPaymentInformationUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientPaymentInformationCreateOrConnectWithoutClientInput
    connect?: ClientPaymentInformationWhereUniqueInput
  }

  export type LabelCreateNestedManyWithoutClientInput = {
    create?: XOR<LabelCreateWithoutClientInput, LabelUncheckedCreateWithoutClientInput> | LabelCreateWithoutClientInput[] | LabelUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutClientInput | LabelCreateOrConnectWithoutClientInput[]
    createMany?: LabelCreateManyClientInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ContractCreateNestedOneWithoutClientInput = {
    create?: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput>
    connectOrCreate?: ContractCreateOrConnectWithoutClientInput
    connect?: ContractWhereUniqueInput
  }

  export type UserRoyaltyReportCreateNestedManyWithoutClientInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutClientInput, UserRoyaltyReportUncheckedCreateWithoutClientInput> | UserRoyaltyReportCreateWithoutClientInput[] | UserRoyaltyReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutClientInput | UserRoyaltyReportCreateOrConnectWithoutClientInput[]
    createMany?: UserRoyaltyReportCreateManyClientInputEnvelope
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
  }

  export type ClientDMBUncheckedCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientDMBCreateWithoutClientInput, ClientDMBUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientDMBCreateOrConnectWithoutClientInput
    connect?: ClientDMBWhereUniqueInput
  }

  export type BalanceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<BalanceCreateWithoutClientInput, BalanceUncheckedCreateWithoutClientInput> | BalanceCreateWithoutClientInput[] | BalanceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutClientInput | BalanceCreateOrConnectWithoutClientInput[]
    createMany?: BalanceCreateManyClientInputEnvelope
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
  }

  export type ClientPaymentInformationUncheckedCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientPaymentInformationCreateWithoutClientInput, ClientPaymentInformationUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientPaymentInformationCreateOrConnectWithoutClientInput
    connect?: ClientPaymentInformationWhereUniqueInput
  }

  export type LabelUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<LabelCreateWithoutClientInput, LabelUncheckedCreateWithoutClientInput> | LabelCreateWithoutClientInput[] | LabelUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutClientInput | LabelCreateOrConnectWithoutClientInput[]
    createMany?: LabelCreateManyClientInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedOneWithoutClientInput = {
    create?: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput>
    connectOrCreate?: ContractCreateOrConnectWithoutClientInput
    connect?: ContractWhereUniqueInput
  }

  export type UserRoyaltyReportUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutClientInput, UserRoyaltyReportUncheckedCreateWithoutClientInput> | UserRoyaltyReportCreateWithoutClientInput[] | UserRoyaltyReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutClientInput | UserRoyaltyReportCreateOrConnectWithoutClientInput[]
    createMany?: UserRoyaltyReportCreateManyClientInputEnvelope
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
  }

  export type EnumClientTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClientType
  }

  export type EnumTaxIdTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaxIdType
  }

  export type EnumClientStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClientStatus
  }

  export type AddressUpdateOneRequiredWithoutClientNestedInput = {
    create?: XOR<AddressCreateWithoutClientInput, AddressUncheckedCreateWithoutClientInput>
    connectOrCreate?: AddressCreateOrConnectWithoutClientInput
    upsert?: AddressUpsertWithoutClientInput
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutClientInput, AddressUpdateWithoutClientInput>, AddressUncheckedUpdateWithoutClientInput>
  }

  export type ClientDMBUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientDMBCreateWithoutClientInput, ClientDMBUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientDMBCreateOrConnectWithoutClientInput
    upsert?: ClientDMBUpsertWithoutClientInput
    disconnect?: ClientDMBWhereInput | boolean
    delete?: ClientDMBWhereInput | boolean
    connect?: ClientDMBWhereUniqueInput
    update?: XOR<XOR<ClientDMBUpdateToOneWithWhereWithoutClientInput, ClientDMBUpdateWithoutClientInput>, ClientDMBUncheckedUpdateWithoutClientInput>
  }

  export type BalanceUpdateManyWithoutClientNestedInput = {
    create?: XOR<BalanceCreateWithoutClientInput, BalanceUncheckedCreateWithoutClientInput> | BalanceCreateWithoutClientInput[] | BalanceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutClientInput | BalanceCreateOrConnectWithoutClientInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutClientInput | BalanceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: BalanceCreateManyClientInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutClientInput | BalanceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutClientInput | BalanceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type ClientPaymentInformationUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientPaymentInformationCreateWithoutClientInput, ClientPaymentInformationUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientPaymentInformationCreateOrConnectWithoutClientInput
    upsert?: ClientPaymentInformationUpsertWithoutClientInput
    disconnect?: ClientPaymentInformationWhereInput | boolean
    delete?: ClientPaymentInformationWhereInput | boolean
    connect?: ClientPaymentInformationWhereUniqueInput
    update?: XOR<XOR<ClientPaymentInformationUpdateToOneWithWhereWithoutClientInput, ClientPaymentInformationUpdateWithoutClientInput>, ClientPaymentInformationUncheckedUpdateWithoutClientInput>
  }

  export type LabelUpdateManyWithoutClientNestedInput = {
    create?: XOR<LabelCreateWithoutClientInput, LabelUncheckedCreateWithoutClientInput> | LabelCreateWithoutClientInput[] | LabelUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutClientInput | LabelCreateOrConnectWithoutClientInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutClientInput | LabelUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LabelCreateManyClientInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutClientInput | LabelUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutClientInput | LabelUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type UserUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClientInput | UserUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClientInput | UserUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClientInput | UserUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ContractUpdateOneWithoutClientNestedInput = {
    create?: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput>
    connectOrCreate?: ContractCreateOrConnectWithoutClientInput
    upsert?: ContractUpsertWithoutClientInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutClientInput, ContractUpdateWithoutClientInput>, ContractUncheckedUpdateWithoutClientInput>
  }

  export type UserRoyaltyReportUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutClientInput, UserRoyaltyReportUncheckedCreateWithoutClientInput> | UserRoyaltyReportCreateWithoutClientInput[] | UserRoyaltyReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutClientInput | UserRoyaltyReportCreateOrConnectWithoutClientInput[]
    upsert?: UserRoyaltyReportUpsertWithWhereUniqueWithoutClientInput | UserRoyaltyReportUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserRoyaltyReportCreateManyClientInputEnvelope
    set?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    disconnect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    delete?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    update?: UserRoyaltyReportUpdateWithWhereUniqueWithoutClientInput | UserRoyaltyReportUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserRoyaltyReportUpdateManyWithWhereWithoutClientInput | UserRoyaltyReportUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserRoyaltyReportScalarWhereInput | UserRoyaltyReportScalarWhereInput[]
  }

  export type ClientDMBUncheckedUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientDMBCreateWithoutClientInput, ClientDMBUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientDMBCreateOrConnectWithoutClientInput
    upsert?: ClientDMBUpsertWithoutClientInput
    disconnect?: ClientDMBWhereInput | boolean
    delete?: ClientDMBWhereInput | boolean
    connect?: ClientDMBWhereUniqueInput
    update?: XOR<XOR<ClientDMBUpdateToOneWithWhereWithoutClientInput, ClientDMBUpdateWithoutClientInput>, ClientDMBUncheckedUpdateWithoutClientInput>
  }

  export type BalanceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<BalanceCreateWithoutClientInput, BalanceUncheckedCreateWithoutClientInput> | BalanceCreateWithoutClientInput[] | BalanceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BalanceCreateOrConnectWithoutClientInput | BalanceCreateOrConnectWithoutClientInput[]
    upsert?: BalanceUpsertWithWhereUniqueWithoutClientInput | BalanceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: BalanceCreateManyClientInputEnvelope
    set?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    disconnect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    delete?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    connect?: BalanceWhereUniqueInput | BalanceWhereUniqueInput[]
    update?: BalanceUpdateWithWhereUniqueWithoutClientInput | BalanceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: BalanceUpdateManyWithWhereWithoutClientInput | BalanceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
  }

  export type ClientPaymentInformationUncheckedUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientPaymentInformationCreateWithoutClientInput, ClientPaymentInformationUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientPaymentInformationCreateOrConnectWithoutClientInput
    upsert?: ClientPaymentInformationUpsertWithoutClientInput
    disconnect?: ClientPaymentInformationWhereInput | boolean
    delete?: ClientPaymentInformationWhereInput | boolean
    connect?: ClientPaymentInformationWhereUniqueInput
    update?: XOR<XOR<ClientPaymentInformationUpdateToOneWithWhereWithoutClientInput, ClientPaymentInformationUpdateWithoutClientInput>, ClientPaymentInformationUncheckedUpdateWithoutClientInput>
  }

  export type LabelUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<LabelCreateWithoutClientInput, LabelUncheckedCreateWithoutClientInput> | LabelCreateWithoutClientInput[] | LabelUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutClientInput | LabelCreateOrConnectWithoutClientInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutClientInput | LabelUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LabelCreateManyClientInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutClientInput | LabelUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutClientInput | LabelUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClientInput | UserUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClientInput | UserUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClientInput | UserUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ContractUncheckedUpdateOneWithoutClientNestedInput = {
    create?: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput>
    connectOrCreate?: ContractCreateOrConnectWithoutClientInput
    upsert?: ContractUpsertWithoutClientInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutClientInput, ContractUpdateWithoutClientInput>, ContractUncheckedUpdateWithoutClientInput>
  }

  export type UserRoyaltyReportUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutClientInput, UserRoyaltyReportUncheckedCreateWithoutClientInput> | UserRoyaltyReportCreateWithoutClientInput[] | UserRoyaltyReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutClientInput | UserRoyaltyReportCreateOrConnectWithoutClientInput[]
    upsert?: UserRoyaltyReportUpsertWithWhereUniqueWithoutClientInput | UserRoyaltyReportUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserRoyaltyReportCreateManyClientInputEnvelope
    set?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    disconnect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    delete?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    update?: UserRoyaltyReportUpdateWithWhereUniqueWithoutClientInput | UserRoyaltyReportUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserRoyaltyReportUpdateManyWithWhereWithoutClientInput | UserRoyaltyReportUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserRoyaltyReportScalarWhereInput | UserRoyaltyReportScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutDmbInput = {
    create?: XOR<ClientCreateWithoutDmbInput, ClientUncheckedCreateWithoutDmbInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDmbInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumAccessTypeDMBFieldUpdateOperationsInput = {
    set?: $Enums.AccessTypeDMB
  }

  export type EnumDMBStatusFieldUpdateOperationsInput = {
    set?: $Enums.DMBStatus
  }

  export type ClientUpdateOneRequiredWithoutDmbNestedInput = {
    create?: XOR<ClientCreateWithoutDmbInput, ClientUncheckedCreateWithoutDmbInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDmbInput
    upsert?: ClientUpsertWithoutDmbInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDmbInput, ClientUpdateWithoutDmbInput>, ClientUncheckedUpdateWithoutDmbInput>
  }

  export type ClientCreateNestedOneWithoutPaymentDataInput = {
    create?: XOR<ClientCreateWithoutPaymentDataInput, ClientUncheckedCreateWithoutPaymentDataInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPaymentDataInput
    connect?: ClientWhereUniqueInput
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type ClientUpdateOneRequiredWithoutPaymentDataNestedInput = {
    create?: XOR<ClientCreateWithoutPaymentDataInput, ClientUncheckedCreateWithoutPaymentDataInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPaymentDataInput
    upsert?: ClientUpsertWithoutPaymentDataInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutPaymentDataInput, ClientUpdateWithoutPaymentDataInput>, ClientUncheckedUpdateWithoutPaymentDataInput>
  }

  export type ClientCreateNestedOneWithoutContractInput = {
    create?: XOR<ClientCreateWithoutContractInput, ClientUncheckedCreateWithoutContractInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContractInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContractType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumContractStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContractStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClientUpdateOneWithoutContractNestedInput = {
    create?: XOR<ClientCreateWithoutContractInput, ClientUncheckedCreateWithoutContractInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContractInput
    upsert?: ClientUpsertWithoutContractInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutContractInput, ClientUpdateWithoutContractInput>, ClientUncheckedUpdateWithoutContractInput>
  }

  export type ClientCreateNestedOneWithoutBalancesInput = {
    create?: XOR<ClientCreateWithoutBalancesInput, ClientUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBalancesInput
    connect?: ClientWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutBalanceInput = {
    create?: XOR<TransactionCreateWithoutBalanceInput, TransactionUncheckedCreateWithoutBalanceInput> | TransactionCreateWithoutBalanceInput[] | TransactionUncheckedCreateWithoutBalanceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBalanceInput | TransactionCreateOrConnectWithoutBalanceInput[]
    createMany?: TransactionCreateManyBalanceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutBalanceInput = {
    create?: XOR<TransactionCreateWithoutBalanceInput, TransactionUncheckedCreateWithoutBalanceInput> | TransactionCreateWithoutBalanceInput[] | TransactionUncheckedCreateWithoutBalanceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBalanceInput | TransactionCreateOrConnectWithoutBalanceInput[]
    createMany?: TransactionCreateManyBalanceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumCurrencyFieldUpdateOperationsInput = {
    set?: $Enums.Currency
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ClientUpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<ClientCreateWithoutBalancesInput, ClientUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutBalancesInput
    upsert?: ClientUpsertWithoutBalancesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutBalancesInput, ClientUpdateWithoutBalancesInput>, ClientUncheckedUpdateWithoutBalancesInput>
  }

  export type TransactionUpdateManyWithoutBalanceNestedInput = {
    create?: XOR<TransactionCreateWithoutBalanceInput, TransactionUncheckedCreateWithoutBalanceInput> | TransactionCreateWithoutBalanceInput[] | TransactionUncheckedCreateWithoutBalanceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBalanceInput | TransactionCreateOrConnectWithoutBalanceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBalanceInput | TransactionUpsertWithWhereUniqueWithoutBalanceInput[]
    createMany?: TransactionCreateManyBalanceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBalanceInput | TransactionUpdateWithWhereUniqueWithoutBalanceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBalanceInput | TransactionUpdateManyWithWhereWithoutBalanceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutBalanceNestedInput = {
    create?: XOR<TransactionCreateWithoutBalanceInput, TransactionUncheckedCreateWithoutBalanceInput> | TransactionCreateWithoutBalanceInput[] | TransactionUncheckedCreateWithoutBalanceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBalanceInput | TransactionCreateOrConnectWithoutBalanceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBalanceInput | TransactionUpsertWithWhereUniqueWithoutBalanceInput[]
    createMany?: TransactionCreateManyBalanceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBalanceInput | TransactionUpdateWithWhereUniqueWithoutBalanceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBalanceInput | TransactionUpdateManyWithWhereWithoutBalanceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BalanceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BalanceCreateWithoutTransactionsInput, BalanceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BalanceCreateOrConnectWithoutTransactionsInput
    connect?: BalanceWhereUniqueInput
  }

  export type BaseRoyaltyReportCreateNestedOneWithoutTransactionInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutTransactionInput, BaseRoyaltyReportUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutTransactionInput
    connect?: BaseRoyaltyReportWhereUniqueInput
  }

  export type UserRoyaltyReportCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutTransactionsInput, UserRoyaltyReportUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutTransactionsInput
    connect?: UserRoyaltyReportWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type NullableEnumDistributorFieldUpdateOperationsInput = {
    set?: $Enums.Distributor | null
  }

  export type BalanceUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<BalanceCreateWithoutTransactionsInput, BalanceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BalanceCreateOrConnectWithoutTransactionsInput
    upsert?: BalanceUpsertWithoutTransactionsInput
    connect?: BalanceWhereUniqueInput
    update?: XOR<XOR<BalanceUpdateToOneWithWhereWithoutTransactionsInput, BalanceUpdateWithoutTransactionsInput>, BalanceUncheckedUpdateWithoutTransactionsInput>
  }

  export type BaseRoyaltyReportUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutTransactionInput, BaseRoyaltyReportUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutTransactionInput
    upsert?: BaseRoyaltyReportUpsertWithoutTransactionInput
    disconnect?: BaseRoyaltyReportWhereInput | boolean
    delete?: BaseRoyaltyReportWhereInput | boolean
    connect?: BaseRoyaltyReportWhereUniqueInput
    update?: XOR<XOR<BaseRoyaltyReportUpdateToOneWithWhereWithoutTransactionInput, BaseRoyaltyReportUpdateWithoutTransactionInput>, BaseRoyaltyReportUncheckedUpdateWithoutTransactionInput>
  }

  export type UserRoyaltyReportUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutTransactionsInput, UserRoyaltyReportUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutTransactionsInput
    upsert?: UserRoyaltyReportUpsertWithoutTransactionsInput
    disconnect?: UserRoyaltyReportWhereInput | boolean
    delete?: UserRoyaltyReportWhereInput | boolean
    connect?: UserRoyaltyReportWhereUniqueInput
    update?: XOR<XOR<UserRoyaltyReportUpdateToOneWithWhereWithoutTransactionsInput, UserRoyaltyReportUpdateWithoutTransactionsInput>, UserRoyaltyReportUncheckedUpdateWithoutTransactionsInput>
  }

  export type CountryCreateNestedOneWithoutAddressInput = {
    create?: XOR<CountryCreateWithoutAddressInput, CountryUncheckedCreateWithoutAddressInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAddressInput
    connect?: CountryWhereUniqueInput
  }

  export type ClientCreateNestedManyWithoutAddressInput = {
    create?: XOR<ClientCreateWithoutAddressInput, ClientUncheckedCreateWithoutAddressInput> | ClientCreateWithoutAddressInput[] | ClientUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAddressInput | ClientCreateOrConnectWithoutAddressInput[]
    createMany?: ClientCreateManyAddressInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<ClientCreateWithoutAddressInput, ClientUncheckedCreateWithoutAddressInput> | ClientCreateWithoutAddressInput[] | ClientUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAddressInput | ClientCreateOrConnectWithoutAddressInput[]
    createMany?: ClientCreateManyAddressInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<CountryCreateWithoutAddressInput, CountryUncheckedCreateWithoutAddressInput>
    connectOrCreate?: CountryCreateOrConnectWithoutAddressInput
    upsert?: CountryUpsertWithoutAddressInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutAddressInput, CountryUpdateWithoutAddressInput>, CountryUncheckedUpdateWithoutAddressInput>
  }

  export type ClientUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ClientCreateWithoutAddressInput, ClientUncheckedCreateWithoutAddressInput> | ClientCreateWithoutAddressInput[] | ClientUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAddressInput | ClientCreateOrConnectWithoutAddressInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutAddressInput | ClientUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ClientCreateManyAddressInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutAddressInput | ClientUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutAddressInput | ClientUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ClientCreateWithoutAddressInput, ClientUncheckedCreateWithoutAddressInput> | ClientCreateWithoutAddressInput[] | ClientUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutAddressInput | ClientCreateOrConnectWithoutAddressInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutAddressInput | ClientUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ClientCreateManyAddressInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutAddressInput | ClientUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutAddressInput | ClientUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type AddressCreateNestedManyWithoutCountryInput = {
    create?: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput> | AddressCreateWithoutCountryInput[] | AddressUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCountryInput | AddressCreateOrConnectWithoutCountryInput[]
    createMany?: AddressCreateManyCountryInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type LabelCreateNestedManyWithoutCountryInput = {
    create?: XOR<LabelCreateWithoutCountryInput, LabelUncheckedCreateWithoutCountryInput> | LabelCreateWithoutCountryInput[] | LabelUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutCountryInput | LabelCreateOrConnectWithoutCountryInput[]
    createMany?: LabelCreateManyCountryInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput> | AddressCreateWithoutCountryInput[] | AddressUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCountryInput | AddressCreateOrConnectWithoutCountryInput[]
    createMany?: AddressCreateManyCountryInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type LabelUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<LabelCreateWithoutCountryInput, LabelUncheckedCreateWithoutCountryInput> | LabelCreateWithoutCountryInput[] | LabelUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutCountryInput | LabelCreateOrConnectWithoutCountryInput[]
    createMany?: LabelCreateManyCountryInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type AddressUpdateManyWithoutCountryNestedInput = {
    create?: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput> | AddressCreateWithoutCountryInput[] | AddressUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCountryInput | AddressCreateOrConnectWithoutCountryInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCountryInput | AddressUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: AddressCreateManyCountryInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCountryInput | AddressUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCountryInput | AddressUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type LabelUpdateManyWithoutCountryNestedInput = {
    create?: XOR<LabelCreateWithoutCountryInput, LabelUncheckedCreateWithoutCountryInput> | LabelCreateWithoutCountryInput[] | LabelUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutCountryInput | LabelCreateOrConnectWithoutCountryInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutCountryInput | LabelUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: LabelCreateManyCountryInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutCountryInput | LabelUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutCountryInput | LabelUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput> | AddressCreateWithoutCountryInput[] | AddressUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCountryInput | AddressCreateOrConnectWithoutCountryInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCountryInput | AddressUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: AddressCreateManyCountryInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCountryInput | AddressUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCountryInput | AddressUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type LabelUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<LabelCreateWithoutCountryInput, LabelUncheckedCreateWithoutCountryInput> | LabelCreateWithoutCountryInput[] | LabelUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutCountryInput | LabelCreateOrConnectWithoutCountryInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutCountryInput | LabelUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: LabelCreateManyCountryInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutCountryInput | LabelUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutCountryInput | LabelUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutLabelsInput = {
    create?: XOR<ClientCreateWithoutLabelsInput, ClientUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLabelsInput
    connect?: ClientWhereUniqueInput
  }

  export type CountryCreateNestedOneWithoutLabelInput = {
    create?: XOR<CountryCreateWithoutLabelInput, CountryUncheckedCreateWithoutLabelInput>
    connectOrCreate?: CountryCreateOrConnectWithoutLabelInput
    connect?: CountryWhereUniqueInput
  }

  export type KontorRoyaltyReportCreateNestedManyWithoutLabelInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutLabelInput, KontorRoyaltyReportUncheckedCreateWithoutLabelInput> | KontorRoyaltyReportCreateWithoutLabelInput[] | KontorRoyaltyReportUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutLabelInput | KontorRoyaltyReportCreateOrConnectWithoutLabelInput[]
    createMany?: KontorRoyaltyReportCreateManyLabelInputEnvelope
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
  }

  export type BelieveRoyaltyReportCreateNestedManyWithoutLabelInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutLabelInput, BelieveRoyaltyReportUncheckedCreateWithoutLabelInput> | BelieveRoyaltyReportCreateWithoutLabelInput[] | BelieveRoyaltyReportUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutLabelInput | BelieveRoyaltyReportCreateOrConnectWithoutLabelInput[]
    createMany?: BelieveRoyaltyReportCreateManyLabelInputEnvelope
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
  }

  export type KontorRoyaltyReportUncheckedCreateNestedManyWithoutLabelInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutLabelInput, KontorRoyaltyReportUncheckedCreateWithoutLabelInput> | KontorRoyaltyReportCreateWithoutLabelInput[] | KontorRoyaltyReportUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutLabelInput | KontorRoyaltyReportCreateOrConnectWithoutLabelInput[]
    createMany?: KontorRoyaltyReportCreateManyLabelInputEnvelope
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
  }

  export type BelieveRoyaltyReportUncheckedCreateNestedManyWithoutLabelInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutLabelInput, BelieveRoyaltyReportUncheckedCreateWithoutLabelInput> | BelieveRoyaltyReportCreateWithoutLabelInput[] | BelieveRoyaltyReportUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutLabelInput | BelieveRoyaltyReportCreateOrConnectWithoutLabelInput[]
    createMany?: BelieveRoyaltyReportCreateManyLabelInputEnvelope
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
  }

  export type EnumLabelStatusFieldUpdateOperationsInput = {
    set?: $Enums.LabelStatus
  }

  export type EnumLabelRegistrationStatusFieldUpdateOperationsInput = {
    set?: $Enums.LabelRegistrationStatus
  }

  export type ClientUpdateOneRequiredWithoutLabelsNestedInput = {
    create?: XOR<ClientCreateWithoutLabelsInput, ClientUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLabelsInput
    upsert?: ClientUpsertWithoutLabelsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutLabelsInput, ClientUpdateWithoutLabelsInput>, ClientUncheckedUpdateWithoutLabelsInput>
  }

  export type CountryUpdateOneWithoutLabelNestedInput = {
    create?: XOR<CountryCreateWithoutLabelInput, CountryUncheckedCreateWithoutLabelInput>
    connectOrCreate?: CountryCreateOrConnectWithoutLabelInput
    upsert?: CountryUpsertWithoutLabelInput
    disconnect?: CountryWhereInput | boolean
    delete?: CountryWhereInput | boolean
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutLabelInput, CountryUpdateWithoutLabelInput>, CountryUncheckedUpdateWithoutLabelInput>
  }

  export type KontorRoyaltyReportUpdateManyWithoutLabelNestedInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutLabelInput, KontorRoyaltyReportUncheckedCreateWithoutLabelInput> | KontorRoyaltyReportCreateWithoutLabelInput[] | KontorRoyaltyReportUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutLabelInput | KontorRoyaltyReportCreateOrConnectWithoutLabelInput[]
    upsert?: KontorRoyaltyReportUpsertWithWhereUniqueWithoutLabelInput | KontorRoyaltyReportUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: KontorRoyaltyReportCreateManyLabelInputEnvelope
    set?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    disconnect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    delete?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    update?: KontorRoyaltyReportUpdateWithWhereUniqueWithoutLabelInput | KontorRoyaltyReportUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: KontorRoyaltyReportUpdateManyWithWhereWithoutLabelInput | KontorRoyaltyReportUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: KontorRoyaltyReportScalarWhereInput | KontorRoyaltyReportScalarWhereInput[]
  }

  export type BelieveRoyaltyReportUpdateManyWithoutLabelNestedInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutLabelInput, BelieveRoyaltyReportUncheckedCreateWithoutLabelInput> | BelieveRoyaltyReportCreateWithoutLabelInput[] | BelieveRoyaltyReportUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutLabelInput | BelieveRoyaltyReportCreateOrConnectWithoutLabelInput[]
    upsert?: BelieveRoyaltyReportUpsertWithWhereUniqueWithoutLabelInput | BelieveRoyaltyReportUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: BelieveRoyaltyReportCreateManyLabelInputEnvelope
    set?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    disconnect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    delete?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    update?: BelieveRoyaltyReportUpdateWithWhereUniqueWithoutLabelInput | BelieveRoyaltyReportUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: BelieveRoyaltyReportUpdateManyWithWhereWithoutLabelInput | BelieveRoyaltyReportUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: BelieveRoyaltyReportScalarWhereInput | BelieveRoyaltyReportScalarWhereInput[]
  }

  export type KontorRoyaltyReportUncheckedUpdateManyWithoutLabelNestedInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutLabelInput, KontorRoyaltyReportUncheckedCreateWithoutLabelInput> | KontorRoyaltyReportCreateWithoutLabelInput[] | KontorRoyaltyReportUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutLabelInput | KontorRoyaltyReportCreateOrConnectWithoutLabelInput[]
    upsert?: KontorRoyaltyReportUpsertWithWhereUniqueWithoutLabelInput | KontorRoyaltyReportUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: KontorRoyaltyReportCreateManyLabelInputEnvelope
    set?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    disconnect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    delete?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    update?: KontorRoyaltyReportUpdateWithWhereUniqueWithoutLabelInput | KontorRoyaltyReportUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: KontorRoyaltyReportUpdateManyWithWhereWithoutLabelInput | KontorRoyaltyReportUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: KontorRoyaltyReportScalarWhereInput | KontorRoyaltyReportScalarWhereInput[]
  }

  export type BelieveRoyaltyReportUncheckedUpdateManyWithoutLabelNestedInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutLabelInput, BelieveRoyaltyReportUncheckedCreateWithoutLabelInput> | BelieveRoyaltyReportCreateWithoutLabelInput[] | BelieveRoyaltyReportUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutLabelInput | BelieveRoyaltyReportCreateOrConnectWithoutLabelInput[]
    upsert?: BelieveRoyaltyReportUpsertWithWhereUniqueWithoutLabelInput | BelieveRoyaltyReportUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: BelieveRoyaltyReportCreateManyLabelInputEnvelope
    set?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    disconnect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    delete?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    update?: BelieveRoyaltyReportUpdateWithWhereUniqueWithoutLabelInput | BelieveRoyaltyReportUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: BelieveRoyaltyReportUpdateManyWithWhereWithoutLabelInput | BelieveRoyaltyReportUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: BelieveRoyaltyReportScalarWhereInput | BelieveRoyaltyReportScalarWhereInput[]
  }

  export type S3FileCreateNestedOneWithoutImportedRoyaltyReportInput = {
    create?: XOR<S3FileCreateWithoutImportedRoyaltyReportInput, S3FileUncheckedCreateWithoutImportedRoyaltyReportInput>
    connectOrCreate?: S3FileCreateOrConnectWithoutImportedRoyaltyReportInput
    connect?: S3FileWhereUniqueInput
  }

  export type KontorRoyaltyReportCreateNestedManyWithoutImportedReportInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutImportedReportInput, KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput> | KontorRoyaltyReportCreateWithoutImportedReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutImportedReportInput | KontorRoyaltyReportCreateOrConnectWithoutImportedReportInput[]
    createMany?: KontorRoyaltyReportCreateManyImportedReportInputEnvelope
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
  }

  export type BelieveRoyaltyReportCreateNestedManyWithoutImportedReportInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutImportedReportInput, BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput> | BelieveRoyaltyReportCreateWithoutImportedReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutImportedReportInput | BelieveRoyaltyReportCreateOrConnectWithoutImportedReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyImportedReportInputEnvelope
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
  }

  export type KontorRoyaltyReportUncheckedCreateNestedManyWithoutImportedReportInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutImportedReportInput, KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput> | KontorRoyaltyReportCreateWithoutImportedReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutImportedReportInput | KontorRoyaltyReportCreateOrConnectWithoutImportedReportInput[]
    createMany?: KontorRoyaltyReportCreateManyImportedReportInputEnvelope
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
  }

  export type BelieveRoyaltyReportUncheckedCreateNestedManyWithoutImportedReportInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutImportedReportInput, BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput> | BelieveRoyaltyReportCreateWithoutImportedReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutImportedReportInput | BelieveRoyaltyReportCreateOrConnectWithoutImportedReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyImportedReportInputEnvelope
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
  }

  export type EnumDistributorFieldUpdateOperationsInput = {
    set?: $Enums.Distributor
  }

  export type S3FileUpdateOneWithoutImportedRoyaltyReportNestedInput = {
    create?: XOR<S3FileCreateWithoutImportedRoyaltyReportInput, S3FileUncheckedCreateWithoutImportedRoyaltyReportInput>
    connectOrCreate?: S3FileCreateOrConnectWithoutImportedRoyaltyReportInput
    upsert?: S3FileUpsertWithoutImportedRoyaltyReportInput
    disconnect?: S3FileWhereInput | boolean
    delete?: S3FileWhereInput | boolean
    connect?: S3FileWhereUniqueInput
    update?: XOR<XOR<S3FileUpdateToOneWithWhereWithoutImportedRoyaltyReportInput, S3FileUpdateWithoutImportedRoyaltyReportInput>, S3FileUncheckedUpdateWithoutImportedRoyaltyReportInput>
  }

  export type KontorRoyaltyReportUpdateManyWithoutImportedReportNestedInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutImportedReportInput, KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput> | KontorRoyaltyReportCreateWithoutImportedReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutImportedReportInput | KontorRoyaltyReportCreateOrConnectWithoutImportedReportInput[]
    upsert?: KontorRoyaltyReportUpsertWithWhereUniqueWithoutImportedReportInput | KontorRoyaltyReportUpsertWithWhereUniqueWithoutImportedReportInput[]
    createMany?: KontorRoyaltyReportCreateManyImportedReportInputEnvelope
    set?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    disconnect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    delete?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    update?: KontorRoyaltyReportUpdateWithWhereUniqueWithoutImportedReportInput | KontorRoyaltyReportUpdateWithWhereUniqueWithoutImportedReportInput[]
    updateMany?: KontorRoyaltyReportUpdateManyWithWhereWithoutImportedReportInput | KontorRoyaltyReportUpdateManyWithWhereWithoutImportedReportInput[]
    deleteMany?: KontorRoyaltyReportScalarWhereInput | KontorRoyaltyReportScalarWhereInput[]
  }

  export type BelieveRoyaltyReportUpdateManyWithoutImportedReportNestedInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutImportedReportInput, BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput> | BelieveRoyaltyReportCreateWithoutImportedReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutImportedReportInput | BelieveRoyaltyReportCreateOrConnectWithoutImportedReportInput[]
    upsert?: BelieveRoyaltyReportUpsertWithWhereUniqueWithoutImportedReportInput | BelieveRoyaltyReportUpsertWithWhereUniqueWithoutImportedReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyImportedReportInputEnvelope
    set?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    disconnect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    delete?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    update?: BelieveRoyaltyReportUpdateWithWhereUniqueWithoutImportedReportInput | BelieveRoyaltyReportUpdateWithWhereUniqueWithoutImportedReportInput[]
    updateMany?: BelieveRoyaltyReportUpdateManyWithWhereWithoutImportedReportInput | BelieveRoyaltyReportUpdateManyWithWhereWithoutImportedReportInput[]
    deleteMany?: BelieveRoyaltyReportScalarWhereInput | BelieveRoyaltyReportScalarWhereInput[]
  }

  export type KontorRoyaltyReportUncheckedUpdateManyWithoutImportedReportNestedInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutImportedReportInput, KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput> | KontorRoyaltyReportCreateWithoutImportedReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutImportedReportInput | KontorRoyaltyReportCreateOrConnectWithoutImportedReportInput[]
    upsert?: KontorRoyaltyReportUpsertWithWhereUniqueWithoutImportedReportInput | KontorRoyaltyReportUpsertWithWhereUniqueWithoutImportedReportInput[]
    createMany?: KontorRoyaltyReportCreateManyImportedReportInputEnvelope
    set?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    disconnect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    delete?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    update?: KontorRoyaltyReportUpdateWithWhereUniqueWithoutImportedReportInput | KontorRoyaltyReportUpdateWithWhereUniqueWithoutImportedReportInput[]
    updateMany?: KontorRoyaltyReportUpdateManyWithWhereWithoutImportedReportInput | KontorRoyaltyReportUpdateManyWithWhereWithoutImportedReportInput[]
    deleteMany?: KontorRoyaltyReportScalarWhereInput | KontorRoyaltyReportScalarWhereInput[]
  }

  export type BelieveRoyaltyReportUncheckedUpdateManyWithoutImportedReportNestedInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutImportedReportInput, BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput> | BelieveRoyaltyReportCreateWithoutImportedReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutImportedReportInput | BelieveRoyaltyReportCreateOrConnectWithoutImportedReportInput[]
    upsert?: BelieveRoyaltyReportUpsertWithWhereUniqueWithoutImportedReportInput | BelieveRoyaltyReportUpsertWithWhereUniqueWithoutImportedReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyImportedReportInputEnvelope
    set?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    disconnect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    delete?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    update?: BelieveRoyaltyReportUpdateWithWhereUniqueWithoutImportedReportInput | BelieveRoyaltyReportUpdateWithWhereUniqueWithoutImportedReportInput[]
    updateMany?: BelieveRoyaltyReportUpdateManyWithWhereWithoutImportedReportInput | BelieveRoyaltyReportUpdateManyWithWhereWithoutImportedReportInput[]
    deleteMany?: BelieveRoyaltyReportScalarWhereInput | BelieveRoyaltyReportScalarWhereInput[]
  }

  export type S3FileCreateNestedOneWithoutBaseRoyaltyReportInput = {
    create?: XOR<S3FileCreateWithoutBaseRoyaltyReportInput, S3FileUncheckedCreateWithoutBaseRoyaltyReportInput>
    connectOrCreate?: S3FileCreateOrConnectWithoutBaseRoyaltyReportInput
    connect?: S3FileWhereUniqueInput
  }

  export type KontorRoyaltyReportCreateNestedManyWithoutBaseReportInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutBaseReportInput, KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput> | KontorRoyaltyReportCreateWithoutBaseReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutBaseReportInput | KontorRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    createMany?: KontorRoyaltyReportCreateManyBaseReportInputEnvelope
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
  }

  export type BelieveRoyaltyReportCreateNestedManyWithoutBaseReportInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutBaseReportInput, BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput> | BelieveRoyaltyReportCreateWithoutBaseReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutBaseReportInput | BelieveRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyBaseReportInputEnvelope
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
  }

  export type UserRoyaltyReportCreateNestedManyWithoutBaseReportInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutBaseReportInput, UserRoyaltyReportUncheckedCreateWithoutBaseReportInput> | UserRoyaltyReportCreateWithoutBaseReportInput[] | UserRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutBaseReportInput | UserRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    createMany?: UserRoyaltyReportCreateManyBaseReportInputEnvelope
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutBaseReportInput = {
    create?: XOR<TransactionCreateWithoutBaseReportInput, TransactionUncheckedCreateWithoutBaseReportInput> | TransactionCreateWithoutBaseReportInput[] | TransactionUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBaseReportInput | TransactionCreateOrConnectWithoutBaseReportInput[]
    createMany?: TransactionCreateManyBaseReportInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type KontorRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutBaseReportInput, KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput> | KontorRoyaltyReportCreateWithoutBaseReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutBaseReportInput | KontorRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    createMany?: KontorRoyaltyReportCreateManyBaseReportInputEnvelope
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
  }

  export type BelieveRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutBaseReportInput, BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput> | BelieveRoyaltyReportCreateWithoutBaseReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutBaseReportInput | BelieveRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyBaseReportInputEnvelope
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
  }

  export type UserRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutBaseReportInput, UserRoyaltyReportUncheckedCreateWithoutBaseReportInput> | UserRoyaltyReportCreateWithoutBaseReportInput[] | UserRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutBaseReportInput | UserRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    createMany?: UserRoyaltyReportCreateManyBaseReportInputEnvelope
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutBaseReportInput = {
    create?: XOR<TransactionCreateWithoutBaseReportInput, TransactionUncheckedCreateWithoutBaseReportInput> | TransactionCreateWithoutBaseReportInput[] | TransactionUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBaseReportInput | TransactionCreateOrConnectWithoutBaseReportInput[]
    createMany?: TransactionCreateManyBaseReportInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDebitStateFieldUpdateOperationsInput = {
    set?: $Enums.DebitState
  }

  export type S3FileUpdateOneWithoutBaseRoyaltyReportNestedInput = {
    create?: XOR<S3FileCreateWithoutBaseRoyaltyReportInput, S3FileUncheckedCreateWithoutBaseRoyaltyReportInput>
    connectOrCreate?: S3FileCreateOrConnectWithoutBaseRoyaltyReportInput
    upsert?: S3FileUpsertWithoutBaseRoyaltyReportInput
    disconnect?: S3FileWhereInput | boolean
    delete?: S3FileWhereInput | boolean
    connect?: S3FileWhereUniqueInput
    update?: XOR<XOR<S3FileUpdateToOneWithWhereWithoutBaseRoyaltyReportInput, S3FileUpdateWithoutBaseRoyaltyReportInput>, S3FileUncheckedUpdateWithoutBaseRoyaltyReportInput>
  }

  export type KontorRoyaltyReportUpdateManyWithoutBaseReportNestedInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutBaseReportInput, KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput> | KontorRoyaltyReportCreateWithoutBaseReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutBaseReportInput | KontorRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    upsert?: KontorRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput | KontorRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput[]
    createMany?: KontorRoyaltyReportCreateManyBaseReportInputEnvelope
    set?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    disconnect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    delete?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    update?: KontorRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput | KontorRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput[]
    updateMany?: KontorRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput | KontorRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput[]
    deleteMany?: KontorRoyaltyReportScalarWhereInput | KontorRoyaltyReportScalarWhereInput[]
  }

  export type BelieveRoyaltyReportUpdateManyWithoutBaseReportNestedInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutBaseReportInput, BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput> | BelieveRoyaltyReportCreateWithoutBaseReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutBaseReportInput | BelieveRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    upsert?: BelieveRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput | BelieveRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyBaseReportInputEnvelope
    set?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    disconnect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    delete?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    update?: BelieveRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput | BelieveRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput[]
    updateMany?: BelieveRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput | BelieveRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput[]
    deleteMany?: BelieveRoyaltyReportScalarWhereInput | BelieveRoyaltyReportScalarWhereInput[]
  }

  export type UserRoyaltyReportUpdateManyWithoutBaseReportNestedInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutBaseReportInput, UserRoyaltyReportUncheckedCreateWithoutBaseReportInput> | UserRoyaltyReportCreateWithoutBaseReportInput[] | UserRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutBaseReportInput | UserRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    upsert?: UserRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput | UserRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput[]
    createMany?: UserRoyaltyReportCreateManyBaseReportInputEnvelope
    set?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    disconnect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    delete?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    update?: UserRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput | UserRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput[]
    updateMany?: UserRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput | UserRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput[]
    deleteMany?: UserRoyaltyReportScalarWhereInput | UserRoyaltyReportScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutBaseReportNestedInput = {
    create?: XOR<TransactionCreateWithoutBaseReportInput, TransactionUncheckedCreateWithoutBaseReportInput> | TransactionCreateWithoutBaseReportInput[] | TransactionUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBaseReportInput | TransactionCreateOrConnectWithoutBaseReportInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBaseReportInput | TransactionUpsertWithWhereUniqueWithoutBaseReportInput[]
    createMany?: TransactionCreateManyBaseReportInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBaseReportInput | TransactionUpdateWithWhereUniqueWithoutBaseReportInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBaseReportInput | TransactionUpdateManyWithWhereWithoutBaseReportInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type KontorRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutBaseReportInput, KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput> | KontorRoyaltyReportCreateWithoutBaseReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutBaseReportInput | KontorRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    upsert?: KontorRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput | KontorRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput[]
    createMany?: KontorRoyaltyReportCreateManyBaseReportInputEnvelope
    set?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    disconnect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    delete?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    update?: KontorRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput | KontorRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput[]
    updateMany?: KontorRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput | KontorRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput[]
    deleteMany?: KontorRoyaltyReportScalarWhereInput | KontorRoyaltyReportScalarWhereInput[]
  }

  export type BelieveRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutBaseReportInput, BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput> | BelieveRoyaltyReportCreateWithoutBaseReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutBaseReportInput | BelieveRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    upsert?: BelieveRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput | BelieveRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyBaseReportInputEnvelope
    set?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    disconnect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    delete?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    update?: BelieveRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput | BelieveRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput[]
    updateMany?: BelieveRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput | BelieveRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput[]
    deleteMany?: BelieveRoyaltyReportScalarWhereInput | BelieveRoyaltyReportScalarWhereInput[]
  }

  export type UserRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutBaseReportInput, UserRoyaltyReportUncheckedCreateWithoutBaseReportInput> | UserRoyaltyReportCreateWithoutBaseReportInput[] | UserRoyaltyReportUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutBaseReportInput | UserRoyaltyReportCreateOrConnectWithoutBaseReportInput[]
    upsert?: UserRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput | UserRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput[]
    createMany?: UserRoyaltyReportCreateManyBaseReportInputEnvelope
    set?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    disconnect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    delete?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    connect?: UserRoyaltyReportWhereUniqueInput | UserRoyaltyReportWhereUniqueInput[]
    update?: UserRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput | UserRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput[]
    updateMany?: UserRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput | UserRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput[]
    deleteMany?: UserRoyaltyReportScalarWhereInput | UserRoyaltyReportScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutBaseReportNestedInput = {
    create?: XOR<TransactionCreateWithoutBaseReportInput, TransactionUncheckedCreateWithoutBaseReportInput> | TransactionCreateWithoutBaseReportInput[] | TransactionUncheckedCreateWithoutBaseReportInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutBaseReportInput | TransactionCreateOrConnectWithoutBaseReportInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutBaseReportInput | TransactionUpsertWithWhereUniqueWithoutBaseReportInput[]
    createMany?: TransactionCreateManyBaseReportInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutBaseReportInput | TransactionUpdateWithWhereUniqueWithoutBaseReportInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutBaseReportInput | TransactionUpdateManyWithWhereWithoutBaseReportInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type S3FileCreateNestedOneWithoutUserRoyaltyReportInput = {
    create?: XOR<S3FileCreateWithoutUserRoyaltyReportInput, S3FileUncheckedCreateWithoutUserRoyaltyReportInput>
    connectOrCreate?: S3FileCreateOrConnectWithoutUserRoyaltyReportInput
    connect?: S3FileWhereUniqueInput
  }

  export type KontorRoyaltyReportCreateNestedManyWithoutUserReportInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutUserReportInput, KontorRoyaltyReportUncheckedCreateWithoutUserReportInput> | KontorRoyaltyReportCreateWithoutUserReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutUserReportInput | KontorRoyaltyReportCreateOrConnectWithoutUserReportInput[]
    createMany?: KontorRoyaltyReportCreateManyUserReportInputEnvelope
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
  }

  export type BelieveRoyaltyReportCreateNestedManyWithoutUserReportInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutUserReportInput, BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput> | BelieveRoyaltyReportCreateWithoutUserReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutUserReportInput | BelieveRoyaltyReportCreateOrConnectWithoutUserReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyUserReportInputEnvelope
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
  }

  export type BaseRoyaltyReportCreateNestedOneWithoutUserReportsInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutUserReportsInput, BaseRoyaltyReportUncheckedCreateWithoutUserReportsInput>
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutUserReportsInput
    connect?: BaseRoyaltyReportWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutUserRoyaltyReportInput = {
    create?: XOR<ClientCreateWithoutUserRoyaltyReportInput, ClientUncheckedCreateWithoutUserRoyaltyReportInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserRoyaltyReportInput
    connect?: ClientWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutUserReportInput = {
    create?: XOR<TransactionCreateWithoutUserReportInput, TransactionUncheckedCreateWithoutUserReportInput> | TransactionCreateWithoutUserReportInput[] | TransactionUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserReportInput | TransactionCreateOrConnectWithoutUserReportInput[]
    createMany?: TransactionCreateManyUserReportInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type KontorRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutUserReportInput, KontorRoyaltyReportUncheckedCreateWithoutUserReportInput> | KontorRoyaltyReportCreateWithoutUserReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutUserReportInput | KontorRoyaltyReportCreateOrConnectWithoutUserReportInput[]
    createMany?: KontorRoyaltyReportCreateManyUserReportInputEnvelope
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
  }

  export type BelieveRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutUserReportInput, BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput> | BelieveRoyaltyReportCreateWithoutUserReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutUserReportInput | BelieveRoyaltyReportCreateOrConnectWithoutUserReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyUserReportInputEnvelope
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserReportInput = {
    create?: XOR<TransactionCreateWithoutUserReportInput, TransactionUncheckedCreateWithoutUserReportInput> | TransactionCreateWithoutUserReportInput[] | TransactionUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserReportInput | TransactionCreateOrConnectWithoutUserReportInput[]
    createMany?: TransactionCreateManyUserReportInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type S3FileUpdateOneWithoutUserRoyaltyReportNestedInput = {
    create?: XOR<S3FileCreateWithoutUserRoyaltyReportInput, S3FileUncheckedCreateWithoutUserRoyaltyReportInput>
    connectOrCreate?: S3FileCreateOrConnectWithoutUserRoyaltyReportInput
    upsert?: S3FileUpsertWithoutUserRoyaltyReportInput
    disconnect?: S3FileWhereInput | boolean
    delete?: S3FileWhereInput | boolean
    connect?: S3FileWhereUniqueInput
    update?: XOR<XOR<S3FileUpdateToOneWithWhereWithoutUserRoyaltyReportInput, S3FileUpdateWithoutUserRoyaltyReportInput>, S3FileUncheckedUpdateWithoutUserRoyaltyReportInput>
  }

  export type KontorRoyaltyReportUpdateManyWithoutUserReportNestedInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutUserReportInput, KontorRoyaltyReportUncheckedCreateWithoutUserReportInput> | KontorRoyaltyReportCreateWithoutUserReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutUserReportInput | KontorRoyaltyReportCreateOrConnectWithoutUserReportInput[]
    upsert?: KontorRoyaltyReportUpsertWithWhereUniqueWithoutUserReportInput | KontorRoyaltyReportUpsertWithWhereUniqueWithoutUserReportInput[]
    createMany?: KontorRoyaltyReportCreateManyUserReportInputEnvelope
    set?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    disconnect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    delete?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    update?: KontorRoyaltyReportUpdateWithWhereUniqueWithoutUserReportInput | KontorRoyaltyReportUpdateWithWhereUniqueWithoutUserReportInput[]
    updateMany?: KontorRoyaltyReportUpdateManyWithWhereWithoutUserReportInput | KontorRoyaltyReportUpdateManyWithWhereWithoutUserReportInput[]
    deleteMany?: KontorRoyaltyReportScalarWhereInput | KontorRoyaltyReportScalarWhereInput[]
  }

  export type BelieveRoyaltyReportUpdateManyWithoutUserReportNestedInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutUserReportInput, BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput> | BelieveRoyaltyReportCreateWithoutUserReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutUserReportInput | BelieveRoyaltyReportCreateOrConnectWithoutUserReportInput[]
    upsert?: BelieveRoyaltyReportUpsertWithWhereUniqueWithoutUserReportInput | BelieveRoyaltyReportUpsertWithWhereUniqueWithoutUserReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyUserReportInputEnvelope
    set?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    disconnect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    delete?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    update?: BelieveRoyaltyReportUpdateWithWhereUniqueWithoutUserReportInput | BelieveRoyaltyReportUpdateWithWhereUniqueWithoutUserReportInput[]
    updateMany?: BelieveRoyaltyReportUpdateManyWithWhereWithoutUserReportInput | BelieveRoyaltyReportUpdateManyWithWhereWithoutUserReportInput[]
    deleteMany?: BelieveRoyaltyReportScalarWhereInput | BelieveRoyaltyReportScalarWhereInput[]
  }

  export type BaseRoyaltyReportUpdateOneWithoutUserReportsNestedInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutUserReportsInput, BaseRoyaltyReportUncheckedCreateWithoutUserReportsInput>
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutUserReportsInput
    upsert?: BaseRoyaltyReportUpsertWithoutUserReportsInput
    disconnect?: BaseRoyaltyReportWhereInput | boolean
    delete?: BaseRoyaltyReportWhereInput | boolean
    connect?: BaseRoyaltyReportWhereUniqueInput
    update?: XOR<XOR<BaseRoyaltyReportUpdateToOneWithWhereWithoutUserReportsInput, BaseRoyaltyReportUpdateWithoutUserReportsInput>, BaseRoyaltyReportUncheckedUpdateWithoutUserReportsInput>
  }

  export type ClientUpdateOneWithoutUserRoyaltyReportNestedInput = {
    create?: XOR<ClientCreateWithoutUserRoyaltyReportInput, ClientUncheckedCreateWithoutUserRoyaltyReportInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUserRoyaltyReportInput
    upsert?: ClientUpsertWithoutUserRoyaltyReportInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUserRoyaltyReportInput, ClientUpdateWithoutUserRoyaltyReportInput>, ClientUncheckedUpdateWithoutUserRoyaltyReportInput>
  }

  export type TransactionUpdateManyWithoutUserReportNestedInput = {
    create?: XOR<TransactionCreateWithoutUserReportInput, TransactionUncheckedCreateWithoutUserReportInput> | TransactionCreateWithoutUserReportInput[] | TransactionUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserReportInput | TransactionCreateOrConnectWithoutUserReportInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserReportInput | TransactionUpsertWithWhereUniqueWithoutUserReportInput[]
    createMany?: TransactionCreateManyUserReportInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserReportInput | TransactionUpdateWithWhereUniqueWithoutUserReportInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserReportInput | TransactionUpdateManyWithWhereWithoutUserReportInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type KontorRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput = {
    create?: XOR<KontorRoyaltyReportCreateWithoutUserReportInput, KontorRoyaltyReportUncheckedCreateWithoutUserReportInput> | KontorRoyaltyReportCreateWithoutUserReportInput[] | KontorRoyaltyReportUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: KontorRoyaltyReportCreateOrConnectWithoutUserReportInput | KontorRoyaltyReportCreateOrConnectWithoutUserReportInput[]
    upsert?: KontorRoyaltyReportUpsertWithWhereUniqueWithoutUserReportInput | KontorRoyaltyReportUpsertWithWhereUniqueWithoutUserReportInput[]
    createMany?: KontorRoyaltyReportCreateManyUserReportInputEnvelope
    set?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    disconnect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    delete?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    connect?: KontorRoyaltyReportWhereUniqueInput | KontorRoyaltyReportWhereUniqueInput[]
    update?: KontorRoyaltyReportUpdateWithWhereUniqueWithoutUserReportInput | KontorRoyaltyReportUpdateWithWhereUniqueWithoutUserReportInput[]
    updateMany?: KontorRoyaltyReportUpdateManyWithWhereWithoutUserReportInput | KontorRoyaltyReportUpdateManyWithWhereWithoutUserReportInput[]
    deleteMany?: KontorRoyaltyReportScalarWhereInput | KontorRoyaltyReportScalarWhereInput[]
  }

  export type BelieveRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput = {
    create?: XOR<BelieveRoyaltyReportCreateWithoutUserReportInput, BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput> | BelieveRoyaltyReportCreateWithoutUserReportInput[] | BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: BelieveRoyaltyReportCreateOrConnectWithoutUserReportInput | BelieveRoyaltyReportCreateOrConnectWithoutUserReportInput[]
    upsert?: BelieveRoyaltyReportUpsertWithWhereUniqueWithoutUserReportInput | BelieveRoyaltyReportUpsertWithWhereUniqueWithoutUserReportInput[]
    createMany?: BelieveRoyaltyReportCreateManyUserReportInputEnvelope
    set?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    disconnect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    delete?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    connect?: BelieveRoyaltyReportWhereUniqueInput | BelieveRoyaltyReportWhereUniqueInput[]
    update?: BelieveRoyaltyReportUpdateWithWhereUniqueWithoutUserReportInput | BelieveRoyaltyReportUpdateWithWhereUniqueWithoutUserReportInput[]
    updateMany?: BelieveRoyaltyReportUpdateManyWithWhereWithoutUserReportInput | BelieveRoyaltyReportUpdateManyWithWhereWithoutUserReportInput[]
    deleteMany?: BelieveRoyaltyReportScalarWhereInput | BelieveRoyaltyReportScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserReportNestedInput = {
    create?: XOR<TransactionCreateWithoutUserReportInput, TransactionUncheckedCreateWithoutUserReportInput> | TransactionCreateWithoutUserReportInput[] | TransactionUncheckedCreateWithoutUserReportInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserReportInput | TransactionCreateOrConnectWithoutUserReportInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserReportInput | TransactionUpsertWithWhereUniqueWithoutUserReportInput[]
    createMany?: TransactionCreateManyUserReportInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserReportInput | TransactionUpdateWithWhereUniqueWithoutUserReportInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserReportInput | TransactionUpdateManyWithWhereWithoutUserReportInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type LabelCreateNestedOneWithoutKontorRoyaltyReportInput = {
    create?: XOR<LabelCreateWithoutKontorRoyaltyReportInput, LabelUncheckedCreateWithoutKontorRoyaltyReportInput>
    connectOrCreate?: LabelCreateOrConnectWithoutKontorRoyaltyReportInput
    connect?: LabelWhereUniqueInput
  }

  export type BaseRoyaltyReportCreateNestedOneWithoutKontorReportsInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutKontorReportsInput, BaseRoyaltyReportUncheckedCreateWithoutKontorReportsInput>
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutKontorReportsInput
    connect?: BaseRoyaltyReportWhereUniqueInput
  }

  export type UserRoyaltyReportCreateNestedOneWithoutKontorReportsInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutKontorReportsInput, UserRoyaltyReportUncheckedCreateWithoutKontorReportsInput>
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutKontorReportsInput
    connect?: UserRoyaltyReportWhereUniqueInput
  }

  export type ImportedRoyaltyReportCreateNestedOneWithoutKontorRoyaltyReportInput = {
    create?: XOR<ImportedRoyaltyReportCreateWithoutKontorRoyaltyReportInput, ImportedRoyaltyReportUncheckedCreateWithoutKontorRoyaltyReportInput>
    connectOrCreate?: ImportedRoyaltyReportCreateOrConnectWithoutKontorRoyaltyReportInput
    connect?: ImportedRoyaltyReportWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type LabelUpdateOneWithoutKontorRoyaltyReportNestedInput = {
    create?: XOR<LabelCreateWithoutKontorRoyaltyReportInput, LabelUncheckedCreateWithoutKontorRoyaltyReportInput>
    connectOrCreate?: LabelCreateOrConnectWithoutKontorRoyaltyReportInput
    upsert?: LabelUpsertWithoutKontorRoyaltyReportInput
    disconnect?: LabelWhereInput | boolean
    delete?: LabelWhereInput | boolean
    connect?: LabelWhereUniqueInput
    update?: XOR<XOR<LabelUpdateToOneWithWhereWithoutKontorRoyaltyReportInput, LabelUpdateWithoutKontorRoyaltyReportInput>, LabelUncheckedUpdateWithoutKontorRoyaltyReportInput>
  }

  export type BaseRoyaltyReportUpdateOneWithoutKontorReportsNestedInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutKontorReportsInput, BaseRoyaltyReportUncheckedCreateWithoutKontorReportsInput>
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutKontorReportsInput
    upsert?: BaseRoyaltyReportUpsertWithoutKontorReportsInput
    disconnect?: BaseRoyaltyReportWhereInput | boolean
    delete?: BaseRoyaltyReportWhereInput | boolean
    connect?: BaseRoyaltyReportWhereUniqueInput
    update?: XOR<XOR<BaseRoyaltyReportUpdateToOneWithWhereWithoutKontorReportsInput, BaseRoyaltyReportUpdateWithoutKontorReportsInput>, BaseRoyaltyReportUncheckedUpdateWithoutKontorReportsInput>
  }

  export type UserRoyaltyReportUpdateOneWithoutKontorReportsNestedInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutKontorReportsInput, UserRoyaltyReportUncheckedCreateWithoutKontorReportsInput>
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutKontorReportsInput
    upsert?: UserRoyaltyReportUpsertWithoutKontorReportsInput
    disconnect?: UserRoyaltyReportWhereInput | boolean
    delete?: UserRoyaltyReportWhereInput | boolean
    connect?: UserRoyaltyReportWhereUniqueInput
    update?: XOR<XOR<UserRoyaltyReportUpdateToOneWithWhereWithoutKontorReportsInput, UserRoyaltyReportUpdateWithoutKontorReportsInput>, UserRoyaltyReportUncheckedUpdateWithoutKontorReportsInput>
  }

  export type ImportedRoyaltyReportUpdateOneWithoutKontorRoyaltyReportNestedInput = {
    create?: XOR<ImportedRoyaltyReportCreateWithoutKontorRoyaltyReportInput, ImportedRoyaltyReportUncheckedCreateWithoutKontorRoyaltyReportInput>
    connectOrCreate?: ImportedRoyaltyReportCreateOrConnectWithoutKontorRoyaltyReportInput
    upsert?: ImportedRoyaltyReportUpsertWithoutKontorRoyaltyReportInput
    disconnect?: ImportedRoyaltyReportWhereInput | boolean
    delete?: ImportedRoyaltyReportWhereInput | boolean
    connect?: ImportedRoyaltyReportWhereUniqueInput
    update?: XOR<XOR<ImportedRoyaltyReportUpdateToOneWithWhereWithoutKontorRoyaltyReportInput, ImportedRoyaltyReportUpdateWithoutKontorRoyaltyReportInput>, ImportedRoyaltyReportUncheckedUpdateWithoutKontorRoyaltyReportInput>
  }

  export type LabelCreateNestedOneWithoutBelieveRoyaltyReportInput = {
    create?: XOR<LabelCreateWithoutBelieveRoyaltyReportInput, LabelUncheckedCreateWithoutBelieveRoyaltyReportInput>
    connectOrCreate?: LabelCreateOrConnectWithoutBelieveRoyaltyReportInput
    connect?: LabelWhereUniqueInput
  }

  export type BaseRoyaltyReportCreateNestedOneWithoutBelieveReportsInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutBelieveReportsInput, BaseRoyaltyReportUncheckedCreateWithoutBelieveReportsInput>
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutBelieveReportsInput
    connect?: BaseRoyaltyReportWhereUniqueInput
  }

  export type UserRoyaltyReportCreateNestedOneWithoutBelieveReportsInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutBelieveReportsInput, UserRoyaltyReportUncheckedCreateWithoutBelieveReportsInput>
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutBelieveReportsInput
    connect?: UserRoyaltyReportWhereUniqueInput
  }

  export type ImportedRoyaltyReportCreateNestedOneWithoutBelieveRoyaltyReportInput = {
    create?: XOR<ImportedRoyaltyReportCreateWithoutBelieveRoyaltyReportInput, ImportedRoyaltyReportUncheckedCreateWithoutBelieveRoyaltyReportInput>
    connectOrCreate?: ImportedRoyaltyReportCreateOrConnectWithoutBelieveRoyaltyReportInput
    connect?: ImportedRoyaltyReportWhereUniqueInput
  }

  export type LabelUpdateOneWithoutBelieveRoyaltyReportNestedInput = {
    create?: XOR<LabelCreateWithoutBelieveRoyaltyReportInput, LabelUncheckedCreateWithoutBelieveRoyaltyReportInput>
    connectOrCreate?: LabelCreateOrConnectWithoutBelieveRoyaltyReportInput
    upsert?: LabelUpsertWithoutBelieveRoyaltyReportInput
    disconnect?: LabelWhereInput | boolean
    delete?: LabelWhereInput | boolean
    connect?: LabelWhereUniqueInput
    update?: XOR<XOR<LabelUpdateToOneWithWhereWithoutBelieveRoyaltyReportInput, LabelUpdateWithoutBelieveRoyaltyReportInput>, LabelUncheckedUpdateWithoutBelieveRoyaltyReportInput>
  }

  export type BaseRoyaltyReportUpdateOneWithoutBelieveReportsNestedInput = {
    create?: XOR<BaseRoyaltyReportCreateWithoutBelieveReportsInput, BaseRoyaltyReportUncheckedCreateWithoutBelieveReportsInput>
    connectOrCreate?: BaseRoyaltyReportCreateOrConnectWithoutBelieveReportsInput
    upsert?: BaseRoyaltyReportUpsertWithoutBelieveReportsInput
    disconnect?: BaseRoyaltyReportWhereInput | boolean
    delete?: BaseRoyaltyReportWhereInput | boolean
    connect?: BaseRoyaltyReportWhereUniqueInput
    update?: XOR<XOR<BaseRoyaltyReportUpdateToOneWithWhereWithoutBelieveReportsInput, BaseRoyaltyReportUpdateWithoutBelieveReportsInput>, BaseRoyaltyReportUncheckedUpdateWithoutBelieveReportsInput>
  }

  export type UserRoyaltyReportUpdateOneWithoutBelieveReportsNestedInput = {
    create?: XOR<UserRoyaltyReportCreateWithoutBelieveReportsInput, UserRoyaltyReportUncheckedCreateWithoutBelieveReportsInput>
    connectOrCreate?: UserRoyaltyReportCreateOrConnectWithoutBelieveReportsInput
    upsert?: UserRoyaltyReportUpsertWithoutBelieveReportsInput
    disconnect?: UserRoyaltyReportWhereInput | boolean
    delete?: UserRoyaltyReportWhereInput | boolean
    connect?: UserRoyaltyReportWhereUniqueInput
    update?: XOR<XOR<UserRoyaltyReportUpdateToOneWithWhereWithoutBelieveReportsInput, UserRoyaltyReportUpdateWithoutBelieveReportsInput>, UserRoyaltyReportUncheckedUpdateWithoutBelieveReportsInput>
  }

  export type ImportedRoyaltyReportUpdateOneWithoutBelieveRoyaltyReportNestedInput = {
    create?: XOR<ImportedRoyaltyReportCreateWithoutBelieveRoyaltyReportInput, ImportedRoyaltyReportUncheckedCreateWithoutBelieveRoyaltyReportInput>
    connectOrCreate?: ImportedRoyaltyReportCreateOrConnectWithoutBelieveRoyaltyReportInput
    upsert?: ImportedRoyaltyReportUpsertWithoutBelieveRoyaltyReportInput
    disconnect?: ImportedRoyaltyReportWhereInput | boolean
    delete?: ImportedRoyaltyReportWhereInput | boolean
    connect?: ImportedRoyaltyReportWhereUniqueInput
    update?: XOR<XOR<ImportedRoyaltyReportUpdateToOneWithWhereWithoutBelieveRoyaltyReportInput, ImportedRoyaltyReportUpdateWithoutBelieveRoyaltyReportInput>, ImportedRoyaltyReportUncheckedUpdateWithoutBelieveRoyaltyReportInput>
  }

  export type UnlinkedReportDetailCreateNestedManyWithoutUnlinkedReportInput = {
    create?: XOR<UnlinkedReportDetailCreateWithoutUnlinkedReportInput, UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput> | UnlinkedReportDetailCreateWithoutUnlinkedReportInput[] | UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput[]
    connectOrCreate?: UnlinkedReportDetailCreateOrConnectWithoutUnlinkedReportInput | UnlinkedReportDetailCreateOrConnectWithoutUnlinkedReportInput[]
    createMany?: UnlinkedReportDetailCreateManyUnlinkedReportInputEnvelope
    connect?: UnlinkedReportDetailWhereUniqueInput | UnlinkedReportDetailWhereUniqueInput[]
  }

  export type UnlinkedReportDetailUncheckedCreateNestedManyWithoutUnlinkedReportInput = {
    create?: XOR<UnlinkedReportDetailCreateWithoutUnlinkedReportInput, UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput> | UnlinkedReportDetailCreateWithoutUnlinkedReportInput[] | UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput[]
    connectOrCreate?: UnlinkedReportDetailCreateOrConnectWithoutUnlinkedReportInput | UnlinkedReportDetailCreateOrConnectWithoutUnlinkedReportInput[]
    createMany?: UnlinkedReportDetailCreateManyUnlinkedReportInputEnvelope
    connect?: UnlinkedReportDetailWhereUniqueInput | UnlinkedReportDetailWhereUniqueInput[]
  }

  export type UnlinkedReportDetailUpdateManyWithoutUnlinkedReportNestedInput = {
    create?: XOR<UnlinkedReportDetailCreateWithoutUnlinkedReportInput, UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput> | UnlinkedReportDetailCreateWithoutUnlinkedReportInput[] | UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput[]
    connectOrCreate?: UnlinkedReportDetailCreateOrConnectWithoutUnlinkedReportInput | UnlinkedReportDetailCreateOrConnectWithoutUnlinkedReportInput[]
    upsert?: UnlinkedReportDetailUpsertWithWhereUniqueWithoutUnlinkedReportInput | UnlinkedReportDetailUpsertWithWhereUniqueWithoutUnlinkedReportInput[]
    createMany?: UnlinkedReportDetailCreateManyUnlinkedReportInputEnvelope
    set?: UnlinkedReportDetailWhereUniqueInput | UnlinkedReportDetailWhereUniqueInput[]
    disconnect?: UnlinkedReportDetailWhereUniqueInput | UnlinkedReportDetailWhereUniqueInput[]
    delete?: UnlinkedReportDetailWhereUniqueInput | UnlinkedReportDetailWhereUniqueInput[]
    connect?: UnlinkedReportDetailWhereUniqueInput | UnlinkedReportDetailWhereUniqueInput[]
    update?: UnlinkedReportDetailUpdateWithWhereUniqueWithoutUnlinkedReportInput | UnlinkedReportDetailUpdateWithWhereUniqueWithoutUnlinkedReportInput[]
    updateMany?: UnlinkedReportDetailUpdateManyWithWhereWithoutUnlinkedReportInput | UnlinkedReportDetailUpdateManyWithWhereWithoutUnlinkedReportInput[]
    deleteMany?: UnlinkedReportDetailScalarWhereInput | UnlinkedReportDetailScalarWhereInput[]
  }

  export type UnlinkedReportDetailUncheckedUpdateManyWithoutUnlinkedReportNestedInput = {
    create?: XOR<UnlinkedReportDetailCreateWithoutUnlinkedReportInput, UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput> | UnlinkedReportDetailCreateWithoutUnlinkedReportInput[] | UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput[]
    connectOrCreate?: UnlinkedReportDetailCreateOrConnectWithoutUnlinkedReportInput | UnlinkedReportDetailCreateOrConnectWithoutUnlinkedReportInput[]
    upsert?: UnlinkedReportDetailUpsertWithWhereUniqueWithoutUnlinkedReportInput | UnlinkedReportDetailUpsertWithWhereUniqueWithoutUnlinkedReportInput[]
    createMany?: UnlinkedReportDetailCreateManyUnlinkedReportInputEnvelope
    set?: UnlinkedReportDetailWhereUniqueInput | UnlinkedReportDetailWhereUniqueInput[]
    disconnect?: UnlinkedReportDetailWhereUniqueInput | UnlinkedReportDetailWhereUniqueInput[]
    delete?: UnlinkedReportDetailWhereUniqueInput | UnlinkedReportDetailWhereUniqueInput[]
    connect?: UnlinkedReportDetailWhereUniqueInput | UnlinkedReportDetailWhereUniqueInput[]
    update?: UnlinkedReportDetailUpdateWithWhereUniqueWithoutUnlinkedReportInput | UnlinkedReportDetailUpdateWithWhereUniqueWithoutUnlinkedReportInput[]
    updateMany?: UnlinkedReportDetailUpdateManyWithWhereWithoutUnlinkedReportInput | UnlinkedReportDetailUpdateManyWithWhereWithoutUnlinkedReportInput[]
    deleteMany?: UnlinkedReportDetailScalarWhereInput | UnlinkedReportDetailScalarWhereInput[]
  }

  export type UnlinkedReportCreateNestedOneWithoutUnlinkedReportDetailInput = {
    create?: XOR<UnlinkedReportCreateWithoutUnlinkedReportDetailInput, UnlinkedReportUncheckedCreateWithoutUnlinkedReportDetailInput>
    connectOrCreate?: UnlinkedReportCreateOrConnectWithoutUnlinkedReportDetailInput
    connect?: UnlinkedReportWhereUniqueInput
  }

  export type UnlinkedReportUpdateOneRequiredWithoutUnlinkedReportDetailNestedInput = {
    create?: XOR<UnlinkedReportCreateWithoutUnlinkedReportDetailInput, UnlinkedReportUncheckedCreateWithoutUnlinkedReportDetailInput>
    connectOrCreate?: UnlinkedReportCreateOrConnectWithoutUnlinkedReportDetailInput
    upsert?: UnlinkedReportUpsertWithoutUnlinkedReportDetailInput
    connect?: UnlinkedReportWhereUniqueInput
    update?: XOR<XOR<UnlinkedReportUpdateToOneWithWhereWithoutUnlinkedReportDetailInput, UnlinkedReportUpdateWithoutUnlinkedReportDetailInput>, UnlinkedReportUncheckedUpdateWithoutUnlinkedReportDetailInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumCommsChannelsFilter<$PrismaModel = never> = {
    equals?: $Enums.CommsChannels | EnumCommsChannelsFieldRefInput<$PrismaModel>
    in?: $Enums.CommsChannels[] | ListEnumCommsChannelsFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommsChannels[] | ListEnumCommsChannelsFieldRefInput<$PrismaModel>
    not?: NestedEnumCommsChannelsFilter<$PrismaModel> | $Enums.CommsChannels
  }

  export type NestedEnumCommsChannelsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommsChannels | EnumCommsChannelsFieldRefInput<$PrismaModel>
    in?: $Enums.CommsChannels[] | ListEnumCommsChannelsFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommsChannels[] | ListEnumCommsChannelsFieldRefInput<$PrismaModel>
    not?: NestedEnumCommsChannelsWithAggregatesFilter<$PrismaModel> | $Enums.CommsChannels
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommsChannelsFilter<$PrismaModel>
    _max?: NestedEnumCommsChannelsFilter<$PrismaModel>
  }

  export type NestedEnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type NestedEnumTaxIdTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxIdTypeFilter<$PrismaModel> | $Enums.TaxIdType
  }

  export type NestedEnumClientStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusFilter<$PrismaModel> | $Enums.ClientStatus
  }

  export type NestedEnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaxIdTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaxIdType | EnumTaxIdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaxIdType[] | ListEnumTaxIdTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaxIdTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaxIdType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaxIdTypeFilter<$PrismaModel>
    _max?: NestedEnumTaxIdTypeFilter<$PrismaModel>
  }

  export type NestedEnumClientStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientStatus | EnumClientStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientStatus[] | ListEnumClientStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClientStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClientStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientStatusFilter<$PrismaModel>
    _max?: NestedEnumClientStatusFilter<$PrismaModel>
  }

  export type NestedEnumAccessTypeDMBFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessTypeDMB | EnumAccessTypeDMBFieldRefInput<$PrismaModel>
    in?: $Enums.AccessTypeDMB[] | ListEnumAccessTypeDMBFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessTypeDMB[] | ListEnumAccessTypeDMBFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeDMBFilter<$PrismaModel> | $Enums.AccessTypeDMB
  }

  export type NestedEnumDMBStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DMBStatus | EnumDMBStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DMBStatus[] | ListEnumDMBStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DMBStatus[] | ListEnumDMBStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDMBStatusFilter<$PrismaModel> | $Enums.DMBStatus
  }

  export type NestedEnumAccessTypeDMBWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessTypeDMB | EnumAccessTypeDMBFieldRefInput<$PrismaModel>
    in?: $Enums.AccessTypeDMB[] | ListEnumAccessTypeDMBFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessTypeDMB[] | ListEnumAccessTypeDMBFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeDMBWithAggregatesFilter<$PrismaModel> | $Enums.AccessTypeDMB
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessTypeDMBFilter<$PrismaModel>
    _max?: NestedEnumAccessTypeDMBFilter<$PrismaModel>
  }

  export type NestedEnumDMBStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DMBStatus | EnumDMBStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DMBStatus[] | ListEnumDMBStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DMBStatus[] | ListEnumDMBStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDMBStatusWithAggregatesFilter<$PrismaModel> | $Enums.DMBStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDMBStatusFilter<$PrismaModel>
    _max?: NestedEnumDMBStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedEnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type NestedEnumContractStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusFilter<$PrismaModel> | $Enums.ContractStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumContractStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractStatusFilter<$PrismaModel>
    _max?: NestedEnumContractStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyFilter<$PrismaModel> | $Enums.Currency
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumCurrencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyWithAggregatesFilter<$PrismaModel> | $Enums.Currency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyFilter<$PrismaModel>
    _max?: NestedEnumCurrencyFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumDistributorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Distributor | EnumDistributorFieldRefInput<$PrismaModel> | null
    in?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDistributorNullableFilter<$PrismaModel> | $Enums.Distributor | null
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumDistributorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Distributor | EnumDistributorFieldRefInput<$PrismaModel> | null
    in?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDistributorNullableWithAggregatesFilter<$PrismaModel> | $Enums.Distributor | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDistributorNullableFilter<$PrismaModel>
    _max?: NestedEnumDistributorNullableFilter<$PrismaModel>
  }

  export type NestedEnumLabelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabelStatus | EnumLabelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabelStatus[] | ListEnumLabelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabelStatus[] | ListEnumLabelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelStatusFilter<$PrismaModel> | $Enums.LabelStatus
  }

  export type NestedEnumLabelRegistrationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabelRegistrationStatus | EnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabelRegistrationStatus[] | ListEnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabelRegistrationStatus[] | ListEnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelRegistrationStatusFilter<$PrismaModel> | $Enums.LabelRegistrationStatus
  }

  export type NestedEnumLabelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabelStatus | EnumLabelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabelStatus[] | ListEnumLabelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabelStatus[] | ListEnumLabelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabelStatusFilter<$PrismaModel>
    _max?: NestedEnumLabelStatusFilter<$PrismaModel>
  }

  export type NestedEnumLabelRegistrationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabelRegistrationStatus | EnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabelRegistrationStatus[] | ListEnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabelRegistrationStatus[] | ListEnumLabelRegistrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabelRegistrationStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabelRegistrationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabelRegistrationStatusFilter<$PrismaModel>
    _max?: NestedEnumLabelRegistrationStatusFilter<$PrismaModel>
  }

  export type NestedEnumDistributorFilter<$PrismaModel = never> = {
    equals?: $Enums.Distributor | EnumDistributorFieldRefInput<$PrismaModel>
    in?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel>
    not?: NestedEnumDistributorFilter<$PrismaModel> | $Enums.Distributor
  }

  export type NestedEnumDistributorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Distributor | EnumDistributorFieldRefInput<$PrismaModel>
    in?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Distributor[] | ListEnumDistributorFieldRefInput<$PrismaModel>
    not?: NestedEnumDistributorWithAggregatesFilter<$PrismaModel> | $Enums.Distributor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDistributorFilter<$PrismaModel>
    _max?: NestedEnumDistributorFilter<$PrismaModel>
  }

  export type NestedEnumDebitStateFilter<$PrismaModel = never> = {
    equals?: $Enums.DebitState | EnumDebitStateFieldRefInput<$PrismaModel>
    in?: $Enums.DebitState[] | ListEnumDebitStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebitState[] | ListEnumDebitStateFieldRefInput<$PrismaModel>
    not?: NestedEnumDebitStateFilter<$PrismaModel> | $Enums.DebitState
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDebitStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DebitState | EnumDebitStateFieldRefInput<$PrismaModel>
    in?: $Enums.DebitState[] | ListEnumDebitStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebitState[] | ListEnumDebitStateFieldRefInput<$PrismaModel>
    not?: NestedEnumDebitStateWithAggregatesFilter<$PrismaModel> | $Enums.DebitState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDebitStateFilter<$PrismaModel>
    _max?: NestedEnumDebitStateFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRoyaltyReportCreateWithoutS3FileInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutUserReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutUserReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutUserReportsInput
    client?: ClientCreateNestedOneWithoutUserRoyaltyReportInput
    transactions?: TransactionCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportUncheckedCreateWithoutS3FileInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    baseReportId?: number | null
    clientId?: number | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportCreateOrConnectWithoutS3FileInput = {
    where: UserRoyaltyReportWhereUniqueInput
    create: XOR<UserRoyaltyReportCreateWithoutS3FileInput, UserRoyaltyReportUncheckedCreateWithoutS3FileInput>
  }

  export type UserRoyaltyReportCreateManyS3FileInputEnvelope = {
    data: UserRoyaltyReportCreateManyS3FileInput | UserRoyaltyReportCreateManyS3FileInput[]
    skipDuplicates?: boolean
  }

  export type BaseRoyaltyReportCreateWithoutS3FileInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutBaseReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutBaseReportInput
    userReports?: UserRoyaltyReportCreateNestedManyWithoutBaseReportInput
    Transaction?: TransactionCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportUncheckedCreateWithoutS3FileInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    userReports?: UserRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportCreateOrConnectWithoutS3FileInput = {
    where: BaseRoyaltyReportWhereUniqueInput
    create: XOR<BaseRoyaltyReportCreateWithoutS3FileInput, BaseRoyaltyReportUncheckedCreateWithoutS3FileInput>
  }

  export type BaseRoyaltyReportCreateManyS3FileInputEnvelope = {
    data: BaseRoyaltyReportCreateManyS3FileInput | BaseRoyaltyReportCreateManyS3FileInput[]
    skipDuplicates?: boolean
  }

  export type ImportedRoyaltyReportCreateWithoutS3FileInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
    KontorRoyaltyReport?: KontorRoyaltyReportCreateNestedManyWithoutImportedReportInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportCreateNestedManyWithoutImportedReportInput
  }

  export type ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutImportedReportInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutImportedReportInput
  }

  export type ImportedRoyaltyReportCreateOrConnectWithoutS3FileInput = {
    where: ImportedRoyaltyReportWhereUniqueInput
    create: XOR<ImportedRoyaltyReportCreateWithoutS3FileInput, ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput>
  }

  export type ImportedRoyaltyReportCreateManyS3FileInputEnvelope = {
    data: ImportedRoyaltyReportCreateManyS3FileInput | ImportedRoyaltyReportCreateManyS3FileInput[]
    skipDuplicates?: boolean
  }

  export type UserRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput = {
    where: UserRoyaltyReportWhereUniqueInput
    update: XOR<UserRoyaltyReportUpdateWithoutS3FileInput, UserRoyaltyReportUncheckedUpdateWithoutS3FileInput>
    create: XOR<UserRoyaltyReportCreateWithoutS3FileInput, UserRoyaltyReportUncheckedCreateWithoutS3FileInput>
  }

  export type UserRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput = {
    where: UserRoyaltyReportWhereUniqueInput
    data: XOR<UserRoyaltyReportUpdateWithoutS3FileInput, UserRoyaltyReportUncheckedUpdateWithoutS3FileInput>
  }

  export type UserRoyaltyReportUpdateManyWithWhereWithoutS3FileInput = {
    where: UserRoyaltyReportScalarWhereInput
    data: XOR<UserRoyaltyReportUpdateManyMutationInput, UserRoyaltyReportUncheckedUpdateManyWithoutS3FileInput>
  }

  export type UserRoyaltyReportScalarWhereInput = {
    AND?: UserRoyaltyReportScalarWhereInput | UserRoyaltyReportScalarWhereInput[]
    OR?: UserRoyaltyReportScalarWhereInput[]
    NOT?: UserRoyaltyReportScalarWhereInput | UserRoyaltyReportScalarWhereInput[]
    id?: IntFilter<"UserRoyaltyReport"> | number
    createdAt?: DateTimeFilter<"UserRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"UserRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"UserRoyaltyReport"> | $Enums.Currency
    distributor?: EnumDistributorFilter<"UserRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"UserRoyaltyReport"> | string
    totalRoyalties?: FloatFilter<"UserRoyaltyReport"> | number
    debitState?: EnumDebitStateFilter<"UserRoyaltyReport"> | $Enums.DebitState
    paidOn?: DateTimeNullableFilter<"UserRoyaltyReport"> | Date | string | null
    s3FileId?: IntNullableFilter<"UserRoyaltyReport"> | number | null
    baseReportId?: IntNullableFilter<"UserRoyaltyReport"> | number | null
    clientId?: IntNullableFilter<"UserRoyaltyReport"> | number | null
  }

  export type BaseRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput = {
    where: BaseRoyaltyReportWhereUniqueInput
    update: XOR<BaseRoyaltyReportUpdateWithoutS3FileInput, BaseRoyaltyReportUncheckedUpdateWithoutS3FileInput>
    create: XOR<BaseRoyaltyReportCreateWithoutS3FileInput, BaseRoyaltyReportUncheckedCreateWithoutS3FileInput>
  }

  export type BaseRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput = {
    where: BaseRoyaltyReportWhereUniqueInput
    data: XOR<BaseRoyaltyReportUpdateWithoutS3FileInput, BaseRoyaltyReportUncheckedUpdateWithoutS3FileInput>
  }

  export type BaseRoyaltyReportUpdateManyWithWhereWithoutS3FileInput = {
    where: BaseRoyaltyReportScalarWhereInput
    data: XOR<BaseRoyaltyReportUpdateManyMutationInput, BaseRoyaltyReportUncheckedUpdateManyWithoutS3FileInput>
  }

  export type BaseRoyaltyReportScalarWhereInput = {
    AND?: BaseRoyaltyReportScalarWhereInput | BaseRoyaltyReportScalarWhereInput[]
    OR?: BaseRoyaltyReportScalarWhereInput[]
    NOT?: BaseRoyaltyReportScalarWhereInput | BaseRoyaltyReportScalarWhereInput[]
    id?: IntFilter<"BaseRoyaltyReport"> | number
    createdAt?: DateTimeFilter<"BaseRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"BaseRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"BaseRoyaltyReport"> | $Enums.Currency
    distributor?: EnumDistributorFilter<"BaseRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"BaseRoyaltyReport"> | string
    totalRoyalties?: FloatFilter<"BaseRoyaltyReport"> | number
    totalEarnings?: FloatFilter<"BaseRoyaltyReport"> | number
    debitState?: EnumDebitStateFilter<"BaseRoyaltyReport"> | $Enums.DebitState
    paidOn?: DateTimeNullableFilter<"BaseRoyaltyReport"> | Date | string | null
    s3FileId?: IntNullableFilter<"BaseRoyaltyReport"> | number | null
  }

  export type ImportedRoyaltyReportUpsertWithWhereUniqueWithoutS3FileInput = {
    where: ImportedRoyaltyReportWhereUniqueInput
    update: XOR<ImportedRoyaltyReportUpdateWithoutS3FileInput, ImportedRoyaltyReportUncheckedUpdateWithoutS3FileInput>
    create: XOR<ImportedRoyaltyReportCreateWithoutS3FileInput, ImportedRoyaltyReportUncheckedCreateWithoutS3FileInput>
  }

  export type ImportedRoyaltyReportUpdateWithWhereUniqueWithoutS3FileInput = {
    where: ImportedRoyaltyReportWhereUniqueInput
    data: XOR<ImportedRoyaltyReportUpdateWithoutS3FileInput, ImportedRoyaltyReportUncheckedUpdateWithoutS3FileInput>
  }

  export type ImportedRoyaltyReportUpdateManyWithWhereWithoutS3FileInput = {
    where: ImportedRoyaltyReportScalarWhereInput
    data: XOR<ImportedRoyaltyReportUpdateManyMutationInput, ImportedRoyaltyReportUncheckedUpdateManyWithoutS3FileInput>
  }

  export type ImportedRoyaltyReportScalarWhereInput = {
    AND?: ImportedRoyaltyReportScalarWhereInput | ImportedRoyaltyReportScalarWhereInput[]
    OR?: ImportedRoyaltyReportScalarWhereInput[]
    NOT?: ImportedRoyaltyReportScalarWhereInput | ImportedRoyaltyReportScalarWhereInput[]
    id?: IntFilter<"ImportedRoyaltyReport"> | number
    createdAt?: DateTimeFilter<"ImportedRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"ImportedRoyaltyReport"> | Date | string
    distributor?: EnumDistributorFilter<"ImportedRoyaltyReport"> | $Enums.Distributor
    reportingMonth?: StringFilter<"ImportedRoyaltyReport"> | string
    importStatus?: StringFilter<"ImportedRoyaltyReport"> | string
    s3FileId?: IntNullableFilter<"ImportedRoyaltyReport"> | number | null
  }

  export type UserCreateWithoutLogsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    preferences?: UserPreferencesCreateNestedManyWithoutUserInput
    comms?: UserCommsCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUsersInput
    resetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    clientId?: number | null
    preferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput
    comms?: UserCommsUncheckedCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: UserPreferencesUpdateManyWithoutUserNestedInput
    comms?: UserCommsUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUsersNestedInput
    resetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    preferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput
    comms?: UserCommsUncheckedUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserPreferencesCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    fontSize?: string | null
    mainMenuCollapsed?: boolean | null
    theme?: string | null
    language?: string | null
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fontSize?: string | null
    mainMenuCollapsed?: boolean | null
    theme?: string | null
    language?: string | null
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserPreferencesCreateManyUserInputEnvelope = {
    data: UserPreferencesCreateManyUserInput | UserPreferencesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCommsCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.CommsChannels
    value: string
  }

  export type UserCommsUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.CommsChannels
    value: string
  }

  export type UserCommsCreateOrConnectWithoutUserInput = {
    where: UserCommsWhereUniqueInput
    create: XOR<UserCommsCreateWithoutUserInput, UserCommsUncheckedCreateWithoutUserInput>
  }

  export type UserCommsCreateManyUserInputEnvelope = {
    data: UserCommsCreateManyUserInput | UserCommsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutUsersInput = {
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address: AddressCreateNestedOneWithoutClientInput
    dmb?: ClientDMBCreateNestedOneWithoutClientInput
    balances?: BalanceCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationCreateNestedOneWithoutClientInput
    labels?: LabelCreateNestedManyWithoutClientInput
    contract?: ContractCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUsersInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    addressId: number
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    dmb?: ClientDMBUncheckedCreateNestedOneWithoutClientInput
    balances?: BalanceUncheckedCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationUncheckedCreateNestedOneWithoutClientInput
    labels?: LabelUncheckedCreateNestedManyWithoutClientInput
    contract?: ContractUncheckedCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUsersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
  }

  export type LogCreateWithoutUserInput = {
    createdAt?: Date | string
    object: string
    objectId?: number | null
    message: string
    script?: string | null
    ip?: string | null
  }

  export type LogUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    object: string
    objectId?: number | null
    message: string
    script?: string | null
    ip?: string | null
  }

  export type LogCreateOrConnectWithoutUserInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogCreateManyUserInputEnvelope = {
    data: LogCreateManyUserInput | LogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRevoked?: boolean
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRevoked?: boolean
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferencesUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateManyWithWhereWithoutUserInput = {
    where: UserPreferencesScalarWhereInput
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPreferencesScalarWhereInput = {
    AND?: UserPreferencesScalarWhereInput | UserPreferencesScalarWhereInput[]
    OR?: UserPreferencesScalarWhereInput[]
    NOT?: UserPreferencesScalarWhereInput | UserPreferencesScalarWhereInput[]
    id?: IntFilter<"UserPreferences"> | number
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    userId?: IntNullableFilter<"UserPreferences"> | number | null
    fontSize?: StringNullableFilter<"UserPreferences"> | string | null
    mainMenuCollapsed?: BoolNullableFilter<"UserPreferences"> | boolean | null
    theme?: StringNullableFilter<"UserPreferences"> | string | null
    language?: StringNullableFilter<"UserPreferences"> | string | null
  }

  export type UserCommsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCommsWhereUniqueInput
    update: XOR<UserCommsUpdateWithoutUserInput, UserCommsUncheckedUpdateWithoutUserInput>
    create: XOR<UserCommsCreateWithoutUserInput, UserCommsUncheckedCreateWithoutUserInput>
  }

  export type UserCommsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCommsWhereUniqueInput
    data: XOR<UserCommsUpdateWithoutUserInput, UserCommsUncheckedUpdateWithoutUserInput>
  }

  export type UserCommsUpdateManyWithWhereWithoutUserInput = {
    where: UserCommsScalarWhereInput
    data: XOR<UserCommsUpdateManyMutationInput, UserCommsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCommsScalarWhereInput = {
    AND?: UserCommsScalarWhereInput | UserCommsScalarWhereInput[]
    OR?: UserCommsScalarWhereInput[]
    NOT?: UserCommsScalarWhereInput | UserCommsScalarWhereInput[]
    id?: IntFilter<"UserComms"> | number
    createdAt?: DateTimeFilter<"UserComms"> | Date | string
    updatedAt?: DateTimeFilter<"UserComms"> | Date | string
    userId?: IntFilter<"UserComms"> | number
    type?: EnumCommsChannelsFilter<"UserComms"> | $Enums.CommsChannels
    value?: StringFilter<"UserComms"> | string
  }

  export type ClientUpsertWithoutUsersInput = {
    update: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUsersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type ClientUpdateWithoutUsersInput = {
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneRequiredWithoutClientNestedInput
    dmb?: ClientDMBUpdateOneWithoutClientNestedInput
    balances?: BalanceUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUpdateOneWithoutClientNestedInput
    labels?: LabelUpdateManyWithoutClientNestedInput
    contract?: ContractUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    addressId?: IntFieldUpdateOperationsInput | number
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    dmb?: ClientDMBUncheckedUpdateOneWithoutClientNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUncheckedUpdateOneWithoutClientNestedInput
    labels?: LabelUncheckedUpdateManyWithoutClientNestedInput
    contract?: ContractUncheckedUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LogUpsertWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogUpdateWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
  }

  export type LogUpdateManyWithWhereWithoutUserInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutUserInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: IntFilter<"Log"> | number
    createdAt?: DateTimeFilter<"Log"> | Date | string
    userId?: IntFilter<"Log"> | number
    object?: StringFilter<"Log"> | string
    objectId?: IntNullableFilter<"Log"> | number | null
    message?: StringFilter<"Log"> | string
    script?: StringNullableFilter<"Log"> | string | null
    ip?: StringNullableFilter<"Log"> | string | null
  }

  export type PasswordResetTokenUpsertWithoutUserInput = {
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
    where?: PasswordResetTokenWhereInput
  }

  export type PasswordResetTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: PasswordResetTokenWhereInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: IntFilter<"RefreshToken"> | number
    token?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
  }

  export type UserCreateWithoutResetTokenInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    preferences?: UserPreferencesCreateNestedManyWithoutUserInput
    comms?: UserCommsCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResetTokenInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    clientId?: number | null
    preferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput
    comms?: UserCommsUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResetTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResetTokenInput, UserUncheckedCreateWithoutResetTokenInput>
  }

  export type UserUpsertWithoutResetTokenInput = {
    update: XOR<UserUpdateWithoutResetTokenInput, UserUncheckedUpdateWithoutResetTokenInput>
    create: XOR<UserCreateWithoutResetTokenInput, UserUncheckedCreateWithoutResetTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResetTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResetTokenInput, UserUncheckedUpdateWithoutResetTokenInput>
  }

  export type UserUpdateWithoutResetTokenInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: UserPreferencesUpdateManyWithoutUserNestedInput
    comms?: UserCommsUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResetTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    preferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput
    comms?: UserCommsUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPreferencesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    comms?: UserCommsCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    clientId?: number | null
    comms?: UserCommsUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    comms?: UserCommsUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    comms?: UserCommsUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCommsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    preferences?: UserPreferencesCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    clientId?: number | null
    preferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommsInput, UserUncheckedCreateWithoutCommsInput>
  }

  export type UserUpsertWithoutCommsInput = {
    update: XOR<UserUpdateWithoutCommsInput, UserUncheckedUpdateWithoutCommsInput>
    create: XOR<UserCreateWithoutCommsInput, UserUncheckedCreateWithoutCommsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommsInput, UserUncheckedUpdateWithoutCommsInput>
  }

  export type UserUpdateWithoutCommsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: UserPreferencesUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    preferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AddressCreateWithoutClientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    street: string
    street2?: string | null
    city: string
    state: string
    zip: string
    country: CountryCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutClientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    street: string
    street2?: string | null
    city: string
    state: string
    countryId: number
    zip: string
  }

  export type AddressCreateOrConnectWithoutClientInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutClientInput, AddressUncheckedCreateWithoutClientInput>
  }

  export type ClientDMBCreateWithoutClientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    accessType?: $Enums.AccessTypeDMB
    status?: $Enums.DMBStatus
    subclientName?: string | null
    username?: string | null
  }

  export type ClientDMBUncheckedCreateWithoutClientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accessType?: $Enums.AccessTypeDMB
    status?: $Enums.DMBStatus
    subclientName?: string | null
    username?: string | null
  }

  export type ClientDMBCreateOrConnectWithoutClientInput = {
    where: ClientDMBWhereUniqueInput
    create: XOR<ClientDMBCreateWithoutClientInput, ClientDMBUncheckedCreateWithoutClientInput>
  }

  export type BalanceCreateWithoutClientInput = {
    currency?: $Enums.Currency
    amount?: Decimal | DecimalJsLike | number | string
    amountRetain?: Decimal | DecimalJsLike | number | string
    amountTerminated?: Decimal | DecimalJsLike | number | string
    transactions?: TransactionCreateNestedManyWithoutBalanceInput
  }

  export type BalanceUncheckedCreateWithoutClientInput = {
    id?: number
    currency?: $Enums.Currency
    amount?: Decimal | DecimalJsLike | number | string
    amountRetain?: Decimal | DecimalJsLike | number | string
    amountTerminated?: Decimal | DecimalJsLike | number | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutBalanceInput
  }

  export type BalanceCreateOrConnectWithoutClientInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutClientInput, BalanceUncheckedCreateWithoutClientInput>
  }

  export type BalanceCreateManyClientInputEnvelope = {
    data: BalanceCreateManyClientInput | BalanceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientPaymentInformationCreateWithoutClientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientPaymentInformationUncheckedCreateWithoutClientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethod?: $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientPaymentInformationCreateOrConnectWithoutClientInput = {
    where: ClientPaymentInformationWhereUniqueInput
    create: XOR<ClientPaymentInformationCreateWithoutClientInput, ClientPaymentInformationUncheckedCreateWithoutClientInput>
  }

  export type LabelCreateWithoutClientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
    country?: CountryCreateNestedOneWithoutLabelInput
    KontorRoyaltyReport?: KontorRoyaltyReportCreateNestedManyWithoutLabelInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateWithoutClientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    countryId?: number | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutLabelInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelCreateOrConnectWithoutClientInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutClientInput, LabelUncheckedCreateWithoutClientInput>
  }

  export type LabelCreateManyClientInputEnvelope = {
    data: LabelCreateManyClientInput | LabelCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutClientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    preferences?: UserPreferencesCreateNestedManyWithoutUserInput
    comms?: UserCommsCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    preferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput
    comms?: UserCommsUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserCreateManyClientInputEnvelope = {
    data: UserCreateManyClientInput | UserCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutClientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    uuid?: string
    type?: $Enums.ContractType
    ppd?: number | null
    status?: $Enums.ContractStatus
    docUrl?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    signed?: boolean
    signedAt?: Date | string | null
    signedBy?: string | null
  }

  export type ContractUncheckedCreateWithoutClientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    uuid?: string
    type?: $Enums.ContractType
    ppd?: number | null
    status?: $Enums.ContractStatus
    docUrl?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    signed?: boolean
    signedAt?: Date | string | null
    signedBy?: string | null
  }

  export type ContractCreateOrConnectWithoutClientInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput>
  }

  export type UserRoyaltyReportCreateWithoutClientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutUserRoyaltyReportInput
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutUserReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutUserReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutUserReportsInput
    transactions?: TransactionCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportUncheckedCreateWithoutClientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    baseReportId?: number | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportCreateOrConnectWithoutClientInput = {
    where: UserRoyaltyReportWhereUniqueInput
    create: XOR<UserRoyaltyReportCreateWithoutClientInput, UserRoyaltyReportUncheckedCreateWithoutClientInput>
  }

  export type UserRoyaltyReportCreateManyClientInputEnvelope = {
    data: UserRoyaltyReportCreateManyClientInput | UserRoyaltyReportCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithoutClientInput = {
    update: XOR<AddressUpdateWithoutClientInput, AddressUncheckedUpdateWithoutClientInput>
    create: XOR<AddressCreateWithoutClientInput, AddressUncheckedCreateWithoutClientInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutClientInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutClientInput, AddressUncheckedUpdateWithoutClientInput>
  }

  export type AddressUpdateWithoutClientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    street?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: CountryUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    street?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    zip?: StringFieldUpdateOperationsInput | string
  }

  export type ClientDMBUpsertWithoutClientInput = {
    update: XOR<ClientDMBUpdateWithoutClientInput, ClientDMBUncheckedUpdateWithoutClientInput>
    create: XOR<ClientDMBCreateWithoutClientInput, ClientDMBUncheckedCreateWithoutClientInput>
    where?: ClientDMBWhereInput
  }

  export type ClientDMBUpdateToOneWithWhereWithoutClientInput = {
    where?: ClientDMBWhereInput
    data: XOR<ClientDMBUpdateWithoutClientInput, ClientDMBUncheckedUpdateWithoutClientInput>
  }

  export type ClientDMBUpdateWithoutClientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessType?: EnumAccessTypeDMBFieldUpdateOperationsInput | $Enums.AccessTypeDMB
    status?: EnumDMBStatusFieldUpdateOperationsInput | $Enums.DMBStatus
    subclientName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientDMBUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessType?: EnumAccessTypeDMBFieldUpdateOperationsInput | $Enums.AccessTypeDMB
    status?: EnumDMBStatusFieldUpdateOperationsInput | $Enums.DMBStatus
    subclientName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BalanceUpsertWithWhereUniqueWithoutClientInput = {
    where: BalanceWhereUniqueInput
    update: XOR<BalanceUpdateWithoutClientInput, BalanceUncheckedUpdateWithoutClientInput>
    create: XOR<BalanceCreateWithoutClientInput, BalanceUncheckedCreateWithoutClientInput>
  }

  export type BalanceUpdateWithWhereUniqueWithoutClientInput = {
    where: BalanceWhereUniqueInput
    data: XOR<BalanceUpdateWithoutClientInput, BalanceUncheckedUpdateWithoutClientInput>
  }

  export type BalanceUpdateManyWithWhereWithoutClientInput = {
    where: BalanceScalarWhereInput
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyWithoutClientInput>
  }

  export type BalanceScalarWhereInput = {
    AND?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
    OR?: BalanceScalarWhereInput[]
    NOT?: BalanceScalarWhereInput | BalanceScalarWhereInput[]
    id?: IntFilter<"Balance"> | number
    clientId?: IntFilter<"Balance"> | number
    currency?: EnumCurrencyFilter<"Balance"> | $Enums.Currency
    amount?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFilter<"Balance"> | Decimal | DecimalJsLike | number | string
  }

  export type ClientPaymentInformationUpsertWithoutClientInput = {
    update: XOR<ClientPaymentInformationUpdateWithoutClientInput, ClientPaymentInformationUncheckedUpdateWithoutClientInput>
    create: XOR<ClientPaymentInformationCreateWithoutClientInput, ClientPaymentInformationUncheckedCreateWithoutClientInput>
    where?: ClientPaymentInformationWhereInput
  }

  export type ClientPaymentInformationUpdateToOneWithWhereWithoutClientInput = {
    where?: ClientPaymentInformationWhereInput
    data: XOR<ClientPaymentInformationUpdateWithoutClientInput, ClientPaymentInformationUncheckedUpdateWithoutClientInput>
  }

  export type ClientPaymentInformationUpdateWithoutClientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ClientPaymentInformationUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LabelUpsertWithWhereUniqueWithoutClientInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutClientInput, LabelUncheckedUpdateWithoutClientInput>
    create: XOR<LabelCreateWithoutClientInput, LabelUncheckedCreateWithoutClientInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutClientInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutClientInput, LabelUncheckedUpdateWithoutClientInput>
  }

  export type LabelUpdateManyWithWhereWithoutClientInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutClientInput>
  }

  export type LabelScalarWhereInput = {
    AND?: LabelScalarWhereInput | LabelScalarWhereInput[]
    OR?: LabelScalarWhereInput[]
    NOT?: LabelScalarWhereInput | LabelScalarWhereInput[]
    id?: IntFilter<"Label"> | number
    createdAt?: DateTimeFilter<"Label"> | Date | string
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    clientId?: IntFilter<"Label"> | number
    name?: StringFilter<"Label"> | string
    status?: EnumLabelStatusFilter<"Label"> | $Enums.LabelStatus
    website?: StringNullableFilter<"Label"> | string | null
    countryId?: IntNullableFilter<"Label"> | number | null
    beatportStatus?: EnumLabelRegistrationStatusFilter<"Label"> | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFilter<"Label"> | $Enums.LabelRegistrationStatus
    beatportUrl?: StringNullableFilter<"Label"> | string | null
    traxsourceUrl?: StringNullableFilter<"Label"> | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutClientInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserUpdateWithWhereUniqueWithoutClientInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateManyWithWhereWithoutClientInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutClientInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    usernameDMB?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    clientId?: IntNullableFilter<"User"> | number | null
  }

  export type ContractUpsertWithoutClientInput = {
    update: XOR<ContractUpdateWithoutClientInput, ContractUncheckedUpdateWithoutClientInput>
    create: XOR<ContractCreateWithoutClientInput, ContractUncheckedCreateWithoutClientInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutClientInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutClientInput, ContractUncheckedUpdateWithoutClientInput>
  }

  export type ContractUpdateWithoutClientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    ppd?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    ppd?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    docUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signed?: BoolFieldUpdateOperationsInput | boolean
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoyaltyReportUpsertWithWhereUniqueWithoutClientInput = {
    where: UserRoyaltyReportWhereUniqueInput
    update: XOR<UserRoyaltyReportUpdateWithoutClientInput, UserRoyaltyReportUncheckedUpdateWithoutClientInput>
    create: XOR<UserRoyaltyReportCreateWithoutClientInput, UserRoyaltyReportUncheckedCreateWithoutClientInput>
  }

  export type UserRoyaltyReportUpdateWithWhereUniqueWithoutClientInput = {
    where: UserRoyaltyReportWhereUniqueInput
    data: XOR<UserRoyaltyReportUpdateWithoutClientInput, UserRoyaltyReportUncheckedUpdateWithoutClientInput>
  }

  export type UserRoyaltyReportUpdateManyWithWhereWithoutClientInput = {
    where: UserRoyaltyReportScalarWhereInput
    data: XOR<UserRoyaltyReportUpdateManyMutationInput, UserRoyaltyReportUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientCreateWithoutDmbInput = {
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address: AddressCreateNestedOneWithoutClientInput
    balances?: BalanceCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationCreateNestedOneWithoutClientInput
    labels?: LabelCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    contract?: ContractCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutDmbInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    addressId: number
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    balances?: BalanceUncheckedCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationUncheckedCreateNestedOneWithoutClientInput
    labels?: LabelUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    contract?: ContractUncheckedCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutDmbInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDmbInput, ClientUncheckedCreateWithoutDmbInput>
  }

  export type ClientUpsertWithoutDmbInput = {
    update: XOR<ClientUpdateWithoutDmbInput, ClientUncheckedUpdateWithoutDmbInput>
    create: XOR<ClientCreateWithoutDmbInput, ClientUncheckedCreateWithoutDmbInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDmbInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDmbInput, ClientUncheckedUpdateWithoutDmbInput>
  }

  export type ClientUpdateWithoutDmbInput = {
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneRequiredWithoutClientNestedInput
    balances?: BalanceUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUpdateOneWithoutClientNestedInput
    labels?: LabelUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    contract?: ContractUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutDmbInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    addressId?: IntFieldUpdateOperationsInput | number
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    balances?: BalanceUncheckedUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUncheckedUpdateOneWithoutClientNestedInput
    labels?: LabelUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    contract?: ContractUncheckedUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutPaymentDataInput = {
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address: AddressCreateNestedOneWithoutClientInput
    dmb?: ClientDMBCreateNestedOneWithoutClientInput
    balances?: BalanceCreateNestedManyWithoutClientInput
    labels?: LabelCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    contract?: ContractCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutPaymentDataInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    addressId: number
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    dmb?: ClientDMBUncheckedCreateNestedOneWithoutClientInput
    balances?: BalanceUncheckedCreateNestedManyWithoutClientInput
    labels?: LabelUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    contract?: ContractUncheckedCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutPaymentDataInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutPaymentDataInput, ClientUncheckedCreateWithoutPaymentDataInput>
  }

  export type ClientUpsertWithoutPaymentDataInput = {
    update: XOR<ClientUpdateWithoutPaymentDataInput, ClientUncheckedUpdateWithoutPaymentDataInput>
    create: XOR<ClientCreateWithoutPaymentDataInput, ClientUncheckedCreateWithoutPaymentDataInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutPaymentDataInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutPaymentDataInput, ClientUncheckedUpdateWithoutPaymentDataInput>
  }

  export type ClientUpdateWithoutPaymentDataInput = {
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneRequiredWithoutClientNestedInput
    dmb?: ClientDMBUpdateOneWithoutClientNestedInput
    balances?: BalanceUpdateManyWithoutClientNestedInput
    labels?: LabelUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    contract?: ContractUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutPaymentDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    addressId?: IntFieldUpdateOperationsInput | number
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    dmb?: ClientDMBUncheckedUpdateOneWithoutClientNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutClientNestedInput
    labels?: LabelUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    contract?: ContractUncheckedUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutContractInput = {
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address: AddressCreateNestedOneWithoutClientInput
    dmb?: ClientDMBCreateNestedOneWithoutClientInput
    balances?: BalanceCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationCreateNestedOneWithoutClientInput
    labels?: LabelCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutContractInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    addressId: number
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    dmb?: ClientDMBUncheckedCreateNestedOneWithoutClientInput
    balances?: BalanceUncheckedCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationUncheckedCreateNestedOneWithoutClientInput
    labels?: LabelUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutContractInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutContractInput, ClientUncheckedCreateWithoutContractInput>
  }

  export type ClientUpsertWithoutContractInput = {
    update: XOR<ClientUpdateWithoutContractInput, ClientUncheckedUpdateWithoutContractInput>
    create: XOR<ClientCreateWithoutContractInput, ClientUncheckedCreateWithoutContractInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutContractInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutContractInput, ClientUncheckedUpdateWithoutContractInput>
  }

  export type ClientUpdateWithoutContractInput = {
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneRequiredWithoutClientNestedInput
    dmb?: ClientDMBUpdateOneWithoutClientNestedInput
    balances?: BalanceUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUpdateOneWithoutClientNestedInput
    labels?: LabelUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutContractInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    addressId?: IntFieldUpdateOperationsInput | number
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    dmb?: ClientDMBUncheckedUpdateOneWithoutClientNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUncheckedUpdateOneWithoutClientNestedInput
    labels?: LabelUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutBalancesInput = {
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address: AddressCreateNestedOneWithoutClientInput
    dmb?: ClientDMBCreateNestedOneWithoutClientInput
    paymentData?: ClientPaymentInformationCreateNestedOneWithoutClientInput
    labels?: LabelCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    contract?: ContractCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutBalancesInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    addressId: number
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    dmb?: ClientDMBUncheckedCreateNestedOneWithoutClientInput
    paymentData?: ClientPaymentInformationUncheckedCreateNestedOneWithoutClientInput
    labels?: LabelUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    contract?: ContractUncheckedCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutBalancesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutBalancesInput, ClientUncheckedCreateWithoutBalancesInput>
  }

  export type TransactionCreateWithoutBalanceInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutTransactionInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutBalanceInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    baseReportId?: number | null
    userReportId?: number | null
  }

  export type TransactionCreateOrConnectWithoutBalanceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBalanceInput, TransactionUncheckedCreateWithoutBalanceInput>
  }

  export type TransactionCreateManyBalanceInputEnvelope = {
    data: TransactionCreateManyBalanceInput | TransactionCreateManyBalanceInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutBalancesInput = {
    update: XOR<ClientUpdateWithoutBalancesInput, ClientUncheckedUpdateWithoutBalancesInput>
    create: XOR<ClientCreateWithoutBalancesInput, ClientUncheckedCreateWithoutBalancesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutBalancesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutBalancesInput, ClientUncheckedUpdateWithoutBalancesInput>
  }

  export type ClientUpdateWithoutBalancesInput = {
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneRequiredWithoutClientNestedInput
    dmb?: ClientDMBUpdateOneWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUpdateOneWithoutClientNestedInput
    labels?: LabelUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    contract?: ContractUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutBalancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    addressId?: IntFieldUpdateOperationsInput | number
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    dmb?: ClientDMBUncheckedUpdateOneWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUncheckedUpdateOneWithoutClientNestedInput
    labels?: LabelUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    contract?: ContractUncheckedUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutBalanceInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBalanceInput, TransactionUncheckedUpdateWithoutBalanceInput>
    create: XOR<TransactionCreateWithoutBalanceInput, TransactionUncheckedCreateWithoutBalanceInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBalanceInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBalanceInput, TransactionUncheckedUpdateWithoutBalanceInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBalanceInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutBalanceInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    description?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    reversed?: BoolFilter<"Transaction"> | boolean
    distributor?: EnumDistributorNullableFilter<"Transaction"> | $Enums.Distributor | null
    balanceId?: IntFilter<"Transaction"> | number
    baseReportId?: IntNullableFilter<"Transaction"> | number | null
    userReportId?: IntNullableFilter<"Transaction"> | number | null
  }

  export type BalanceCreateWithoutTransactionsInput = {
    currency?: $Enums.Currency
    amount?: Decimal | DecimalJsLike | number | string
    amountRetain?: Decimal | DecimalJsLike | number | string
    amountTerminated?: Decimal | DecimalJsLike | number | string
    client: ClientCreateNestedOneWithoutBalancesInput
  }

  export type BalanceUncheckedCreateWithoutTransactionsInput = {
    id?: number
    clientId: number
    currency?: $Enums.Currency
    amount?: Decimal | DecimalJsLike | number | string
    amountRetain?: Decimal | DecimalJsLike | number | string
    amountTerminated?: Decimal | DecimalJsLike | number | string
  }

  export type BalanceCreateOrConnectWithoutTransactionsInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutTransactionsInput, BalanceUncheckedCreateWithoutTransactionsInput>
  }

  export type BaseRoyaltyReportCreateWithoutTransactionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutBaseRoyaltyReportInput
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutBaseReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutBaseReportInput
    userReports?: UserRoyaltyReportCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportUncheckedCreateWithoutTransactionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    userReports?: UserRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportCreateOrConnectWithoutTransactionInput = {
    where: BaseRoyaltyReportWhereUniqueInput
    create: XOR<BaseRoyaltyReportCreateWithoutTransactionInput, BaseRoyaltyReportUncheckedCreateWithoutTransactionInput>
  }

  export type UserRoyaltyReportCreateWithoutTransactionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutUserRoyaltyReportInput
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutUserReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutUserReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutUserReportsInput
    client?: ClientCreateNestedOneWithoutUserRoyaltyReportInput
  }

  export type UserRoyaltyReportUncheckedCreateWithoutTransactionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    baseReportId?: number | null
    clientId?: number | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportCreateOrConnectWithoutTransactionsInput = {
    where: UserRoyaltyReportWhereUniqueInput
    create: XOR<UserRoyaltyReportCreateWithoutTransactionsInput, UserRoyaltyReportUncheckedCreateWithoutTransactionsInput>
  }

  export type BalanceUpsertWithoutTransactionsInput = {
    update: XOR<BalanceUpdateWithoutTransactionsInput, BalanceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BalanceCreateWithoutTransactionsInput, BalanceUncheckedCreateWithoutTransactionsInput>
    where?: BalanceWhereInput
  }

  export type BalanceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BalanceWhereInput
    data: XOR<BalanceUpdateWithoutTransactionsInput, BalanceUncheckedUpdateWithoutTransactionsInput>
  }

  export type BalanceUpdateWithoutTransactionsInput = {
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    client?: ClientUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type BalanceUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BaseRoyaltyReportUpsertWithoutTransactionInput = {
    update: XOR<BaseRoyaltyReportUpdateWithoutTransactionInput, BaseRoyaltyReportUncheckedUpdateWithoutTransactionInput>
    create: XOR<BaseRoyaltyReportCreateWithoutTransactionInput, BaseRoyaltyReportUncheckedCreateWithoutTransactionInput>
    where?: BaseRoyaltyReportWhereInput
  }

  export type BaseRoyaltyReportUpdateToOneWithWhereWithoutTransactionInput = {
    where?: BaseRoyaltyReportWhereInput
    data: XOR<BaseRoyaltyReportUpdateWithoutTransactionInput, BaseRoyaltyReportUncheckedUpdateWithoutTransactionInput>
  }

  export type BaseRoyaltyReportUpdateWithoutTransactionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutBaseRoyaltyReportNestedInput
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    userReports?: UserRoyaltyReportUpdateManyWithoutBaseReportNestedInput
  }

  export type BaseRoyaltyReportUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    userReports?: UserRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
  }

  export type UserRoyaltyReportUpsertWithoutTransactionsInput = {
    update: XOR<UserRoyaltyReportUpdateWithoutTransactionsInput, UserRoyaltyReportUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserRoyaltyReportCreateWithoutTransactionsInput, UserRoyaltyReportUncheckedCreateWithoutTransactionsInput>
    where?: UserRoyaltyReportWhereInput
  }

  export type UserRoyaltyReportUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserRoyaltyReportWhereInput
    data: XOR<UserRoyaltyReportUpdateWithoutTransactionsInput, UserRoyaltyReportUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserRoyaltyReportUpdateWithoutTransactionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutUserRoyaltyReportNestedInput
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutUserReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutUserReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutUserReportsNestedInput
    client?: ClientUpdateOneWithoutUserRoyaltyReportNestedInput
  }

  export type UserRoyaltyReportUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
  }

  export type CountryCreateWithoutAddressInput = {
    name: string
    shortCode: string
    code: string
    label?: LabelCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
    shortCode: string
    code: string
    label?: LabelUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutAddressInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutAddressInput, CountryUncheckedCreateWithoutAddressInput>
  }

  export type ClientCreateWithoutAddressInput = {
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    dmb?: ClientDMBCreateNestedOneWithoutClientInput
    balances?: BalanceCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationCreateNestedOneWithoutClientInput
    labels?: LabelCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    contract?: ContractCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAddressInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    dmb?: ClientDMBUncheckedCreateNestedOneWithoutClientInput
    balances?: BalanceUncheckedCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationUncheckedCreateNestedOneWithoutClientInput
    labels?: LabelUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    contract?: ContractUncheckedCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAddressInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAddressInput, ClientUncheckedCreateWithoutAddressInput>
  }

  export type ClientCreateManyAddressInputEnvelope = {
    data: ClientCreateManyAddressInput | ClientCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutAddressInput = {
    update: XOR<CountryUpdateWithoutAddressInput, CountryUncheckedUpdateWithoutAddressInput>
    create: XOR<CountryCreateWithoutAddressInput, CountryUncheckedCreateWithoutAddressInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutAddressInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutAddressInput, CountryUncheckedUpdateWithoutAddressInput>
  }

  export type CountryUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: LabelUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    label?: LabelUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type ClientUpsertWithWhereUniqueWithoutAddressInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutAddressInput, ClientUncheckedUpdateWithoutAddressInput>
    create: XOR<ClientCreateWithoutAddressInput, ClientUncheckedCreateWithoutAddressInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutAddressInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutAddressInput, ClientUncheckedUpdateWithoutAddressInput>
  }

  export type ClientUpdateManyWithWhereWithoutAddressInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutAddressInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: IntFilter<"Client"> | number
    wp_id?: IntNullableFilter<"Client"> | number | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    clientName?: StringFilter<"Client"> | string
    firstName?: StringFilter<"Client"> | string
    lastName?: StringFilter<"Client"> | string
    type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    addressId?: IntFilter<"Client"> | number
    taxIdType?: EnumTaxIdTypeFilter<"Client"> | $Enums.TaxIdType
    taxId?: StringFilter<"Client"> | string
    vatRegistered?: BoolFilter<"Client"> | boolean
    vatId?: StringNullableFilter<"Client"> | string | null
    status?: EnumClientStatusFilter<"Client"> | $Enums.ClientStatus
    isBlocked?: BoolNullableFilter<"Client"> | boolean | null
    isPaymentsBlocked?: BoolNullableFilter<"Client"> | boolean | null
    isPaymentInProgress?: BoolFilter<"Client"> | boolean
    isPaymentDataInValidation?: BoolFilter<"Client"> | boolean
  }

  export type AddressCreateWithoutCountryInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    street: string
    street2?: string | null
    city: string
    state: string
    zip: string
    client?: ClientCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCountryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    street: string
    street2?: string | null
    city: string
    state: string
    zip: string
    client?: ClientUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutCountryInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput>
  }

  export type AddressCreateManyCountryInputEnvelope = {
    data: AddressCreateManyCountryInput | AddressCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type LabelCreateWithoutCountryInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
    client: ClientCreateNestedOneWithoutLabelsInput
    KontorRoyaltyReport?: KontorRoyaltyReportCreateNestedManyWithoutLabelInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateWithoutCountryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: number
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutLabelInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelCreateOrConnectWithoutCountryInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutCountryInput, LabelUncheckedCreateWithoutCountryInput>
  }

  export type LabelCreateManyCountryInputEnvelope = {
    data: LabelCreateManyCountryInput | LabelCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutCountryInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCountryInput, AddressUncheckedUpdateWithoutCountryInput>
    create: XOR<AddressCreateWithoutCountryInput, AddressUncheckedCreateWithoutCountryInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCountryInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCountryInput, AddressUncheckedUpdateWithoutCountryInput>
  }

  export type AddressUpdateManyWithWhereWithoutCountryInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutCountryInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: IntFilter<"Address"> | number
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    street?: StringFilter<"Address"> | string
    street2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    countryId?: IntFilter<"Address"> | number
    zip?: StringFilter<"Address"> | string
  }

  export type LabelUpsertWithWhereUniqueWithoutCountryInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutCountryInput, LabelUncheckedUpdateWithoutCountryInput>
    create: XOR<LabelCreateWithoutCountryInput, LabelUncheckedCreateWithoutCountryInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutCountryInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutCountryInput, LabelUncheckedUpdateWithoutCountryInput>
  }

  export type LabelUpdateManyWithWhereWithoutCountryInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutCountryInput>
  }

  export type ClientCreateWithoutLabelsInput = {
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address: AddressCreateNestedOneWithoutClientInput
    dmb?: ClientDMBCreateNestedOneWithoutClientInput
    balances?: BalanceCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationCreateNestedOneWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    contract?: ContractCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutLabelsInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    addressId: number
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    dmb?: ClientDMBUncheckedCreateNestedOneWithoutClientInput
    balances?: BalanceUncheckedCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationUncheckedCreateNestedOneWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    contract?: ContractUncheckedCreateNestedOneWithoutClientInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutLabelsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutLabelsInput, ClientUncheckedCreateWithoutLabelsInput>
  }

  export type CountryCreateWithoutLabelInput = {
    name: string
    shortCode: string
    code: string
    address?: AddressCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutLabelInput = {
    id?: number
    name: string
    shortCode: string
    code: string
    address?: AddressUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutLabelInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutLabelInput, CountryUncheckedCreateWithoutLabelInput>
  }

  export type KontorRoyaltyReportCreateWithoutLabelInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutKontorReportsInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutKontorReportsInput
    importedReport?: ImportedRoyaltyReportCreateNestedOneWithoutKontorRoyaltyReportInput
  }

  export type KontorRoyaltyReportUncheckedCreateWithoutLabelInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type KontorRoyaltyReportCreateOrConnectWithoutLabelInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    create: XOR<KontorRoyaltyReportCreateWithoutLabelInput, KontorRoyaltyReportUncheckedCreateWithoutLabelInput>
  }

  export type KontorRoyaltyReportCreateManyLabelInputEnvelope = {
    data: KontorRoyaltyReportCreateManyLabelInput | KontorRoyaltyReportCreateManyLabelInput[]
    skipDuplicates?: boolean
  }

  export type BelieveRoyaltyReportCreateWithoutLabelInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutBelieveReportsInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutBelieveReportsInput
    importedReport?: ImportedRoyaltyReportCreateNestedOneWithoutBelieveRoyaltyReportInput
  }

  export type BelieveRoyaltyReportUncheckedCreateWithoutLabelInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type BelieveRoyaltyReportCreateOrConnectWithoutLabelInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    create: XOR<BelieveRoyaltyReportCreateWithoutLabelInput, BelieveRoyaltyReportUncheckedCreateWithoutLabelInput>
  }

  export type BelieveRoyaltyReportCreateManyLabelInputEnvelope = {
    data: BelieveRoyaltyReportCreateManyLabelInput | BelieveRoyaltyReportCreateManyLabelInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutLabelsInput = {
    update: XOR<ClientUpdateWithoutLabelsInput, ClientUncheckedUpdateWithoutLabelsInput>
    create: XOR<ClientCreateWithoutLabelsInput, ClientUncheckedCreateWithoutLabelsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutLabelsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutLabelsInput, ClientUncheckedUpdateWithoutLabelsInput>
  }

  export type ClientUpdateWithoutLabelsInput = {
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneRequiredWithoutClientNestedInput
    dmb?: ClientDMBUpdateOneWithoutClientNestedInput
    balances?: BalanceUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUpdateOneWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    contract?: ContractUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutLabelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    addressId?: IntFieldUpdateOperationsInput | number
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    dmb?: ClientDMBUncheckedUpdateOneWithoutClientNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUncheckedUpdateOneWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    contract?: ContractUncheckedUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CountryUpsertWithoutLabelInput = {
    update: XOR<CountryUpdateWithoutLabelInput, CountryUncheckedUpdateWithoutLabelInput>
    create: XOR<CountryCreateWithoutLabelInput, CountryUncheckedCreateWithoutLabelInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutLabelInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutLabelInput, CountryUncheckedUpdateWithoutLabelInput>
  }

  export type CountryUpdateWithoutLabelInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutLabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortCode?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: AddressUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type KontorRoyaltyReportUpsertWithWhereUniqueWithoutLabelInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    update: XOR<KontorRoyaltyReportUpdateWithoutLabelInput, KontorRoyaltyReportUncheckedUpdateWithoutLabelInput>
    create: XOR<KontorRoyaltyReportCreateWithoutLabelInput, KontorRoyaltyReportUncheckedCreateWithoutLabelInput>
  }

  export type KontorRoyaltyReportUpdateWithWhereUniqueWithoutLabelInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    data: XOR<KontorRoyaltyReportUpdateWithoutLabelInput, KontorRoyaltyReportUncheckedUpdateWithoutLabelInput>
  }

  export type KontorRoyaltyReportUpdateManyWithWhereWithoutLabelInput = {
    where: KontorRoyaltyReportScalarWhereInput
    data: XOR<KontorRoyaltyReportUpdateManyMutationInput, KontorRoyaltyReportUncheckedUpdateManyWithoutLabelInput>
  }

  export type KontorRoyaltyReportScalarWhereInput = {
    AND?: KontorRoyaltyReportScalarWhereInput | KontorRoyaltyReportScalarWhereInput[]
    OR?: KontorRoyaltyReportScalarWhereInput[]
    NOT?: KontorRoyaltyReportScalarWhereInput | KontorRoyaltyReportScalarWhereInput[]
    id?: IntFilter<"KontorRoyaltyReport"> | number
    createdAt?: DateTimeFilter<"KontorRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"KontorRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"KontorRoyaltyReport"> | $Enums.Currency
    labelId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    reportingMonth?: StringFilter<"KontorRoyaltyReport"> | string
    salesMonth?: StringFilter<"KontorRoyaltyReport"> | string
    store?: StringFilter<"KontorRoyaltyReport"> | string
    chType?: StringNullableFilter<"KontorRoyaltyReport"> | string | null
    channelId?: StringNullableFilter<"KontorRoyaltyReport"> | string | null
    country?: StringFilter<"KontorRoyaltyReport"> | string
    labelName?: StringFilter<"KontorRoyaltyReport"> | string
    productType?: StringFilter<"KontorRoyaltyReport"> | string
    productTitle?: StringFilter<"KontorRoyaltyReport"> | string
    productArtist?: StringFilter<"KontorRoyaltyReport"> | string
    ean?: StringFilter<"KontorRoyaltyReport"> | string
    isrc?: StringFilter<"KontorRoyaltyReport"> | string
    grid?: StringFilter<"KontorRoyaltyReport"> | string
    articleNo?: StringNullableFilter<"KontorRoyaltyReport"> | string | null
    royalties?: DecimalFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    units?: IntFilter<"KontorRoyaltyReport"> | number
    cmg_clientRate?: DecimalNullableFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: DecimalNullableFilter<"KontorRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    baseReportId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    userReportId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
    importedReportId?: IntNullableFilter<"KontorRoyaltyReport"> | number | null
  }

  export type BelieveRoyaltyReportUpsertWithWhereUniqueWithoutLabelInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    update: XOR<BelieveRoyaltyReportUpdateWithoutLabelInput, BelieveRoyaltyReportUncheckedUpdateWithoutLabelInput>
    create: XOR<BelieveRoyaltyReportCreateWithoutLabelInput, BelieveRoyaltyReportUncheckedCreateWithoutLabelInput>
  }

  export type BelieveRoyaltyReportUpdateWithWhereUniqueWithoutLabelInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    data: XOR<BelieveRoyaltyReportUpdateWithoutLabelInput, BelieveRoyaltyReportUncheckedUpdateWithoutLabelInput>
  }

  export type BelieveRoyaltyReportUpdateManyWithWhereWithoutLabelInput = {
    where: BelieveRoyaltyReportScalarWhereInput
    data: XOR<BelieveRoyaltyReportUpdateManyMutationInput, BelieveRoyaltyReportUncheckedUpdateManyWithoutLabelInput>
  }

  export type BelieveRoyaltyReportScalarWhereInput = {
    AND?: BelieveRoyaltyReportScalarWhereInput | BelieveRoyaltyReportScalarWhereInput[]
    OR?: BelieveRoyaltyReportScalarWhereInput[]
    NOT?: BelieveRoyaltyReportScalarWhereInput | BelieveRoyaltyReportScalarWhereInput[]
    id?: IntFilter<"BelieveRoyaltyReport"> | number
    createdAt?: DateTimeFilter<"BelieveRoyaltyReport"> | Date | string
    updatedAt?: DateTimeFilter<"BelieveRoyaltyReport"> | Date | string
    currency?: EnumCurrencyFilter<"BelieveRoyaltyReport"> | $Enums.Currency
    labelId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    reportingMonth?: StringFilter<"BelieveRoyaltyReport"> | string
    salesMonth?: StringFilter<"BelieveRoyaltyReport"> | string
    platform?: StringFilter<"BelieveRoyaltyReport"> | string
    countryRegion?: StringFilter<"BelieveRoyaltyReport"> | string
    labelName?: StringFilter<"BelieveRoyaltyReport"> | string
    artistName?: StringFilter<"BelieveRoyaltyReport"> | string
    releaseTitle?: StringFilter<"BelieveRoyaltyReport"> | string
    trackTitle?: StringFilter<"BelieveRoyaltyReport"> | string
    upc?: StringFilter<"BelieveRoyaltyReport"> | string
    isrc?: StringFilter<"BelieveRoyaltyReport"> | string
    catalogNb?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    streamingSubscriptionType?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    releaseType?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    salesType?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    quantity?: StringFilter<"BelieveRoyaltyReport"> | string
    clientPaymentCurrency?: StringNullableFilter<"BelieveRoyaltyReport"> | string | null
    unitPrice?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    mechanicalFee?: DecimalNullableFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: DecimalNullableFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: DecimalNullableFilter<"BelieveRoyaltyReport"> | Decimal | DecimalJsLike | number | string | null
    baseReportId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    userReportId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
    importedReportId?: IntNullableFilter<"BelieveRoyaltyReport"> | number | null
  }

  export type S3FileCreateWithoutImportedRoyaltyReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    type: string
    folder?: string | null
    bucket: string
    key: string
    UserRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutS3FileInput
    BaseRoyaltyReport?: BaseRoyaltyReportCreateNestedManyWithoutS3FileInput
  }

  export type S3FileUncheckedCreateWithoutImportedRoyaltyReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    type: string
    folder?: string | null
    bucket: string
    key: string
    UserRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput
    BaseRoyaltyReport?: BaseRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput
  }

  export type S3FileCreateOrConnectWithoutImportedRoyaltyReportInput = {
    where: S3FileWhereUniqueInput
    create: XOR<S3FileCreateWithoutImportedRoyaltyReportInput, S3FileUncheckedCreateWithoutImportedRoyaltyReportInput>
  }

  export type KontorRoyaltyReportCreateWithoutImportedReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    label?: LabelCreateNestedOneWithoutKontorRoyaltyReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutKontorReportsInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutKontorReportsInput
  }

  export type KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
  }

  export type KontorRoyaltyReportCreateOrConnectWithoutImportedReportInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    create: XOR<KontorRoyaltyReportCreateWithoutImportedReportInput, KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput>
  }

  export type KontorRoyaltyReportCreateManyImportedReportInputEnvelope = {
    data: KontorRoyaltyReportCreateManyImportedReportInput | KontorRoyaltyReportCreateManyImportedReportInput[]
    skipDuplicates?: boolean
  }

  export type BelieveRoyaltyReportCreateWithoutImportedReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    label?: LabelCreateNestedOneWithoutBelieveRoyaltyReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutBelieveReportsInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutBelieveReportsInput
  }

  export type BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
  }

  export type BelieveRoyaltyReportCreateOrConnectWithoutImportedReportInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    create: XOR<BelieveRoyaltyReportCreateWithoutImportedReportInput, BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput>
  }

  export type BelieveRoyaltyReportCreateManyImportedReportInputEnvelope = {
    data: BelieveRoyaltyReportCreateManyImportedReportInput | BelieveRoyaltyReportCreateManyImportedReportInput[]
    skipDuplicates?: boolean
  }

  export type S3FileUpsertWithoutImportedRoyaltyReportInput = {
    update: XOR<S3FileUpdateWithoutImportedRoyaltyReportInput, S3FileUncheckedUpdateWithoutImportedRoyaltyReportInput>
    create: XOR<S3FileCreateWithoutImportedRoyaltyReportInput, S3FileUncheckedCreateWithoutImportedRoyaltyReportInput>
    where?: S3FileWhereInput
  }

  export type S3FileUpdateToOneWithWhereWithoutImportedRoyaltyReportInput = {
    where?: S3FileWhereInput
    data: XOR<S3FileUpdateWithoutImportedRoyaltyReportInput, S3FileUncheckedUpdateWithoutImportedRoyaltyReportInput>
  }

  export type S3FileUpdateWithoutImportedRoyaltyReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    folder?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    UserRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutS3FileNestedInput
    BaseRoyaltyReport?: BaseRoyaltyReportUpdateManyWithoutS3FileNestedInput
  }

  export type S3FileUncheckedUpdateWithoutImportedRoyaltyReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    folder?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    UserRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput
    BaseRoyaltyReport?: BaseRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput
  }

  export type KontorRoyaltyReportUpsertWithWhereUniqueWithoutImportedReportInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    update: XOR<KontorRoyaltyReportUpdateWithoutImportedReportInput, KontorRoyaltyReportUncheckedUpdateWithoutImportedReportInput>
    create: XOR<KontorRoyaltyReportCreateWithoutImportedReportInput, KontorRoyaltyReportUncheckedCreateWithoutImportedReportInput>
  }

  export type KontorRoyaltyReportUpdateWithWhereUniqueWithoutImportedReportInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    data: XOR<KontorRoyaltyReportUpdateWithoutImportedReportInput, KontorRoyaltyReportUncheckedUpdateWithoutImportedReportInput>
  }

  export type KontorRoyaltyReportUpdateManyWithWhereWithoutImportedReportInput = {
    where: KontorRoyaltyReportScalarWhereInput
    data: XOR<KontorRoyaltyReportUpdateManyMutationInput, KontorRoyaltyReportUncheckedUpdateManyWithoutImportedReportInput>
  }

  export type BelieveRoyaltyReportUpsertWithWhereUniqueWithoutImportedReportInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    update: XOR<BelieveRoyaltyReportUpdateWithoutImportedReportInput, BelieveRoyaltyReportUncheckedUpdateWithoutImportedReportInput>
    create: XOR<BelieveRoyaltyReportCreateWithoutImportedReportInput, BelieveRoyaltyReportUncheckedCreateWithoutImportedReportInput>
  }

  export type BelieveRoyaltyReportUpdateWithWhereUniqueWithoutImportedReportInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    data: XOR<BelieveRoyaltyReportUpdateWithoutImportedReportInput, BelieveRoyaltyReportUncheckedUpdateWithoutImportedReportInput>
  }

  export type BelieveRoyaltyReportUpdateManyWithWhereWithoutImportedReportInput = {
    where: BelieveRoyaltyReportScalarWhereInput
    data: XOR<BelieveRoyaltyReportUpdateManyMutationInput, BelieveRoyaltyReportUncheckedUpdateManyWithoutImportedReportInput>
  }

  export type S3FileCreateWithoutBaseRoyaltyReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    type: string
    folder?: string | null
    bucket: string
    key: string
    UserRoyaltyReport?: UserRoyaltyReportCreateNestedManyWithoutS3FileInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportCreateNestedManyWithoutS3FileInput
  }

  export type S3FileUncheckedCreateWithoutBaseRoyaltyReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    type: string
    folder?: string | null
    bucket: string
    key: string
    UserRoyaltyReport?: UserRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput
  }

  export type S3FileCreateOrConnectWithoutBaseRoyaltyReportInput = {
    where: S3FileWhereUniqueInput
    create: XOR<S3FileCreateWithoutBaseRoyaltyReportInput, S3FileUncheckedCreateWithoutBaseRoyaltyReportInput>
  }

  export type KontorRoyaltyReportCreateWithoutBaseReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    label?: LabelCreateNestedOneWithoutKontorRoyaltyReportInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutKontorReportsInput
    importedReport?: ImportedRoyaltyReportCreateNestedOneWithoutKontorRoyaltyReportInput
  }

  export type KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type KontorRoyaltyReportCreateOrConnectWithoutBaseReportInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    create: XOR<KontorRoyaltyReportCreateWithoutBaseReportInput, KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput>
  }

  export type KontorRoyaltyReportCreateManyBaseReportInputEnvelope = {
    data: KontorRoyaltyReportCreateManyBaseReportInput | KontorRoyaltyReportCreateManyBaseReportInput[]
    skipDuplicates?: boolean
  }

  export type BelieveRoyaltyReportCreateWithoutBaseReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    label?: LabelCreateNestedOneWithoutBelieveRoyaltyReportInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutBelieveReportsInput
    importedReport?: ImportedRoyaltyReportCreateNestedOneWithoutBelieveRoyaltyReportInput
  }

  export type BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type BelieveRoyaltyReportCreateOrConnectWithoutBaseReportInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    create: XOR<BelieveRoyaltyReportCreateWithoutBaseReportInput, BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput>
  }

  export type BelieveRoyaltyReportCreateManyBaseReportInputEnvelope = {
    data: BelieveRoyaltyReportCreateManyBaseReportInput | BelieveRoyaltyReportCreateManyBaseReportInput[]
    skipDuplicates?: boolean
  }

  export type UserRoyaltyReportCreateWithoutBaseReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutUserRoyaltyReportInput
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutUserReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutUserReportInput
    client?: ClientCreateNestedOneWithoutUserRoyaltyReportInput
    transactions?: TransactionCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportUncheckedCreateWithoutBaseReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    clientId?: number | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportCreateOrConnectWithoutBaseReportInput = {
    where: UserRoyaltyReportWhereUniqueInput
    create: XOR<UserRoyaltyReportCreateWithoutBaseReportInput, UserRoyaltyReportUncheckedCreateWithoutBaseReportInput>
  }

  export type UserRoyaltyReportCreateManyBaseReportInputEnvelope = {
    data: UserRoyaltyReportCreateManyBaseReportInput | UserRoyaltyReportCreateManyBaseReportInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutBaseReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    balance: BalanceCreateNestedOneWithoutTransactionsInput
    userReport?: UserRoyaltyReportCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutBaseReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    balanceId: number
    userReportId?: number | null
  }

  export type TransactionCreateOrConnectWithoutBaseReportInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBaseReportInput, TransactionUncheckedCreateWithoutBaseReportInput>
  }

  export type TransactionCreateManyBaseReportInputEnvelope = {
    data: TransactionCreateManyBaseReportInput | TransactionCreateManyBaseReportInput[]
    skipDuplicates?: boolean
  }

  export type S3FileUpsertWithoutBaseRoyaltyReportInput = {
    update: XOR<S3FileUpdateWithoutBaseRoyaltyReportInput, S3FileUncheckedUpdateWithoutBaseRoyaltyReportInput>
    create: XOR<S3FileCreateWithoutBaseRoyaltyReportInput, S3FileUncheckedCreateWithoutBaseRoyaltyReportInput>
    where?: S3FileWhereInput
  }

  export type S3FileUpdateToOneWithWhereWithoutBaseRoyaltyReportInput = {
    where?: S3FileWhereInput
    data: XOR<S3FileUpdateWithoutBaseRoyaltyReportInput, S3FileUncheckedUpdateWithoutBaseRoyaltyReportInput>
  }

  export type S3FileUpdateWithoutBaseRoyaltyReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    folder?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    UserRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutS3FileNestedInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportUpdateManyWithoutS3FileNestedInput
  }

  export type S3FileUncheckedUpdateWithoutBaseRoyaltyReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    folder?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    UserRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput
  }

  export type KontorRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    update: XOR<KontorRoyaltyReportUpdateWithoutBaseReportInput, KontorRoyaltyReportUncheckedUpdateWithoutBaseReportInput>
    create: XOR<KontorRoyaltyReportCreateWithoutBaseReportInput, KontorRoyaltyReportUncheckedCreateWithoutBaseReportInput>
  }

  export type KontorRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    data: XOR<KontorRoyaltyReportUpdateWithoutBaseReportInput, KontorRoyaltyReportUncheckedUpdateWithoutBaseReportInput>
  }

  export type KontorRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput = {
    where: KontorRoyaltyReportScalarWhereInput
    data: XOR<KontorRoyaltyReportUpdateManyMutationInput, KontorRoyaltyReportUncheckedUpdateManyWithoutBaseReportInput>
  }

  export type BelieveRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    update: XOR<BelieveRoyaltyReportUpdateWithoutBaseReportInput, BelieveRoyaltyReportUncheckedUpdateWithoutBaseReportInput>
    create: XOR<BelieveRoyaltyReportCreateWithoutBaseReportInput, BelieveRoyaltyReportUncheckedCreateWithoutBaseReportInput>
  }

  export type BelieveRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    data: XOR<BelieveRoyaltyReportUpdateWithoutBaseReportInput, BelieveRoyaltyReportUncheckedUpdateWithoutBaseReportInput>
  }

  export type BelieveRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput = {
    where: BelieveRoyaltyReportScalarWhereInput
    data: XOR<BelieveRoyaltyReportUpdateManyMutationInput, BelieveRoyaltyReportUncheckedUpdateManyWithoutBaseReportInput>
  }

  export type UserRoyaltyReportUpsertWithWhereUniqueWithoutBaseReportInput = {
    where: UserRoyaltyReportWhereUniqueInput
    update: XOR<UserRoyaltyReportUpdateWithoutBaseReportInput, UserRoyaltyReportUncheckedUpdateWithoutBaseReportInput>
    create: XOR<UserRoyaltyReportCreateWithoutBaseReportInput, UserRoyaltyReportUncheckedCreateWithoutBaseReportInput>
  }

  export type UserRoyaltyReportUpdateWithWhereUniqueWithoutBaseReportInput = {
    where: UserRoyaltyReportWhereUniqueInput
    data: XOR<UserRoyaltyReportUpdateWithoutBaseReportInput, UserRoyaltyReportUncheckedUpdateWithoutBaseReportInput>
  }

  export type UserRoyaltyReportUpdateManyWithWhereWithoutBaseReportInput = {
    where: UserRoyaltyReportScalarWhereInput
    data: XOR<UserRoyaltyReportUpdateManyMutationInput, UserRoyaltyReportUncheckedUpdateManyWithoutBaseReportInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutBaseReportInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBaseReportInput, TransactionUncheckedUpdateWithoutBaseReportInput>
    create: XOR<TransactionCreateWithoutBaseReportInput, TransactionUncheckedCreateWithoutBaseReportInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBaseReportInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBaseReportInput, TransactionUncheckedUpdateWithoutBaseReportInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBaseReportInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutBaseReportInput>
  }

  export type S3FileCreateWithoutUserRoyaltyReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    type: string
    folder?: string | null
    bucket: string
    key: string
    BaseRoyaltyReport?: BaseRoyaltyReportCreateNestedManyWithoutS3FileInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportCreateNestedManyWithoutS3FileInput
  }

  export type S3FileUncheckedCreateWithoutUserRoyaltyReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    type: string
    folder?: string | null
    bucket: string
    key: string
    BaseRoyaltyReport?: BaseRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportUncheckedCreateNestedManyWithoutS3FileInput
  }

  export type S3FileCreateOrConnectWithoutUserRoyaltyReportInput = {
    where: S3FileWhereUniqueInput
    create: XOR<S3FileCreateWithoutUserRoyaltyReportInput, S3FileUncheckedCreateWithoutUserRoyaltyReportInput>
  }

  export type KontorRoyaltyReportCreateWithoutUserReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    label?: LabelCreateNestedOneWithoutKontorRoyaltyReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutKontorReportsInput
    importedReport?: ImportedRoyaltyReportCreateNestedOneWithoutKontorRoyaltyReportInput
  }

  export type KontorRoyaltyReportUncheckedCreateWithoutUserReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    importedReportId?: number | null
  }

  export type KontorRoyaltyReportCreateOrConnectWithoutUserReportInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    create: XOR<KontorRoyaltyReportCreateWithoutUserReportInput, KontorRoyaltyReportUncheckedCreateWithoutUserReportInput>
  }

  export type KontorRoyaltyReportCreateManyUserReportInputEnvelope = {
    data: KontorRoyaltyReportCreateManyUserReportInput | KontorRoyaltyReportCreateManyUserReportInput[]
    skipDuplicates?: boolean
  }

  export type BelieveRoyaltyReportCreateWithoutUserReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    label?: LabelCreateNestedOneWithoutBelieveRoyaltyReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutBelieveReportsInput
    importedReport?: ImportedRoyaltyReportCreateNestedOneWithoutBelieveRoyaltyReportInput
  }

  export type BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    importedReportId?: number | null
  }

  export type BelieveRoyaltyReportCreateOrConnectWithoutUserReportInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    create: XOR<BelieveRoyaltyReportCreateWithoutUserReportInput, BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput>
  }

  export type BelieveRoyaltyReportCreateManyUserReportInputEnvelope = {
    data: BelieveRoyaltyReportCreateManyUserReportInput | BelieveRoyaltyReportCreateManyUserReportInput[]
    skipDuplicates?: boolean
  }

  export type BaseRoyaltyReportCreateWithoutUserReportsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutBaseRoyaltyReportInput
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutBaseReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutBaseReportInput
    Transaction?: TransactionCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportUncheckedCreateWithoutUserReportsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportCreateOrConnectWithoutUserReportsInput = {
    where: BaseRoyaltyReportWhereUniqueInput
    create: XOR<BaseRoyaltyReportCreateWithoutUserReportsInput, BaseRoyaltyReportUncheckedCreateWithoutUserReportsInput>
  }

  export type ClientCreateWithoutUserRoyaltyReportInput = {
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    address: AddressCreateNestedOneWithoutClientInput
    dmb?: ClientDMBCreateNestedOneWithoutClientInput
    balances?: BalanceCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationCreateNestedOneWithoutClientInput
    labels?: LabelCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    contract?: ContractCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserRoyaltyReportInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    addressId: number
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
    dmb?: ClientDMBUncheckedCreateNestedOneWithoutClientInput
    balances?: BalanceUncheckedCreateNestedManyWithoutClientInput
    paymentData?: ClientPaymentInformationUncheckedCreateNestedOneWithoutClientInput
    labels?: LabelUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    contract?: ContractUncheckedCreateNestedOneWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserRoyaltyReportInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserRoyaltyReportInput, ClientUncheckedCreateWithoutUserRoyaltyReportInput>
  }

  export type TransactionCreateWithoutUserReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    balance: BalanceCreateNestedOneWithoutTransactionsInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    balanceId: number
    baseReportId?: number | null
  }

  export type TransactionCreateOrConnectWithoutUserReportInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserReportInput, TransactionUncheckedCreateWithoutUserReportInput>
  }

  export type TransactionCreateManyUserReportInputEnvelope = {
    data: TransactionCreateManyUserReportInput | TransactionCreateManyUserReportInput[]
    skipDuplicates?: boolean
  }

  export type S3FileUpsertWithoutUserRoyaltyReportInput = {
    update: XOR<S3FileUpdateWithoutUserRoyaltyReportInput, S3FileUncheckedUpdateWithoutUserRoyaltyReportInput>
    create: XOR<S3FileCreateWithoutUserRoyaltyReportInput, S3FileUncheckedCreateWithoutUserRoyaltyReportInput>
    where?: S3FileWhereInput
  }

  export type S3FileUpdateToOneWithWhereWithoutUserRoyaltyReportInput = {
    where?: S3FileWhereInput
    data: XOR<S3FileUpdateWithoutUserRoyaltyReportInput, S3FileUncheckedUpdateWithoutUserRoyaltyReportInput>
  }

  export type S3FileUpdateWithoutUserRoyaltyReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    folder?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    BaseRoyaltyReport?: BaseRoyaltyReportUpdateManyWithoutS3FileNestedInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportUpdateManyWithoutS3FileNestedInput
  }

  export type S3FileUncheckedUpdateWithoutUserRoyaltyReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    folder?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    BaseRoyaltyReport?: BaseRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput
    ImportedRoyaltyReport?: ImportedRoyaltyReportUncheckedUpdateManyWithoutS3FileNestedInput
  }

  export type KontorRoyaltyReportUpsertWithWhereUniqueWithoutUserReportInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    update: XOR<KontorRoyaltyReportUpdateWithoutUserReportInput, KontorRoyaltyReportUncheckedUpdateWithoutUserReportInput>
    create: XOR<KontorRoyaltyReportCreateWithoutUserReportInput, KontorRoyaltyReportUncheckedCreateWithoutUserReportInput>
  }

  export type KontorRoyaltyReportUpdateWithWhereUniqueWithoutUserReportInput = {
    where: KontorRoyaltyReportWhereUniqueInput
    data: XOR<KontorRoyaltyReportUpdateWithoutUserReportInput, KontorRoyaltyReportUncheckedUpdateWithoutUserReportInput>
  }

  export type KontorRoyaltyReportUpdateManyWithWhereWithoutUserReportInput = {
    where: KontorRoyaltyReportScalarWhereInput
    data: XOR<KontorRoyaltyReportUpdateManyMutationInput, KontorRoyaltyReportUncheckedUpdateManyWithoutUserReportInput>
  }

  export type BelieveRoyaltyReportUpsertWithWhereUniqueWithoutUserReportInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    update: XOR<BelieveRoyaltyReportUpdateWithoutUserReportInput, BelieveRoyaltyReportUncheckedUpdateWithoutUserReportInput>
    create: XOR<BelieveRoyaltyReportCreateWithoutUserReportInput, BelieveRoyaltyReportUncheckedCreateWithoutUserReportInput>
  }

  export type BelieveRoyaltyReportUpdateWithWhereUniqueWithoutUserReportInput = {
    where: BelieveRoyaltyReportWhereUniqueInput
    data: XOR<BelieveRoyaltyReportUpdateWithoutUserReportInput, BelieveRoyaltyReportUncheckedUpdateWithoutUserReportInput>
  }

  export type BelieveRoyaltyReportUpdateManyWithWhereWithoutUserReportInput = {
    where: BelieveRoyaltyReportScalarWhereInput
    data: XOR<BelieveRoyaltyReportUpdateManyMutationInput, BelieveRoyaltyReportUncheckedUpdateManyWithoutUserReportInput>
  }

  export type BaseRoyaltyReportUpsertWithoutUserReportsInput = {
    update: XOR<BaseRoyaltyReportUpdateWithoutUserReportsInput, BaseRoyaltyReportUncheckedUpdateWithoutUserReportsInput>
    create: XOR<BaseRoyaltyReportCreateWithoutUserReportsInput, BaseRoyaltyReportUncheckedCreateWithoutUserReportsInput>
    where?: BaseRoyaltyReportWhereInput
  }

  export type BaseRoyaltyReportUpdateToOneWithWhereWithoutUserReportsInput = {
    where?: BaseRoyaltyReportWhereInput
    data: XOR<BaseRoyaltyReportUpdateWithoutUserReportsInput, BaseRoyaltyReportUncheckedUpdateWithoutUserReportsInput>
  }

  export type BaseRoyaltyReportUpdateWithoutUserReportsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutBaseRoyaltyReportNestedInput
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    Transaction?: TransactionUpdateManyWithoutBaseReportNestedInput
  }

  export type BaseRoyaltyReportUncheckedUpdateWithoutUserReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBaseReportNestedInput
  }

  export type ClientUpsertWithoutUserRoyaltyReportInput = {
    update: XOR<ClientUpdateWithoutUserRoyaltyReportInput, ClientUncheckedUpdateWithoutUserRoyaltyReportInput>
    create: XOR<ClientCreateWithoutUserRoyaltyReportInput, ClientUncheckedCreateWithoutUserRoyaltyReportInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUserRoyaltyReportInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUserRoyaltyReportInput, ClientUncheckedUpdateWithoutUserRoyaltyReportInput>
  }

  export type ClientUpdateWithoutUserRoyaltyReportInput = {
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneRequiredWithoutClientNestedInput
    dmb?: ClientDMBUpdateOneWithoutClientNestedInput
    balances?: BalanceUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUpdateOneWithoutClientNestedInput
    labels?: LabelUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    contract?: ContractUpdateOneWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserRoyaltyReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    addressId?: IntFieldUpdateOperationsInput | number
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    dmb?: ClientDMBUncheckedUpdateOneWithoutClientNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUncheckedUpdateOneWithoutClientNestedInput
    labels?: LabelUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    contract?: ContractUncheckedUpdateOneWithoutClientNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserReportInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserReportInput, TransactionUncheckedUpdateWithoutUserReportInput>
    create: XOR<TransactionCreateWithoutUserReportInput, TransactionUncheckedCreateWithoutUserReportInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserReportInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserReportInput, TransactionUncheckedUpdateWithoutUserReportInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserReportInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserReportInput>
  }

  export type LabelCreateWithoutKontorRoyaltyReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
    client: ClientCreateNestedOneWithoutLabelsInput
    country?: CountryCreateNestedOneWithoutLabelInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateWithoutKontorRoyaltyReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: number
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    countryId?: number | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelCreateOrConnectWithoutKontorRoyaltyReportInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutKontorRoyaltyReportInput, LabelUncheckedCreateWithoutKontorRoyaltyReportInput>
  }

  export type BaseRoyaltyReportCreateWithoutKontorReportsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutBaseRoyaltyReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutBaseReportInput
    userReports?: UserRoyaltyReportCreateNestedManyWithoutBaseReportInput
    Transaction?: TransactionCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportUncheckedCreateWithoutKontorReportsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    userReports?: UserRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportCreateOrConnectWithoutKontorReportsInput = {
    where: BaseRoyaltyReportWhereUniqueInput
    create: XOR<BaseRoyaltyReportCreateWithoutKontorReportsInput, BaseRoyaltyReportUncheckedCreateWithoutKontorReportsInput>
  }

  export type UserRoyaltyReportCreateWithoutKontorReportsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutUserRoyaltyReportInput
    believeReports?: BelieveRoyaltyReportCreateNestedManyWithoutUserReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutUserReportsInput
    client?: ClientCreateNestedOneWithoutUserRoyaltyReportInput
    transactions?: TransactionCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportUncheckedCreateWithoutKontorReportsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    baseReportId?: number | null
    clientId?: number | null
    believeReports?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportCreateOrConnectWithoutKontorReportsInput = {
    where: UserRoyaltyReportWhereUniqueInput
    create: XOR<UserRoyaltyReportCreateWithoutKontorReportsInput, UserRoyaltyReportUncheckedCreateWithoutKontorReportsInput>
  }

  export type ImportedRoyaltyReportCreateWithoutKontorRoyaltyReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
    s3File?: S3FileCreateNestedOneWithoutImportedRoyaltyReportInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportCreateNestedManyWithoutImportedReportInput
  }

  export type ImportedRoyaltyReportUncheckedCreateWithoutKontorRoyaltyReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
    s3FileId?: number | null
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedCreateNestedManyWithoutImportedReportInput
  }

  export type ImportedRoyaltyReportCreateOrConnectWithoutKontorRoyaltyReportInput = {
    where: ImportedRoyaltyReportWhereUniqueInput
    create: XOR<ImportedRoyaltyReportCreateWithoutKontorRoyaltyReportInput, ImportedRoyaltyReportUncheckedCreateWithoutKontorRoyaltyReportInput>
  }

  export type LabelUpsertWithoutKontorRoyaltyReportInput = {
    update: XOR<LabelUpdateWithoutKontorRoyaltyReportInput, LabelUncheckedUpdateWithoutKontorRoyaltyReportInput>
    create: XOR<LabelCreateWithoutKontorRoyaltyReportInput, LabelUncheckedCreateWithoutKontorRoyaltyReportInput>
    where?: LabelWhereInput
  }

  export type LabelUpdateToOneWithWhereWithoutKontorRoyaltyReportInput = {
    where?: LabelWhereInput
    data: XOR<LabelUpdateWithoutKontorRoyaltyReportInput, LabelUncheckedUpdateWithoutKontorRoyaltyReportInput>
  }

  export type LabelUpdateWithoutKontorRoyaltyReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneWithoutLabelNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateWithoutKontorRoyaltyReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type BaseRoyaltyReportUpsertWithoutKontorReportsInput = {
    update: XOR<BaseRoyaltyReportUpdateWithoutKontorReportsInput, BaseRoyaltyReportUncheckedUpdateWithoutKontorReportsInput>
    create: XOR<BaseRoyaltyReportCreateWithoutKontorReportsInput, BaseRoyaltyReportUncheckedCreateWithoutKontorReportsInput>
    where?: BaseRoyaltyReportWhereInput
  }

  export type BaseRoyaltyReportUpdateToOneWithWhereWithoutKontorReportsInput = {
    where?: BaseRoyaltyReportWhereInput
    data: XOR<BaseRoyaltyReportUpdateWithoutKontorReportsInput, BaseRoyaltyReportUncheckedUpdateWithoutKontorReportsInput>
  }

  export type BaseRoyaltyReportUpdateWithoutKontorReportsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutBaseRoyaltyReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    userReports?: UserRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    Transaction?: TransactionUpdateManyWithoutBaseReportNestedInput
  }

  export type BaseRoyaltyReportUncheckedUpdateWithoutKontorReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    userReports?: UserRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBaseReportNestedInput
  }

  export type UserRoyaltyReportUpsertWithoutKontorReportsInput = {
    update: XOR<UserRoyaltyReportUpdateWithoutKontorReportsInput, UserRoyaltyReportUncheckedUpdateWithoutKontorReportsInput>
    create: XOR<UserRoyaltyReportCreateWithoutKontorReportsInput, UserRoyaltyReportUncheckedCreateWithoutKontorReportsInput>
    where?: UserRoyaltyReportWhereInput
  }

  export type UserRoyaltyReportUpdateToOneWithWhereWithoutKontorReportsInput = {
    where?: UserRoyaltyReportWhereInput
    data: XOR<UserRoyaltyReportUpdateWithoutKontorReportsInput, UserRoyaltyReportUncheckedUpdateWithoutKontorReportsInput>
  }

  export type UserRoyaltyReportUpdateWithoutKontorReportsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutUserRoyaltyReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutUserReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutUserReportsNestedInput
    client?: ClientUpdateOneWithoutUserRoyaltyReportNestedInput
    transactions?: TransactionUpdateManyWithoutUserReportNestedInput
  }

  export type UserRoyaltyReportUncheckedUpdateWithoutKontorReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserReportNestedInput
  }

  export type ImportedRoyaltyReportUpsertWithoutKontorRoyaltyReportInput = {
    update: XOR<ImportedRoyaltyReportUpdateWithoutKontorRoyaltyReportInput, ImportedRoyaltyReportUncheckedUpdateWithoutKontorRoyaltyReportInput>
    create: XOR<ImportedRoyaltyReportCreateWithoutKontorRoyaltyReportInput, ImportedRoyaltyReportUncheckedCreateWithoutKontorRoyaltyReportInput>
    where?: ImportedRoyaltyReportWhereInput
  }

  export type ImportedRoyaltyReportUpdateToOneWithWhereWithoutKontorRoyaltyReportInput = {
    where?: ImportedRoyaltyReportWhereInput
    data: XOR<ImportedRoyaltyReportUpdateWithoutKontorRoyaltyReportInput, ImportedRoyaltyReportUncheckedUpdateWithoutKontorRoyaltyReportInput>
  }

  export type ImportedRoyaltyReportUpdateWithoutKontorRoyaltyReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
    s3File?: S3FileUpdateOneWithoutImportedRoyaltyReportNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUpdateManyWithoutImportedReportNestedInput
  }

  export type ImportedRoyaltyReportUncheckedUpdateWithoutKontorRoyaltyReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedUpdateManyWithoutImportedReportNestedInput
  }

  export type LabelCreateWithoutBelieveRoyaltyReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
    client: ClientCreateNestedOneWithoutLabelsInput
    country?: CountryCreateNestedOneWithoutLabelInput
    KontorRoyaltyReport?: KontorRoyaltyReportCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateWithoutBelieveRoyaltyReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: number
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    countryId?: number | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelCreateOrConnectWithoutBelieveRoyaltyReportInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutBelieveRoyaltyReportInput, LabelUncheckedCreateWithoutBelieveRoyaltyReportInput>
  }

  export type BaseRoyaltyReportCreateWithoutBelieveReportsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutBaseRoyaltyReportInput
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutBaseReportInput
    userReports?: UserRoyaltyReportCreateNestedManyWithoutBaseReportInput
    Transaction?: TransactionCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportUncheckedCreateWithoutBelieveReportsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    userReports?: UserRoyaltyReportUncheckedCreateNestedManyWithoutBaseReportInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutBaseReportInput
  }

  export type BaseRoyaltyReportCreateOrConnectWithoutBelieveReportsInput = {
    where: BaseRoyaltyReportWhereUniqueInput
    create: XOR<BaseRoyaltyReportCreateWithoutBelieveReportsInput, BaseRoyaltyReportUncheckedCreateWithoutBelieveReportsInput>
  }

  export type UserRoyaltyReportCreateWithoutBelieveReportsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3File?: S3FileCreateNestedOneWithoutUserRoyaltyReportInput
    kontorReports?: KontorRoyaltyReportCreateNestedManyWithoutUserReportInput
    baseReport?: BaseRoyaltyReportCreateNestedOneWithoutUserReportsInput
    client?: ClientCreateNestedOneWithoutUserRoyaltyReportInput
    transactions?: TransactionCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportUncheckedCreateWithoutBelieveReportsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    baseReportId?: number | null
    clientId?: number | null
    kontorReports?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutUserReportInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserReportInput
  }

  export type UserRoyaltyReportCreateOrConnectWithoutBelieveReportsInput = {
    where: UserRoyaltyReportWhereUniqueInput
    create: XOR<UserRoyaltyReportCreateWithoutBelieveReportsInput, UserRoyaltyReportUncheckedCreateWithoutBelieveReportsInput>
  }

  export type ImportedRoyaltyReportCreateWithoutBelieveRoyaltyReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
    s3File?: S3FileCreateNestedOneWithoutImportedRoyaltyReportInput
    KontorRoyaltyReport?: KontorRoyaltyReportCreateNestedManyWithoutImportedReportInput
  }

  export type ImportedRoyaltyReportUncheckedCreateWithoutBelieveRoyaltyReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
    s3FileId?: number | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedCreateNestedManyWithoutImportedReportInput
  }

  export type ImportedRoyaltyReportCreateOrConnectWithoutBelieveRoyaltyReportInput = {
    where: ImportedRoyaltyReportWhereUniqueInput
    create: XOR<ImportedRoyaltyReportCreateWithoutBelieveRoyaltyReportInput, ImportedRoyaltyReportUncheckedCreateWithoutBelieveRoyaltyReportInput>
  }

  export type LabelUpsertWithoutBelieveRoyaltyReportInput = {
    update: XOR<LabelUpdateWithoutBelieveRoyaltyReportInput, LabelUncheckedUpdateWithoutBelieveRoyaltyReportInput>
    create: XOR<LabelCreateWithoutBelieveRoyaltyReportInput, LabelUncheckedCreateWithoutBelieveRoyaltyReportInput>
    where?: LabelWhereInput
  }

  export type LabelUpdateToOneWithWhereWithoutBelieveRoyaltyReportInput = {
    where?: LabelWhereInput
    data: XOR<LabelUpdateWithoutBelieveRoyaltyReportInput, LabelUncheckedUpdateWithoutBelieveRoyaltyReportInput>
  }

  export type LabelUpdateWithoutBelieveRoyaltyReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutLabelsNestedInput
    country?: CountryUpdateOneWithoutLabelNestedInput
    KontorRoyaltyReport?: KontorRoyaltyReportUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateWithoutBelieveRoyaltyReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type BaseRoyaltyReportUpsertWithoutBelieveReportsInput = {
    update: XOR<BaseRoyaltyReportUpdateWithoutBelieveReportsInput, BaseRoyaltyReportUncheckedUpdateWithoutBelieveReportsInput>
    create: XOR<BaseRoyaltyReportCreateWithoutBelieveReportsInput, BaseRoyaltyReportUncheckedCreateWithoutBelieveReportsInput>
    where?: BaseRoyaltyReportWhereInput
  }

  export type BaseRoyaltyReportUpdateToOneWithWhereWithoutBelieveReportsInput = {
    where?: BaseRoyaltyReportWhereInput
    data: XOR<BaseRoyaltyReportUpdateWithoutBelieveReportsInput, BaseRoyaltyReportUncheckedUpdateWithoutBelieveReportsInput>
  }

  export type BaseRoyaltyReportUpdateWithoutBelieveReportsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutBaseRoyaltyReportNestedInput
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    userReports?: UserRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    Transaction?: TransactionUpdateManyWithoutBaseReportNestedInput
  }

  export type BaseRoyaltyReportUncheckedUpdateWithoutBelieveReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    userReports?: UserRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBaseReportNestedInput
  }

  export type UserRoyaltyReportUpsertWithoutBelieveReportsInput = {
    update: XOR<UserRoyaltyReportUpdateWithoutBelieveReportsInput, UserRoyaltyReportUncheckedUpdateWithoutBelieveReportsInput>
    create: XOR<UserRoyaltyReportCreateWithoutBelieveReportsInput, UserRoyaltyReportUncheckedCreateWithoutBelieveReportsInput>
    where?: UserRoyaltyReportWhereInput
  }

  export type UserRoyaltyReportUpdateToOneWithWhereWithoutBelieveReportsInput = {
    where?: UserRoyaltyReportWhereInput
    data: XOR<UserRoyaltyReportUpdateWithoutBelieveReportsInput, UserRoyaltyReportUncheckedUpdateWithoutBelieveReportsInput>
  }

  export type UserRoyaltyReportUpdateWithoutBelieveReportsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutUserRoyaltyReportNestedInput
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutUserReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutUserReportsNestedInput
    client?: ClientUpdateOneWithoutUserRoyaltyReportNestedInput
    transactions?: TransactionUpdateManyWithoutUserReportNestedInput
  }

  export type UserRoyaltyReportUncheckedUpdateWithoutBelieveReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserReportNestedInput
  }

  export type ImportedRoyaltyReportUpsertWithoutBelieveRoyaltyReportInput = {
    update: XOR<ImportedRoyaltyReportUpdateWithoutBelieveRoyaltyReportInput, ImportedRoyaltyReportUncheckedUpdateWithoutBelieveRoyaltyReportInput>
    create: XOR<ImportedRoyaltyReportCreateWithoutBelieveRoyaltyReportInput, ImportedRoyaltyReportUncheckedCreateWithoutBelieveRoyaltyReportInput>
    where?: ImportedRoyaltyReportWhereInput
  }

  export type ImportedRoyaltyReportUpdateToOneWithWhereWithoutBelieveRoyaltyReportInput = {
    where?: ImportedRoyaltyReportWhereInput
    data: XOR<ImportedRoyaltyReportUpdateWithoutBelieveRoyaltyReportInput, ImportedRoyaltyReportUncheckedUpdateWithoutBelieveRoyaltyReportInput>
  }

  export type ImportedRoyaltyReportUpdateWithoutBelieveRoyaltyReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
    s3File?: S3FileUpdateOneWithoutImportedRoyaltyReportNestedInput
    KontorRoyaltyReport?: KontorRoyaltyReportUpdateManyWithoutImportedReportNestedInput
  }

  export type ImportedRoyaltyReportUncheckedUpdateWithoutBelieveRoyaltyReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedUpdateManyWithoutImportedReportNestedInput
  }

  export type UnlinkedReportDetailCreateWithoutUnlinkedReportInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type UnlinkedReportDetailCreateOrConnectWithoutUnlinkedReportInput = {
    where: UnlinkedReportDetailWhereUniqueInput
    create: XOR<UnlinkedReportDetailCreateWithoutUnlinkedReportInput, UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput>
  }

  export type UnlinkedReportDetailCreateManyUnlinkedReportInputEnvelope = {
    data: UnlinkedReportDetailCreateManyUnlinkedReportInput | UnlinkedReportDetailCreateManyUnlinkedReportInput[]
    skipDuplicates?: boolean
  }

  export type UnlinkedReportDetailUpsertWithWhereUniqueWithoutUnlinkedReportInput = {
    where: UnlinkedReportDetailWhereUniqueInput
    update: XOR<UnlinkedReportDetailUpdateWithoutUnlinkedReportInput, UnlinkedReportDetailUncheckedUpdateWithoutUnlinkedReportInput>
    create: XOR<UnlinkedReportDetailCreateWithoutUnlinkedReportInput, UnlinkedReportDetailUncheckedCreateWithoutUnlinkedReportInput>
  }

  export type UnlinkedReportDetailUpdateWithWhereUniqueWithoutUnlinkedReportInput = {
    where: UnlinkedReportDetailWhereUniqueInput
    data: XOR<UnlinkedReportDetailUpdateWithoutUnlinkedReportInput, UnlinkedReportDetailUncheckedUpdateWithoutUnlinkedReportInput>
  }

  export type UnlinkedReportDetailUpdateManyWithWhereWithoutUnlinkedReportInput = {
    where: UnlinkedReportDetailScalarWhereInput
    data: XOR<UnlinkedReportDetailUpdateManyMutationInput, UnlinkedReportDetailUncheckedUpdateManyWithoutUnlinkedReportInput>
  }

  export type UnlinkedReportDetailScalarWhereInput = {
    AND?: UnlinkedReportDetailScalarWhereInput | UnlinkedReportDetailScalarWhereInput[]
    OR?: UnlinkedReportDetailScalarWhereInput[]
    NOT?: UnlinkedReportDetailScalarWhereInput | UnlinkedReportDetailScalarWhereInput[]
    id?: IntFilter<"UnlinkedReportDetail"> | number
    createdAt?: DateTimeFilter<"UnlinkedReportDetail"> | Date | string
    updatedAt?: DateTimeFilter<"UnlinkedReportDetail"> | Date | string
    unlinkedReportId?: IntFilter<"UnlinkedReportDetail"> | number
    data?: JsonFilter<"UnlinkedReportDetail">
  }

  export type UnlinkedReportCreateWithoutUnlinkedReportDetailInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    labelName: string
    count: number
  }

  export type UnlinkedReportUncheckedCreateWithoutUnlinkedReportDetailInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    labelName: string
    count: number
  }

  export type UnlinkedReportCreateOrConnectWithoutUnlinkedReportDetailInput = {
    where: UnlinkedReportWhereUniqueInput
    create: XOR<UnlinkedReportCreateWithoutUnlinkedReportDetailInput, UnlinkedReportUncheckedCreateWithoutUnlinkedReportDetailInput>
  }

  export type UnlinkedReportUpsertWithoutUnlinkedReportDetailInput = {
    update: XOR<UnlinkedReportUpdateWithoutUnlinkedReportDetailInput, UnlinkedReportUncheckedUpdateWithoutUnlinkedReportDetailInput>
    create: XOR<UnlinkedReportCreateWithoutUnlinkedReportDetailInput, UnlinkedReportUncheckedCreateWithoutUnlinkedReportDetailInput>
    where?: UnlinkedReportWhereInput
  }

  export type UnlinkedReportUpdateToOneWithWhereWithoutUnlinkedReportDetailInput = {
    where?: UnlinkedReportWhereInput
    data: XOR<UnlinkedReportUpdateWithoutUnlinkedReportDetailInput, UnlinkedReportUncheckedUpdateWithoutUnlinkedReportDetailInput>
  }

  export type UnlinkedReportUpdateWithoutUnlinkedReportDetailInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type UnlinkedReportUncheckedUpdateWithoutUnlinkedReportDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutRefreshTokensInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    preferences?: UserPreferencesCreateNestedManyWithoutUserInput
    comms?: UserCommsCreateNestedManyWithoutUserInput
    client?: ClientCreateNestedOneWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
    clientId?: number | null
    preferences?: UserPreferencesUncheckedCreateNestedManyWithoutUserInput
    comms?: UserCommsUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    resetToken?: PasswordResetTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: UserPreferencesUpdateManyWithoutUserNestedInput
    comms?: UserCommsUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    preferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput
    comms?: UserCommsUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserRoyaltyReportCreateManyS3FileInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    baseReportId?: number | null
    clientId?: number | null
  }

  export type BaseRoyaltyReportCreateManyS3FileInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    totalEarnings: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
  }

  export type ImportedRoyaltyReportCreateManyS3FileInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: $Enums.Distributor
    reportingMonth: string
    importStatus: string
  }

  export type UserRoyaltyReportUpdateWithoutS3FileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutUserReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutUserReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutUserReportsNestedInput
    client?: ClientUpdateOneWithoutUserRoyaltyReportNestedInput
    transactions?: TransactionUpdateManyWithoutUserReportNestedInput
  }

  export type UserRoyaltyReportUncheckedUpdateWithoutS3FileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserReportNestedInput
  }

  export type UserRoyaltyReportUncheckedUpdateManyWithoutS3FileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BaseRoyaltyReportUpdateWithoutS3FileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    userReports?: UserRoyaltyReportUpdateManyWithoutBaseReportNestedInput
    Transaction?: TransactionUpdateManyWithoutBaseReportNestedInput
  }

  export type BaseRoyaltyReportUncheckedUpdateWithoutS3FileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    userReports?: UserRoyaltyReportUncheckedUpdateManyWithoutBaseReportNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutBaseReportNestedInput
  }

  export type BaseRoyaltyReportUncheckedUpdateManyWithoutS3FileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ImportedRoyaltyReportUpdateWithoutS3FileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
    KontorRoyaltyReport?: KontorRoyaltyReportUpdateManyWithoutImportedReportNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUpdateManyWithoutImportedReportNestedInput
  }

  export type ImportedRoyaltyReportUncheckedUpdateWithoutS3FileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedUpdateManyWithoutImportedReportNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedUpdateManyWithoutImportedReportNestedInput
  }

  export type ImportedRoyaltyReportUncheckedUpdateManyWithoutS3FileInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    importStatus?: StringFieldUpdateOperationsInput | string
  }

  export type UserPreferencesCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fontSize?: string | null
    mainMenuCollapsed?: boolean | null
    theme?: string | null
    language?: string | null
  }

  export type UserCommsCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.CommsChannels
    value: string
  }

  export type LogCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    object: string
    objectId?: number | null
    message: string
    script?: string | null
    ip?: string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    isRevoked?: boolean
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    mainMenuCollapsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    mainMenuCollapsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPreferencesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    mainMenuCollapsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommsUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCommsChannelsFieldUpdateOperationsInput | $Enums.CommsChannels
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserCommsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCommsChannelsFieldUpdateOperationsInput | $Enums.CommsChannels
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserCommsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumCommsChannelsFieldUpdateOperationsInput | $Enums.CommsChannels
    value?: StringFieldUpdateOperationsInput | string
  }

  export type LogUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: StringFieldUpdateOperationsInput | string
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: StringFieldUpdateOperationsInput | string
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    object?: StringFieldUpdateOperationsInput | string
    objectId?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    script?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BalanceCreateManyClientInput = {
    id?: number
    currency?: $Enums.Currency
    amount?: Decimal | DecimalJsLike | number | string
    amountRetain?: Decimal | DecimalJsLike | number | string
    amountTerminated?: Decimal | DecimalJsLike | number | string
  }

  export type LabelCreateManyClientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    countryId?: number | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
  }

  export type UserCreateManyClientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    email: string
    password: string
    fullName?: string
    usernameDMB?: string | null
    role?: $Enums.Role
  }

  export type UserRoyaltyReportCreateManyClientInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    baseReportId?: number | null
  }

  export type BalanceUpdateWithoutClientInput = {
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactions?: TransactionUpdateManyWithoutBalanceNestedInput
  }

  export type BalanceUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transactions?: TransactionUncheckedUpdateManyWithoutBalanceNestedInput
  }

  export type BalanceUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRetain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountTerminated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LabelUpdateWithoutClientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneWithoutLabelNestedInput
    KontorRoyaltyReport?: KontorRoyaltyReportUpdateManyWithoutLabelNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedUpdateManyWithoutLabelNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutClientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: UserPreferencesUpdateManyWithoutUserNestedInput
    comms?: UserCommsUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: UserPreferencesUncheckedUpdateManyWithoutUserNestedInput
    comms?: UserCommsUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    resetToken?: PasswordResetTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    usernameDMB?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserRoyaltyReportUpdateWithoutClientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutUserRoyaltyReportNestedInput
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutUserReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutUserReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutUserReportsNestedInput
    transactions?: TransactionUpdateManyWithoutUserReportNestedInput
  }

  export type UserRoyaltyReportUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserReportNestedInput
  }

  export type UserRoyaltyReportUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionCreateManyBalanceInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    baseReportId?: number | null
    userReportId?: number | null
  }

  export type TransactionUpdateWithoutBalanceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    baseReport?: BaseRoyaltyReportUpdateOneWithoutTransactionNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionUncheckedUpdateManyWithoutBalanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientCreateManyAddressInput = {
    id?: number
    wp_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientName: string
    firstName: string
    lastName: string
    type?: $Enums.ClientType
    taxIdType: $Enums.TaxIdType
    taxId: string
    vatRegistered?: boolean
    vatId?: string | null
    status?: $Enums.ClientStatus
    isBlocked?: boolean | null
    isPaymentsBlocked?: boolean | null
    isPaymentInProgress?: boolean
    isPaymentDataInValidation?: boolean
  }

  export type ClientUpdateWithoutAddressInput = {
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    dmb?: ClientDMBUpdateOneWithoutClientNestedInput
    balances?: BalanceUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUpdateOneWithoutClientNestedInput
    labels?: LabelUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    contract?: ContractUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
    dmb?: ClientDMBUncheckedUpdateOneWithoutClientNestedInput
    balances?: BalanceUncheckedUpdateManyWithoutClientNestedInput
    paymentData?: ClientPaymentInformationUncheckedUpdateOneWithoutClientNestedInput
    labels?: LabelUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    contract?: ContractUncheckedUpdateOneWithoutClientNestedInput
    userRoyaltyReport?: UserRoyaltyReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    wp_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    taxIdType?: EnumTaxIdTypeFieldUpdateOperationsInput | $Enums.TaxIdType
    taxId?: StringFieldUpdateOperationsInput | string
    vatRegistered?: BoolFieldUpdateOperationsInput | boolean
    vatId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClientStatusFieldUpdateOperationsInput | $Enums.ClientStatus
    isBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentsBlocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isPaymentInProgress?: BoolFieldUpdateOperationsInput | boolean
    isPaymentDataInValidation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AddressCreateManyCountryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    street: string
    street2?: string | null
    city: string
    state: string
    zip: string
  }

  export type LabelCreateManyCountryInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: number
    name: string
    status?: $Enums.LabelStatus
    website?: string | null
    beatportStatus?: $Enums.LabelRegistrationStatus
    traxsourceStatus?: $Enums.LabelRegistrationStatus
    beatportUrl?: string | null
    traxsourceUrl?: string | null
  }

  export type AddressUpdateWithoutCountryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    street?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    client?: ClientUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    street?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    client?: ClientUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    street?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
  }

  export type LabelUpdateWithoutCountryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutLabelsNestedInput
    KontorRoyaltyReport?: KontorRoyaltyReportUpdateManyWithoutLabelNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    KontorRoyaltyReport?: KontorRoyaltyReportUncheckedUpdateManyWithoutLabelNestedInput
    BelieveRoyaltyReport?: BelieveRoyaltyReportUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumLabelStatusFieldUpdateOperationsInput | $Enums.LabelStatus
    website?: NullableStringFieldUpdateOperationsInput | string | null
    beatportStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    traxsourceStatus?: EnumLabelRegistrationStatusFieldUpdateOperationsInput | $Enums.LabelRegistrationStatus
    beatportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    traxsourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KontorRoyaltyReportCreateManyLabelInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type BelieveRoyaltyReportCreateManyLabelInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type KontorRoyaltyReportUpdateWithoutLabelInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReport?: BaseRoyaltyReportUpdateOneWithoutKontorReportsNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutKontorReportsNestedInput
    importedReport?: ImportedRoyaltyReportUpdateOneWithoutKontorRoyaltyReportNestedInput
  }

  export type KontorRoyaltyReportUncheckedUpdateWithoutLabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KontorRoyaltyReportUncheckedUpdateManyWithoutLabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BelieveRoyaltyReportUpdateWithoutLabelInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReport?: BaseRoyaltyReportUpdateOneWithoutBelieveReportsNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutBelieveReportsNestedInput
    importedReport?: ImportedRoyaltyReportUpdateOneWithoutBelieveRoyaltyReportNestedInput
  }

  export type BelieveRoyaltyReportUncheckedUpdateWithoutLabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BelieveRoyaltyReportUncheckedUpdateManyWithoutLabelInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KontorRoyaltyReportCreateManyImportedReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
  }

  export type BelieveRoyaltyReportCreateManyImportedReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    userReportId?: number | null
  }

  export type KontorRoyaltyReportUpdateWithoutImportedReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    label?: LabelUpdateOneWithoutKontorRoyaltyReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutKontorReportsNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutKontorReportsNestedInput
  }

  export type KontorRoyaltyReportUncheckedUpdateWithoutImportedReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KontorRoyaltyReportUncheckedUpdateManyWithoutImportedReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BelieveRoyaltyReportUpdateWithoutImportedReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    label?: LabelUpdateOneWithoutBelieveRoyaltyReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutBelieveReportsNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutBelieveReportsNestedInput
  }

  export type BelieveRoyaltyReportUncheckedUpdateWithoutImportedReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BelieveRoyaltyReportUncheckedUpdateManyWithoutImportedReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KontorRoyaltyReportCreateManyBaseReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type BelieveRoyaltyReportCreateManyBaseReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    userReportId?: number | null
    importedReportId?: number | null
  }

  export type UserRoyaltyReportCreateManyBaseReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    distributor: $Enums.Distributor
    reportingMonth: string
    totalRoyalties: number
    debitState?: $Enums.DebitState
    paidOn?: Date | string | null
    s3FileId?: number | null
    clientId?: number | null
  }

  export type TransactionCreateManyBaseReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    balanceId: number
    userReportId?: number | null
  }

  export type KontorRoyaltyReportUpdateWithoutBaseReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    label?: LabelUpdateOneWithoutKontorRoyaltyReportNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutKontorReportsNestedInput
    importedReport?: ImportedRoyaltyReportUpdateOneWithoutKontorRoyaltyReportNestedInput
  }

  export type KontorRoyaltyReportUncheckedUpdateWithoutBaseReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KontorRoyaltyReportUncheckedUpdateManyWithoutBaseReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BelieveRoyaltyReportUpdateWithoutBaseReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    label?: LabelUpdateOneWithoutBelieveRoyaltyReportNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutBelieveReportsNestedInput
    importedReport?: ImportedRoyaltyReportUpdateOneWithoutBelieveRoyaltyReportNestedInput
  }

  export type BelieveRoyaltyReportUncheckedUpdateWithoutBaseReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BelieveRoyaltyReportUncheckedUpdateManyWithoutBaseReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoyaltyReportUpdateWithoutBaseReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3File?: S3FileUpdateOneWithoutUserRoyaltyReportNestedInput
    kontorReports?: KontorRoyaltyReportUpdateManyWithoutUserReportNestedInput
    believeReports?: BelieveRoyaltyReportUpdateManyWithoutUserReportNestedInput
    client?: ClientUpdateOneWithoutUserRoyaltyReportNestedInput
    transactions?: TransactionUpdateManyWithoutUserReportNestedInput
  }

  export type UserRoyaltyReportUncheckedUpdateWithoutBaseReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    kontorReports?: KontorRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    believeReports?: BelieveRoyaltyReportUncheckedUpdateManyWithoutUserReportNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserReportNestedInput
  }

  export type UserRoyaltyReportUncheckedUpdateManyWithoutBaseReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    distributor?: EnumDistributorFieldUpdateOperationsInput | $Enums.Distributor
    reportingMonth?: StringFieldUpdateOperationsInput | string
    totalRoyalties?: FloatFieldUpdateOperationsInput | number
    debitState?: EnumDebitStateFieldUpdateOperationsInput | $Enums.DebitState
    paidOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    s3FileId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionUpdateWithoutBaseReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    balance?: BalanceUpdateOneRequiredWithoutTransactionsNestedInput
    userReport?: UserRoyaltyReportUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBaseReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    balanceId?: IntFieldUpdateOperationsInput | number
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionUncheckedUpdateManyWithoutBaseReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    balanceId?: IntFieldUpdateOperationsInput | number
    userReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KontorRoyaltyReportCreateManyUserReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    store: string
    chType?: string | null
    channelId?: string | null
    country: string
    labelName: string
    productType: string
    productTitle: string
    productArtist: string
    ean: string
    isrc: string
    grid: string
    articleNo?: string | null
    royalties: Decimal | DecimalJsLike | number | string
    units: number
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    importedReportId?: number | null
  }

  export type BelieveRoyaltyReportCreateManyUserReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: $Enums.Currency
    labelId?: number | null
    reportingMonth: string
    salesMonth: string
    platform: string
    countryRegion: string
    labelName: string
    artistName: string
    releaseTitle: string
    trackTitle: string
    upc: string
    isrc: string
    catalogNb?: string | null
    streamingSubscriptionType?: string | null
    releaseType?: string | null
    salesType?: string | null
    quantity: string
    clientPaymentCurrency?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    mechanicalFee?: Decimal | DecimalJsLike | number | string | null
    grossRevenue: Decimal | DecimalJsLike | number | string
    clientShareRate: Decimal | DecimalJsLike | number | string
    netRevenue: Decimal | DecimalJsLike | number | string
    cmg_clientRate?: Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: Decimal | DecimalJsLike | number | string | null
    baseReportId?: number | null
    importedReportId?: number | null
  }

  export type TransactionCreateManyUserReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.TransactionType
    description: string
    amount: Decimal | DecimalJsLike | number | string
    balanceAmount: Decimal | DecimalJsLike | number | string
    reversed?: boolean
    distributor?: $Enums.Distributor | null
    balanceId: number
    baseReportId?: number | null
  }

  export type KontorRoyaltyReportUpdateWithoutUserReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    label?: LabelUpdateOneWithoutKontorRoyaltyReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutKontorReportsNestedInput
    importedReport?: ImportedRoyaltyReportUpdateOneWithoutKontorRoyaltyReportNestedInput
  }

  export type KontorRoyaltyReportUncheckedUpdateWithoutUserReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type KontorRoyaltyReportUncheckedUpdateManyWithoutUserReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    store?: StringFieldUpdateOperationsInput | string
    chType?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    productTitle?: StringFieldUpdateOperationsInput | string
    productArtist?: StringFieldUpdateOperationsInput | string
    ean?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    grid?: StringFieldUpdateOperationsInput | string
    articleNo?: NullableStringFieldUpdateOperationsInput | string | null
    royalties?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    units?: IntFieldUpdateOperationsInput | number
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BelieveRoyaltyReportUpdateWithoutUserReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    label?: LabelUpdateOneWithoutBelieveRoyaltyReportNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutBelieveReportsNestedInput
    importedReport?: ImportedRoyaltyReportUpdateOneWithoutBelieveRoyaltyReportNestedInput
  }

  export type BelieveRoyaltyReportUncheckedUpdateWithoutUserReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BelieveRoyaltyReportUncheckedUpdateManyWithoutUserReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    labelId?: NullableIntFieldUpdateOperationsInput | number | null
    reportingMonth?: StringFieldUpdateOperationsInput | string
    salesMonth?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    countryRegion?: StringFieldUpdateOperationsInput | string
    labelName?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    releaseTitle?: StringFieldUpdateOperationsInput | string
    trackTitle?: StringFieldUpdateOperationsInput | string
    upc?: StringFieldUpdateOperationsInput | string
    isrc?: StringFieldUpdateOperationsInput | string
    catalogNb?: NullableStringFieldUpdateOperationsInput | string | null
    streamingSubscriptionType?: NullableStringFieldUpdateOperationsInput | string | null
    releaseType?: NullableStringFieldUpdateOperationsInput | string | null
    salesType?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: StringFieldUpdateOperationsInput | string
    clientPaymentCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mechanicalFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clientShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmg_clientRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cmg_netRevenue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
    importedReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionUpdateWithoutUserReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    balance?: BalanceUpdateOneRequiredWithoutTransactionsNestedInput
    baseReport?: BaseRoyaltyReportUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    balanceId?: IntFieldUpdateOperationsInput | number
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionUncheckedUpdateManyWithoutUserReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reversed?: BoolFieldUpdateOperationsInput | boolean
    distributor?: NullableEnumDistributorFieldUpdateOperationsInput | $Enums.Distributor | null
    balanceId?: IntFieldUpdateOperationsInput | number
    baseReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnlinkedReportDetailCreateManyUnlinkedReportInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    data: JsonNullValueInput | InputJsonValue
  }

  export type UnlinkedReportDetailUpdateWithoutUnlinkedReportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UnlinkedReportDetailUncheckedUpdateWithoutUnlinkedReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }

  export type UnlinkedReportDetailUncheckedUpdateManyWithoutUnlinkedReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: JsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}